<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Miao&#39;s Blog</title>
  
  
  <link href="http://miaohao-oops.github.io/atom.xml" rel="self"/>
  
  <link href="http://miaohao-oops.github.io/"/>
  <updated>2022-08-12T12:28:18.623Z</updated>
  <id>http://miaohao-oops.github.io/</id>
  
  <author>
    <name>MiaoHao-oops</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>记计算所夏令营经历</title>
    <link href="http://miaohao-oops.github.io/2022/07/21/%E8%AE%B0%E8%AE%A1%E7%AE%97%E6%89%80%E5%A4%8F%E4%BB%A4%E8%90%A5%E7%BB%8F%E5%8E%86/"/>
    <id>http://miaohao-oops.github.io/2022/07/21/%E8%AE%B0%E8%AE%A1%E7%AE%97%E6%89%80%E5%A4%8F%E4%BB%A4%E8%90%A5%E7%BB%8F%E5%8E%86/</id>
    <published>2022-07-21T12:39:12.000Z</published>
    <updated>2022-08-12T12:28:18.623Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>声明：本文章将不涉及任何具体的面试内容，除了熟知的英文自我介绍环节。</p></blockquote><h1 id="报名夏令营">报名夏令营</h1><p>报名过程其实没什么可说的，注意一下计算所的官网通知，按要求注册填报系统进行填报即可。另外，计算所还会单开一个问卷进行导师填报，因为当时我认定了目标就是微处理器中心，所以联系了实验室的老师后，我只报了第一志愿导师。</p><h1 id="夏令营基本情况">夏令营基本情况</h1><p>计算所是真正的 ddl 战士，官网上“六月底公布录取结果”的含义基本上就是“七月初”了，所以大可不必着急。公布入营名单后，首先计算所会给每个入营的同学发送一封邮件，说明一些具体内容，以及电子材料的提交说明（这封邮件不出意外地也是卡点发的，我收到时离 ddl 只有两分钟）。除此之外，各实验室也会根据报名情况进行单独的联系（与是否入营无关），主要是通知进行各实验室的考核，期间要保持邮箱和手机的畅通。</p><p>夏令营一般就在公布入营名单的下一周开营，夏令营活动基本上是讲座 + 各实验室的招生宣讲，可以根据自己的兴趣选听，时间在 2 天左右。这两天的活动结束后，就进入了各实验室的考核环节，<strong>根据实验室的不同，可能会安排笔试、机试和面试</strong>，一般面试是必不可少的，一些报名人数比较多的实验室通常会安排笔试和机试。</p><h1 id="面试过程中的心路历程">面试过程中的心路历程</h1><p>因为我只报了第一志愿导师，因此也只收到了微处理器中心的面试通知，而微处理器中心的考核方式只有面试，最后我也成功通过了面试。虽然只有面试，但我十分地紧张，从头一天晚上一直提心吊胆到进入面试的会议。</p><p>回想起来上次参加这种“决定人生走向”的面试，还是 3 年前进入国科大之前的“综合评价”面试。那次面试经历给我留下了不小的阴影。它的面试形式是 4 - 5 人一组一起面试，而我记得和我同组的有一位口才非常好的人大附同学，对老师所提出的任何问题，他都能侃侃而谈，而我却是闷不作声，这让我感到十分的自卑。对于我这种从小就十分内向的人来说，面试那十几分钟简直能要了我的命，因此我一度十分反感这种“以口才论英雄”的考核形式。但是出乎意料的是，最后我的综合评价成绩竟然还不错，最后我也通过综合评价的方式走进了国科大的校园。</p><p>回到这次面试，虽然在面试的前一天，实验室就已经发通知明确了面试的基本内容（之前我也向学长咨询了一些），但我仍然十分恐惧。恐惧的来源是对自己极度的不自信，我常常会想“要是英文自我介绍的时候卡壳了怎么办？”“要是老师提的问题我答不上来怎么办？”等等。我的脑中常常模拟出一些我处境十分难堪的场景，随之而来的是心跳加速，精神也变得紧张。因为我被安排到下午进行面试，因此我度过了一个十分煎熬的上午。在精神极度紧张的情况下，即使开着空调，我仍然满头大汗，并且没办法坐下来安心地“复习”英文自我介绍：每隔几分钟，我必须要离开座位，到屋子里走一圈，才能回到座位上再待几分钟。</p><p>混混噩噩地度过了一上午，终于，面试组秘书在群里 @ 了我，通知我进入会议。我已经完全想不起来当时以什么心情进入会议，但是奇怪的是，进入之后我的心情竟然平静了下来。这种感觉就好像紧张的我发生了一次“中断”，然后由另一个我接管了对我的控制。面试过程非常顺利，英文自我介绍没有卡壳，老师的问题我也一一回答，并且提前十多分钟就结束了面试。最后，在所有面试结束后不到半个小时，我收到了面试通过的消息，总算是有了一个结果。</p><h1 id="后记">后记</h1><p>最离奇的经历无非就是面试过程中的“中断”，那么“另一个我”到底是谁呢？也许是我的深层的意识。这也许与我在学习中一贯采取的“不求甚解”的方法论有关系。</p><p>所谓的“不求甚解”，指的是我在学习知识时，尤其是第一次学习新东西时，通常遇到我无法理解的东西，不会花过多的时间和经历“死磕”。这不是矛盾的吗？什么东西都不弄懂，那最后不是什么都没学会？第一次没搞明白的东西，其实在试图理解的这个过程中，大脑已经在不知不觉中加深了印象，只是我自己还不认可。那么，当未来的某个时间点，又遇到它的时候，原来的印象迅速地被调用出来，在完全不同的情景、灵感下，很容易对之前不理解的东西产生新的启发。虽然新的探索可能仍然是失败的，但是它又进一步加深了大脑对知识的印象。久而久之，一般三五次，在不同的启发之下，许多知识便被我不自觉地掌握了。</p>]]></content>
    
    
    <summary type="html">2022 年 7 月 21 日，我参加了中科院计算所微处理器中心的夏令营面试，在此记录整个过程。</summary>
    
    
    
    <category term="blog" scheme="http://miaohao-oops.github.io/categories/blog/"/>
    
    
  </entry>
  
  <entry>
    <title>chisel 使用浅测</title>
    <link href="http://miaohao-oops.github.io/2022/06/02/chisel%E4%BD%BF%E7%94%A8%E6%B5%85%E6%B5%8B/"/>
    <id>http://miaohao-oops.github.io/2022/06/02/chisel%E4%BD%BF%E7%94%A8%E6%B5%85%E6%B5%8B/</id>
    <published>2022-06-02T00:58:59.000Z</published>
    <updated>2022-06-02T03:36:24.901Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是-chisel">什么是 chisel</h2><p>关于“什么是 chisel”这个问题，在网上已经有了详尽的讨论：它是硬件描述语言，它是 scala 的包等等。在我的使用范畴下，我认为它是一个编译器，依托于 scala 包的形式存在，有些类似于 LLVM 以库的形式存在的特点。它具有编译器的特点：源语言是 scala，目标语言是 verilog，此外还具有中间表示 FIRRTL。chisel 的工作过程可以理解为：通过在 scala 代码中调用一些 chisel 包中的类和方法，再运行这段 scala 代码，产生可综合的 verilog。</p><h2 id="chisel-的优势">chisel 的优势</h2><p>chisel 的敏捷性源于它更高层次的抽象以及 scala 语言本身面向对象、函数式的特点。</p><h3 id="丰富的数据类型">丰富的数据类型</h3><p>下面是 <a href="https://www.chisel-lang.org/">chisel 官网</a> 中数据类型的继承关系图：</p><p><img src="/img/chisel_type_hierarchy.svg" /></p><p>比较常用的数据类型有 <code>UInt</code>，<code>SInt</code>，<code>Bool</code>，<code>Clock</code> 和 <code>Reset</code>。此外还可以通过 <code>Vec</code> 和 <code>Bundle</code> 将它们聚集起来，<code>Vec</code> 用于聚集相同的类型，而 <code>Bundle</code> 用于聚集不同的类型。</p><h3 id="简单的硬件模型">简单的硬件模型</h3><p>在 chisel 中的硬件模型只有两种：线网 <code>Wire</code> 和寄存器 <code>Reg</code>，并且使用了 <code>Reg</code> 声明的变量最终一定会产生寄存器，而不像 verilog 一样不能确定。</p><p>声明一个硬件需要将数据类型和硬件模型结合起来使用：</p><figure class="highlight scala"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> foo = <span class="hljs-type">Wire</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">32.</span><span class="hljs-type">W</span>))<br><span class="hljs-keyword">val</span> bar = <span class="hljs-type">Reg</span>(<span class="hljs-type">Bool</span>())<br></code></pre></td></tr></table></figure><p><code>foo</code> 描述了一个 32 位宽的线，<code>bar</code> 描述了一个 1 位宽的寄存器。需要注意的是，在 chisel 中的时钟和复位信号是隐含的，<code>Reg</code> 默认使用该寄存器所在模块的同步时钟和复位信号。</p><h3 id="自定义类型">自定义类型</h3><p>在编写 verilog 时，常常因为散乱的接口而难以维护，陷入“设计一小时，模块编码一小时，接线两小时”的窘境，chisel 的自定义类型解决了这一问题。</p><h4 id="bundle-继承">Bundle 继承</h4><p>通过继承 <code>Bundle</code> 类，用户可以自定义线束类型，将不同类型的线聚集起来：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBundle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Bundle</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> src = <span class="hljs-type">Vec</span>(<span class="hljs-number">2</span>, <span class="hljs-type">UInt</span>(<span class="hljs-number">32.</span><span class="hljs-type">W</span>))<br>  <span class="hljs-keyword">val</span> op = <span class="hljs-type">Vec</span>(<span class="hljs-number">12</span>, <span class="hljs-type">Bool</span>())<br>&#125;<br></code></pre></td></tr></table></figure><p>定义了由两个 32 位操作数 <code>src</code> 和一个 12 位操作码 <code>op</code> 所组成的线束。在模块中，可以使用自定义类型产生硬件并对其进行连接：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> myBundle = <span class="hljs-type">Wire</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">MyBundle</span>)<br>myBundle.src(<span class="hljs-number">0</span>) := <span class="hljs-number">0.</span><span class="hljs-type">U</span><br>myBundle.src(<span class="hljs-number">1</span>) := <span class="hljs-number">1.</span><span class="hljs-type">U</span><br>myBundle.op := <span class="hljs-string">&quot;b000100&quot;</span>.<span class="hljs-type">U</span><br></code></pre></td></tr></table></figure><h4 id="module-继承">Module 继承</h4><p>Module 是电路中基本组成单元，chisel 中的模块同样抽象为 IO 接口和内部逻辑，通过继承 Module 可以自定义模块：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyModule</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Module</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> io = <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Bundle</span>()&#123;<br>    <span class="hljs-keyword">val</span> in = <span class="hljs-type">Input</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">MyBundle</span>)<br>    <span class="hljs-keyword">val</span> out = <span class="hljs-type">Output</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Bundle</span>()&#123;<br>      <span class="hljs-keyword">val</span> res = <span class="hljs-type">UInt</span>(<span class="hljs-number">32.</span><span class="hljs-type">W</span>)<br>    &#125;)<br>  &#125;)<br><br>  io.out.res := <span class="hljs-type">Mux1H</span>(<span class="hljs-type">Seq</span>(<br>    io.in.op(<span class="hljs-number">0</span>) -&gt; io.in.src(<span class="hljs-number">0</span>) + io.in.src(<span class="hljs-number">1</span>),<br>    io.in.op(<span class="hljs-number">1</span>) -&gt; io.in.src(<span class="hljs-number">0</span>) - io.in.src(<span class="hljs-number">1</span>),<br>    ...<br>  ))<br>&#125;<br></code></pre></td></tr></table></figure><p>定义了一个使用 12 位独热码作为操作码的 alu 模块。其中值 <code>io</code> 定义了该模块的 IO 接口。为了创建它，定义了一个匿名的 Bundle 对象，其中包含 <code>in</code> 和 <code>out</code> 分别定义输入接口和输出接口。定义 IO 接口中的 3 个方法 <code>IO</code>，<code>Input</code> 和 <code>Output</code> 接受的参数都是 <code>Bundle</code> 的对象，因此在这里可以使用自定义的线束类型。<code>MyModule</code> 中剩余部分是该模块的内部逻辑，这里使用了原语 <code>Mux1H</code> 生成一个独热码选择器。</p><h4 id="快速连接模块">快速连接模块</h4><p>chisel 中基本的连接算符是 <code>:=</code> ，信号的流动方向是从右向左。chisel 中还提供了一种 element-wise 的连接算符 <code>&lt;&gt;</code>，它可以快速连接线束中的<strong>同名元素</strong>，并检查其类型是否相同：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyModuleWrap</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Module</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> io = <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Bundle</span>()&#123;<br>    <span class="hljs-keyword">val</span> in = <span class="hljs-type">Input</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">MyBundle</span>)<br>    <span class="hljs-keyword">val</span> out = <span class="hljs-type">Output</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Bundle</span>()&#123;<br>      <span class="hljs-keyword">val</span> res = <span class="hljs-type">UInt</span>(<span class="hljs-number">32.</span><span class="hljs-type">W</span>)<br>    &#125;)<br>  &#125;)<br>  <span class="hljs-keyword">val</span> myAlu = <span class="hljs-type">Module</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">MyModule</span>)<br><br>  myAlu.io&lt;&gt;io<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="强大的语法检查">强大的语法检查</h3><p>正如上文所提到的，在 chisel 进行编译时，编译器将检查连接左右硬件的数据类型是否相同，若不同则报错，停止编译。实际上，chisel 编译器还做了更多的事情，能够帮助在编码时就检查出一些设计功能无关的错误，节省开发时间。</p><h3 id="参数化模块">参数化模块</h3><p>由于所有类型的定义都是基于 scala 的类，因此可以使用类的初始化参数对模块进行参数化定义：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBundle</span>(<span class="hljs-params">xLen:<span class="hljs-type">Int</span> = 32</span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Bundle</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> src = <span class="hljs-type">Vec</span>(<span class="hljs-number">2</span>, <span class="hljs-type">UInt</span>(xLen.<span class="hljs-type">W</span>))<br>  <span class="hljs-keyword">val</span> op = <span class="hljs-type">Vec</span>(<span class="hljs-number">12</span>, <span class="hljs-type">Bool</span>())<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyModule</span>(<span class="hljs-params">xLen:<span class="hljs-type">Int</span> = 32</span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Module</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> io = <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Bundle</span>()&#123;<br>    <span class="hljs-keyword">val</span> in = <span class="hljs-type">Input</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">MyBundle</span>(xLen))<br>    <span class="hljs-keyword">val</span> out = <span class="hljs-type">Output</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Bundle</span>()&#123;<br>      <span class="hljs-keyword">val</span> res = <span class="hljs-type">UInt</span>(xLen.<span class="hljs-type">W</span>)<br>    &#125;)<br>  &#125;)<br><br>  io.out.res := <span class="hljs-type">Mux1H</span>(<span class="hljs-type">Seq</span>(<br>    io.in.op(<span class="hljs-number">0</span>) -&gt; io.in.src(<span class="hljs-number">0</span>) + io.in.src(<span class="hljs-number">1</span>),<br>    io.in.op(<span class="hljs-number">1</span>) -&gt; io.in.src(<span class="hljs-number">0</span>) - io.in.src(<span class="hljs-number">1</span>),<br>    ...<br>  ))<br>&#125;<br></code></pre></td></tr></table></figure><p>在实例化模块时，可以通过改变传入的参数定制不同的模块：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> myModule1 = <span class="hljs-type">Module</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">MyModule</span>(<span class="hljs-number">16</span>))<br><span class="hljs-keyword">val</span> myModule2 = <span class="hljs-type">Module</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">MyModule</span>(<span class="hljs-number">32</span>))<br></code></pre></td></tr></table></figure><h3 id="scala-集合类型和函数式编程">scala 集合类型和函数式编程</h3><p>集合类型和函数式编程都是 scala 的语言特性，由于 chisel 是 scala 的包，因此可以使用这些特性用于构造硬件生成器。</p><p>比如说对于设计 CPU 核而言，一个明显的集合是<strong>指令集</strong>，在 chisel 中，可以将所有指令放到一个查找表中，利用 scala 的 <code>ListLookUp</code> 方法生成译码逻辑：</p><ol type="1"><li>首先，构造查找表，它使用一个指令作为索引，查找结果是控制信号：</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">DecodeConstants</span> </span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">CtrlIdx</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">scala</span>.<span class="hljs-title">Enumeration</span> </span>&#123;<br>    <span class="hljs-keyword">val</span> selSrc0, selSrc1, selImm, selWnum, fuType, fuOp, rfWen, illegal = <span class="hljs-type">Value</span><br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">default</span></span>: <span class="hljs-type">List</span>[<span class="hljs-type">UInt</span>] = <span class="hljs-comment">// no instruction</span><br>  <span class="hljs-comment">//     SelSrc(0)</span><br>  <span class="hljs-comment">//     |   SelSrc(1)</span><br>  <span class="hljs-comment">//     |   |   SelImm</span><br>  <span class="hljs-comment">//     |   |   |    SelWnum</span><br>  <span class="hljs-comment">//     |   |   |    |      FuType</span><br>  <span class="hljs-comment">//     |   |   |    |      |    FuOp</span><br>  <span class="hljs-comment">//     |   |   |    |      |    |    rfWen</span><br>  <span class="hljs-comment">//     |   |   |    |      |    |    |  illegal</span><br>    <span class="hljs-type">List</span>(rs, rt, nan, dzero, alu, sll, f, t)<br>  <span class="hljs-keyword">val</span> table: <span class="hljs-type">Array</span>[(<span class="hljs-type">BitPat</span>, <span class="hljs-type">List</span>[<span class="hljs-type">UInt</span>])]<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">MIPS32I</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">DecodeConstants</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> table: <span class="hljs-type">Array</span>[(<span class="hljs-type">BitPat</span>, <span class="hljs-type">List</span>[<span class="hljs-type">UInt</span>])] = <span class="hljs-type">Array</span>(<br>    <span class="hljs-type">SLL</span>   -&gt; rTypeRAlu(sll),<br>    <span class="hljs-type">SRL</span>   -&gt; rTypeRAlu(srl),<br>    <span class="hljs-type">SRA</span>   -&gt; rTypeRAlu(sra),<br><br>    <span class="hljs-type">JR</span>    -&gt; rTypeJr(jumpr),<br><br>    <span class="hljs-type">ADDU</span>  -&gt; rTypeRAlu(add),<br>    <span class="hljs-type">SUBU</span>  -&gt; rTypeRAlu(sub),<br><br>    <span class="hljs-type">AND</span>   -&gt; rTypeRAlu(and),<br>    <span class="hljs-type">OR</span>    -&gt; rTypeRAlu(or),<br>    <span class="hljs-type">XOR</span>   -&gt; rTypeRAlu(xor),<br>    <span class="hljs-type">NOR</span>   -&gt; rTypeRAlu(nor),<br>    <span class="hljs-type">SLT</span>   -&gt; rTypeRAlu(slt),<br>    <span class="hljs-type">SLTU</span>  -&gt; rTypeRAlu(sltu),<br><br>    <span class="hljs-type">JAL</span>   -&gt; jTypeJal(jump),<br><br>    <span class="hljs-type">BEQ</span>   -&gt; iTypeBr(beq),<br>    <span class="hljs-type">BNE</span>   -&gt; iTypeBr(bne),<br><br>    <span class="hljs-type">ADDIU</span> -&gt; iTypeUAlu(add),<br><br>    <span class="hljs-type">LUI</span>   -&gt; iTypeUAlu(lui),<br><br>    <span class="hljs-type">LW</span>    -&gt; iTypeLd(lw),<br><br>    <span class="hljs-type">SW</span>    -&gt; iTypeSt(sw)<br>  )<br>&#125;<br></code></pre></td></tr></table></figure><p><code>table</code> 定义了所需要的查找表，它的表项是一系列键-值对，键-值对在 scala 中使用 <code>-&gt;</code> 表示，左边是键，右边是值。在查找表中，所有键的类型都是 <code>BitPat</code>，它是 chisel 中的一种用于做二进制串模式匹配的类型；所有值的类型都是 <code>List[UInt]</code>，即由 <code>UInt</code> 对象组成的列表，用于表示某条指令对应的控制信号的具体取值。</p><ol start="2" type="1"><li>定义控制信号的线束：</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ControlSignals</span>(<span class="hljs-params">xLen:<span class="hljs-type">Int</span> = 32</span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Bundle</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> selSrc0 = <span class="hljs-type">UInt</span>()<br>  <span class="hljs-keyword">val</span> selSrc1 = <span class="hljs-type">UInt</span>()<br>  <span class="hljs-keyword">val</span> selImm = <span class="hljs-type">UInt</span>()<br>  <span class="hljs-keyword">val</span> selWnum = <span class="hljs-type">UInt</span>()<br>  <span class="hljs-keyword">val</span> fuType = <span class="hljs-type">UInt</span>()<br>  <span class="hljs-keyword">val</span> fuOp = <span class="hljs-type">UInt</span>()<br>  <span class="hljs-keyword">val</span> rfWen = <span class="hljs-type">Bool</span>()<br>  <span class="hljs-keyword">val</span> illegal = <span class="hljs-type">Bool</span>()<br><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">signals</span> </span>= <span class="hljs-type">Array</span>(<br>    <span class="hljs-type">MIPS32I</span>.<span class="hljs-type">CtrlIdx</span>.selSrc0 -&gt; selSrc0,<br>    <span class="hljs-type">MIPS32I</span>.<span class="hljs-type">CtrlIdx</span>.selSrc1 -&gt; selSrc1,<br>    <span class="hljs-type">MIPS32I</span>.<span class="hljs-type">CtrlIdx</span>.selImm -&gt; selImm,<br>    <span class="hljs-type">MIPS32I</span>.<span class="hljs-type">CtrlIdx</span>.selWnum -&gt; selWnum,<br>    <span class="hljs-type">MIPS32I</span>.<span class="hljs-type">CtrlIdx</span>.fuType -&gt; fuType,<br>    <span class="hljs-type">MIPS32I</span>.<span class="hljs-type">CtrlIdx</span>.fuOp -&gt; fuOp,<br>    <span class="hljs-type">MIPS32I</span>.<span class="hljs-type">CtrlIdx</span>.rfWen -&gt; rfWen,<br>    <span class="hljs-type">MIPS32I</span>.<span class="hljs-type">CtrlIdx</span>.illegal -&gt; illegal<br>  )<br>&#125;<br></code></pre></td></tr></table></figure><p>这里没有指定信号的位宽，在编译时 chisel 将自动推导出它们的宽度。另外，定义了 <code>signal</code> 方法，它返回一个 <code>Array</code>，存储这些信号在查找结果中的索引和具体信号值的键-值对，方便在模块中对其进行迭代。</p><ol start="3" type="1"><li>定义译码模块：</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Instruction</span>(<span class="hljs-params">xLen:<span class="hljs-type">Int</span> = 32</span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Bundle</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> instr = <span class="hljs-type">UInt</span>(xLen.<span class="hljs-type">W</span>)<br>  <span class="hljs-keyword">val</span> pc = <span class="hljs-type">UInt</span>(xLen.<span class="hljs-type">W</span>)<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ControlIO</span>(<span class="hljs-params">xLen:<span class="hljs-type">Int</span> = 32</span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Bundle</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> in = <span class="hljs-type">Input</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Instruction</span>(xLen))<br>  <span class="hljs-keyword">val</span> out = <span class="hljs-type">Output</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">ControlSignals</span>(xLen))<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Control</span>(<span class="hljs-params">xLen:<span class="hljs-type">Int</span> = 32</span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Module</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> io = <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">ControlIO</span>(xLen))<br><br>  <span class="hljs-keyword">val</span> ctrlSignals = <span class="hljs-type">ListLookup</span>(io.in.instr, <span class="hljs-type">MIPS32I</span>.<span class="hljs-keyword">default</span>, <span class="hljs-type">MIPS32I</span>.table)<br>  io.out.signals.map(x =&gt; x._2 := ctrlSignals(x._1.id))<br>&#125;<br></code></pre></td></tr></table></figure><p>译码模块 <code>Control</code> 的输入是一条指令及其对应的 <code>pc</code>，输出是控制信号。该模块的巧妙之处在于控制信号的生成。</p><p>首先，使用 <code>ListLookup</code> 方法对之前构建的查找表进行查找，查找的结果是一个 <code>UInt</code> 组成的 <code>List</code>，将其存储在 <code>ctrlSignals</code> 中。</p><p>然后调用 <code>Array</code>（<code>io.out.signals</code> 方法返回一个 <code>Array</code>）的 <code>map</code> 方法进行迭代。该方法传入了一个匿名函数 <code>x =&gt; x._2 := ctrlSignals(x._1.id)</code>，它将 <code>Array</code>中的每一项取出，使用该项的键索引查找结果，然后将其连接到对应的值上。最终的效果是将查找结果的每一项都连接到了对应的控制信号上。</p><h3 id="scala-泛型">scala 泛型</h3><p>由于 scala 泛型的存在，可以对电路进行更高层次的抽象。</p><p>比如说对于流水线寄存器而言，可以将其抽象为：</p><ol type="1"><li>IO 接口：</li></ol><table><thead><tr class="header"><th style="text-align: center;">名称</th><th style="text-align: center;">方向</th><th style="text-align: center;">说明</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">io.in.data.valid</td><td style="text-align: center;">input</td><td style="text-align: center;">输入数据有效</td></tr><tr class="even"><td style="text-align: center;">io.in.data.bits</td><td style="text-align: center;">input</td><td style="text-align: center;">输入数据</td></tr><tr class="odd"><td style="text-align: center;">io.in.stall</td><td style="text-align: center;">input</td><td style="text-align: center;">流水级暂停</td></tr><tr class="even"><td style="text-align: center;">io.in.flush</td><td style="text-align: center;">input</td><td style="text-align: center;">流水级冲刷</td></tr><tr class="odd"><td style="text-align: center;">io.out.data.valid</td><td style="text-align: center;">output</td><td style="text-align: center;">输出数据有效</td></tr><tr class="even"><td style="text-align: center;">io.out.data.bits</td><td style="text-align: center;">outptu</td><td style="text-align: center;">输出数据</td></tr></tbody></table><ol start="2" type="1"><li>内部逻辑（伪代码）：</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StageReg</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Module</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> io = <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">StageRegIO</span>)<br><br>  <span class="hljs-keyword">val</span> validReg = <span class="hljs-type">Reg</span>(<span class="hljs-type">Bool</span>())<br>  <span class="hljs-keyword">val</span> dataReg = <span class="hljs-type">Reg</span>(<span class="hljs-type">DataType</span>())<br><br>  when(reset.asBool || io.in.flush) &#123;<br>    validReg := <span class="hljs-number">0.</span><span class="hljs-type">U</span><br>  &#125; .elsewhen(!io.in.stall) &#123;<br>    validReg := io.in.data.valid<br>  &#125;<br><br>  when (!io.in.stall) &#123;<br>    dataReg := io.in.data.bits<br>  &#125;<br><br>  io.out.data.valid := validReg<br>  io.out.data.bits := dataReg<br>&#125;<br></code></pre></td></tr></table></figure><p>在实际使用中，IO 接口和内部逻辑都是不变的，发生变化的是输入数据的类型 <code>DataType</code>，因此可以对于输入的数据类型使用泛型：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StageRegIn</span>[<span class="hljs-type">T</span>&lt;:<span class="hljs-type">Bundle</span>](<span class="hljs-params">xLen:<span class="hljs-type">Int</span> = 32, dataType: <span class="hljs-type">T</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Bundle</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> stall = <span class="hljs-type">Input</span>(<span class="hljs-type">Bool</span>())<br>  <span class="hljs-keyword">val</span> flush = <span class="hljs-type">Input</span>(<span class="hljs-type">Bool</span>())<br>  <span class="hljs-keyword">val</span> data = <span class="hljs-type">Flipped</span>(<span class="hljs-type">Valid</span>(dataType))<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StageRegOut</span>[<span class="hljs-type">T</span>&lt;:<span class="hljs-type">Bundle</span>](<span class="hljs-params">xLen:<span class="hljs-type">Int</span> = 32, dataType: <span class="hljs-type">T</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Bundle</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> data = <span class="hljs-type">Valid</span>(dataType)<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StageRegIO</span>[<span class="hljs-type">T</span>&lt;:<span class="hljs-type">Bundle</span>](<span class="hljs-params">xLen:<span class="hljs-type">Int</span> = 32, dataType: <span class="hljs-type">T</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Bundle</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> in = <span class="hljs-keyword">new</span> <span class="hljs-type">StageRegIn</span>(xLen, dataType)<br>  <span class="hljs-keyword">val</span> out = <span class="hljs-keyword">new</span> <span class="hljs-type">StageRegOut</span>(xLen, dataType)<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StageReg</span>[<span class="hljs-type">T</span>&lt;:<span class="hljs-type">Bundle</span>](<span class="hljs-params">xLen:<span class="hljs-type">Int</span> = 32, dataType: <span class="hljs-type">T</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Module</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> io = <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">StageRegIO</span>(xLen, dataType))<br><br>  <span class="hljs-keyword">val</span> validReg = <span class="hljs-type">Reg</span>(<span class="hljs-type">Bool</span>())<br>  <span class="hljs-keyword">val</span> dataReg = <span class="hljs-type">Reg</span>(dataType)<br><br>  when(reset.asBool || io.in.flush) &#123;<br>    validReg := <span class="hljs-number">0.</span><span class="hljs-type">U</span><br>  &#125; .elsewhen(!io.in.stall) &#123;<br>    validReg := io.in.data.valid<br>  &#125;<br><br>  when (!io.in.stall) &#123;<br>    dataReg := io.in.data.bits<br>  &#125;<br><br>  io.out.data.valid := validReg<br>  io.out.data.bits := dataReg<br>&#125;<br></code></pre></td></tr></table></figure><p>在实例化一个流水级寄存器时，可以传入自定义类型以定制寄存器的输入输出数据类型：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> myStageReg = <span class="hljs-type">Module</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">StageReg</span>(<span class="hljs-number">32</span>, <span class="hljs-keyword">new</span> <span class="hljs-type">MyBundle</span>))<br></code></pre></td></tr></table></figure><h2 id="chisel-的劣势">chisel 的劣势</h2><h3 id="学习成本高">学习成本高</h3><p>chisel 是基于 scala 开发的包，因此使用 chisel 需要先学习 scala。相比于 C 而言，scala 是一门完全不同的语言，其中面向对象、函数式编程的特性是 C 所不具备的，需要从头学习。之所以需要学习这些高级特性，是因为只有使用了这些特性才能充分利用 chisel 的优势，否则 chisel 的使用体验和 verilog 差不多。</p><h3 id="对工业级开发流程支持尚不完善">对工业级开发流程支持尚不完善</h3><p>目前，我只把 chisel 当作一个工具，用于使用更少、更易于维护的代码生成 verilog，然后将 verilog 导入 vivado 工程，作为 SOC 的一部分进行仿真、综合、实现、比特流生成和上板。虽然 chisel 中包含测试模块，但是它完全不支持对于 IP 核的调用。</p><h2 id="参考资料">参考资料</h2><ul><li><p><a href="https://www.chisel-lang.org/chisel3/docs/introduction.html">chisel 官方文档</a>：包含了一些 chisel 的基本使用方法</p></li><li><p><a href="https://www.chisel-lang.org/api/latest/index.html">chisel API 文档</a>：包含所有 chisel API 的原型和使用方法</p></li><li><p><a href="https://github.com/freechipsproject/chisel-bootcamp">chisel bootcamp</a>：一个 chisel/scala 从零入门教程</p></li></ul>]]></content>
    
    
    <summary type="html">chisel 是一门新兴的敏捷硬件描述语言，在使用了“几天”后，我打算写这篇评测。</summary>
    
    
    
    <category term="note" scheme="http://miaohao-oops.github.io/categories/note/"/>
    
    
    <category term="硬件描述语言" scheme="http://miaohao-oops.github.io/tags/%E7%A1%AC%E4%BB%B6%E6%8F%8F%E8%BF%B0%E8%AF%AD%E8%A8%80/"/>
    
    <category term="chisel" scheme="http://miaohao-oops.github.io/tags/chisel/"/>
    
  </entry>
  
  <entry>
    <title>使用 nginx 在服务器上反向代理 Tomcat</title>
    <link href="http://miaohao-oops.github.io/2022/05/02/%E4%BD%BF%E7%94%A8nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86Tomcat/"/>
    <id>http://miaohao-oops.github.io/2022/05/02/%E4%BD%BF%E7%94%A8nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86Tomcat/</id>
    <published>2022-05-02T07:30:35.000Z</published>
    <updated>2022-06-02T03:36:14.652Z</updated>
    
    <content type="html"><![CDATA[<h2 id="反向代理概述">反向代理概述</h2><p>在服务器上使用 nginx 软件并添加相关配置就可以实现反向代理。所谓反向代理，就是通过访问代理服务器（安装并配置了 nginx）的特定端口或域名，将访问请求转发到其他服务器或其他服务上。举例来说，我在服务器上运行了 Tomcat 软件，它打开的是 <code>localhost:8080</code>，现在我想通过服务器的 IP 地址从外网访问 Tomcat 服务（比如：<code>服务器IP:8082</code>），那么这时就可以使用 nginx 进行反向代理。在上面的例子里，nginx 的大致工作过程是：经过配置后，nginx 将开始监听服务器的 <code>8082</code> 端口，当服务器收到来自 <code>8082</code> 端口的访问请求时，nginx 将请求转发到 <code>localhost:8080</code>，返回数据也是同样的过程，相当于 nginx 在中间起到了仲裁的作用。</p><h2 id="配置过程">配置过程</h2><p>我的服务器上的 nginx 配置文件位于 <code>/usr/local/nginx/conf/nginx.conf</code> 中，在文件的 <code>http&#123; ... &#125;</code> 大括号中加入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs conf">server<br>&#123;<br>    listen 8082;<br>    server_name _;<br><br>    location / &#123;<br>        proxy_pass http://localhost:8080/;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后重启 nginx （我这里使用的是 lnmp，也可以使用不同的方法重启 nginx）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo lnmp nginx restart<br></code></pre></td></tr></table></figure><p>现在，在浏览器的地址栏输入 <code>服务器IP:8082</code>，就可以访问运行在服务器上的 Tomcat服务了。</p><h2 id="小插曲">小插曲</h2><p>实际上在配置完成后我并不能直接访问服务器的 <code>8082</code> 端口，这是因为我使用的阿里云服务器没有对外打开这个端口。需要进入阿里云控制台，在防火墙配置中将该端口打开才能正常访问。</p>]]></content>
    
    
    <summary type="html">记录一下如何在一台服务器上配置 nginx 使得通过外网的某个接口访问 Tomcat 服务。</summary>
    
    
    
    <category term="note" scheme="http://miaohao-oops.github.io/categories/note/"/>
    
    
    <category term="软件配置" scheme="http://miaohao-oops.github.io/tags/%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/"/>
    
    <category term="计算机网络" scheme="http://miaohao-oops.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>三月三十一日于西北食堂用午餐作诗一首</title>
    <link href="http://miaohao-oops.github.io/2022/04/01/%E4%B8%89%E6%9C%88%E4%B8%89%E5%8D%81%E4%B8%80%E6%97%A5%E4%BA%8E%E8%A5%BF%E5%8C%97%E9%A3%9F%E5%A0%82%E7%94%A8%E5%8D%88%E9%A4%90%E4%BD%9C%E8%AF%97%E4%B8%80%E9%A6%96/"/>
    <id>http://miaohao-oops.github.io/2022/04/01/%E4%B8%89%E6%9C%88%E4%B8%89%E5%8D%81%E4%B8%80%E6%97%A5%E4%BA%8E%E8%A5%BF%E5%8C%97%E9%A3%9F%E5%A0%82%E7%94%A8%E5%8D%88%E9%A4%90%E4%BD%9C%E8%AF%97%E4%B8%80%E9%A6%96/</id>
    <published>2022-04-01T00:27:03.000Z</published>
    <updated>2022-04-01T00:32:24.930Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/0401-1.jpg" /></p><blockquote><p>三奎肉饭十六元，三两口就全吃完。<br />西北食堂物价高，以后换个小点盘。</p></blockquote>]]></content>
    
    
    <summary type="html">最近校园食堂问题频发，无论是卫生还是菜品质量，抑或是价格。昨天中午在西北食堂点了一份16元的蜜汁三奎肉盖饭，结果做出来的量只有盘子的一半不到，遂作此打油诗。</summary>
    
    
    
    <category term="blog" scheme="http://miaohao-oops.github.io/categories/blog/"/>
    
    
  </entry>
  
  <entry>
    <title>LR(0)分析方法</title>
    <link href="http://miaohao-oops.github.io/2022/03/29/LR-0-%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95/"/>
    <id>http://miaohao-oops.github.io/2022/03/29/LR-0-%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95/</id>
    <published>2022-03-29T01:16:46.000Z</published>
    <updated>2022-03-29T07:30:30.314Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概念">基本概念</h2><h3 id="项目-item">项目 item</h3><blockquote><p>项目是对文法中产生式的扩展，通过在产生式右部添加<span class="math inline">\(\cdot\)</span>的方法来表示语法分析器在分析过程中的某个状态。</p></blockquote><p>例子：</p><p>对于产生式<span class="math inline">\(A\rightarrow \alpha X\)</span>，它产生以下几个项：</p><p><span class="math display">\[\begin{align}A&amp;\rightarrow \cdot \alpha X &amp;(1)\\ A&amp;\rightarrow \alpha \cdot X &amp;(2)\\ A&amp;\rightarrow \alpha X \cdot &amp;(3)\\ \end{align}\]</span></p><p>其中，</p><ul><li><p>式<span class="math inline">\((1)\)</span>的点号右侧是一个终结符，意味着在当前状态下，分析器期待从输入流中读入符号<span class="math inline">\(\alpha\)</span>，因此它被定义为一个<strong>移入项</strong>。</p></li><li><p>式<span class="math inline">\((2)\)</span>中点号右侧是一个非终结符，此时分析器期待后面的输入归约得到非终结符<span class="math inline">\(X\)</span>，因此它被定义为一个<strong>待约项</strong>。</p></li><li><p>式<span class="math inline">\((3)\)</span>的点号位于整个产生式的结尾，此时意味着分析器将进行归约操作，将<span class="math inline">\(\alpha X\)</span>归约为<span class="math inline">\(A\)</span>，因此它被定义为一个<strong>归约项</strong>。</p></li></ul><h3 id="增广文法-augmented-grammar">增广文法 augmented grammar</h3><p>为了得到唯一的终止产生式，定义一个文法<span class="math inline">\(G\)</span>的增广文法<span class="math inline">\(G^{\prime}\)</span>：</p><blockquote><p>对于文法<span class="math inline">\(G\)</span>的开始符号<span class="math inline">\(S\)</span>，将产生式<span class="math inline">\(S^{\prime}\rightarrow S\)</span>添加到<span class="math inline">\(G\)</span>中，就得到了文法<span class="math inline">\(G^{\prime}\)</span>。</p></blockquote><p>这样，当分析器进入状态<span class="math inline">\(S^{\prime}\rightarrow S\cdot\)</span>时，如果输入流已经读完，就表示进入了接受状态。</p><h3 id="textclosure函数"><span class="math inline">\(\text{CLOSURE}\)</span>函数</h3><p><span class="math inline">\(\text{CLOSURE}\)</span>函数将一个项目集合映射到另一个项目集合，它的输入是项目集合<span class="math inline">\(I\)</span>，输出是该项目集合的闭包<span class="math inline">\(\text{CLOSURE}(I)\)</span>。它的意义在于将一些在状态上等价的项聚集起来形成一个状态，而不是对于文法的每一个项作为一个状态，避免语法分析器的状态数过多。定义<span class="math inline">\(\text{CLOSURE}(I)\)</span>：</p><blockquote><ol type="1"><li>初始，<span class="math inline">\(\text{CLOSURE}(I) = \phi\)</span></li><li><span class="math inline">\(\text{CLOSURE}(I) = \text{CLOSURE}(I)\cup I\)</span></li><li>如果<span class="math inline">\(A\rightarrow \alpha \cdot B \beta \in \text{CLOSURE}(I)\)</span>，并且<span class="math inline">\(\exists B\rightarrow \cdot \gamma \notin \text{CLOSURE}(I)\)</span>，那么<span class="math inline">\(\text{CLOSURE}(I) = \text{CLOSURE}(I)\cup B\rightarrow \cdot \gamma\)</span></li></ol></blockquote><p>不断重复<span class="math inline">\((3)\)</span>直到没有新的项能添加到<span class="math inline">\(\text{CLOSURE}(I)\)</span>中。上面各式的含义是：</p><ul><li><p><span class="math inline">\((2)\)</span>的含义是所有<span class="math inline">\(I\)</span>中的项都在<span class="math inline">\(I\)</span>的闭包中</p></li><li><p><span class="math inline">\((3)\)</span>的含义是如果<span class="math inline">\(\text{CLOSURE}(I)\)</span>中某个项的点号的右侧是一个非终结符，那么以该非终结符为左部且点号在右部最左侧的项也在<span class="math inline">\(\text{CLOSURE}(I)\)</span>中。进一步也就是说如果此时分析器期待对非终结符<span class="math inline">\(B\)</span>的归约，那么它也同样期待着由<span class="math inline">\(B\)</span>产生的那些符号，因为只有那些符号才能归约成<span class="math inline">\(B\)</span>。</p></li></ul><h3 id="textgoto函数"><span class="math inline">\(\text{GOTO}\)</span>函数</h3><p><span class="math inline">\(\text{GOTO}\)</span>函数也将一个项目集合映射到另一个项目集合，它的输入是项目集合<span class="math inline">\(I\)</span>和一个文法符号<span class="math inline">\(X\)</span>，输出是该项目集合中所有项遇到文法符号<span class="math inline">\(X\)</span>后所有后继项的闭包。</p><blockquote><p>后继项：对于项<span class="math inline">\(A\rightarrow X\cdot YZ\)</span>而言，它的后继项就是将点号移动到项右部的下一个文法符号，即<span class="math inline">\(A\rightarrow XY\cdot Z\)</span>。</p></blockquote><p>它的意义是求出分析器状态机中的所有状态转移。定义<span class="math inline">\(\text{GOTO}\)</span>函数：</p><blockquote><p><span class="math inline">\(\text{GOTO}(I, X) = \text{CLOSURE}(\{A\rightarrow \alpha X\cdot \beta \ |\ \forall A\rightarrow \alpha \cdot X \beta \in I \})\)</span></p></blockquote><h3 id="规范textlr0项集族-canonical-lr0-collection">规范<span class="math inline">\(\text{LR}(0)\)</span>项集族 canonical LR(0) collection</h3><p>所谓项集族，指的是项目集合的集合，也就是说项集族中每一个元素都是一个项目的集合。利用<span class="math inline">\(\text{CLOSURE}\)</span>函数和<span class="math inline">\(\text{GOTO}\)</span>函数，可以构造出一个文法的规范<span class="math inline">\(\text{LR}(0)\)</span>项集族。定义规范<span class="math inline">\(\text{LR}(0)\)</span>项集族：</p><blockquote><p><span class="math inline">\(C = \{I_{0}\}\cup \{I\ |\ \exists J\in C, X\in V_{N}\cup V_{T}, I = \text{GOTO}(J, X)\}\)</span></p></blockquote><p>上面表达式的含义是：</p><ul><li><p><span class="math inline">\(C\)</span>中包含了项<span class="math inline">\(S^{\prime}\rightarrow \cdot S\)</span>的闭包。</p></li><li><p>对<span class="math inline">\(C\)</span>中的每一个项目集合<span class="math inline">\(I\)</span>和文法中每一个符号<span class="math inline">\(X\)</span>，如果<span class="math inline">\(\text{GOTO}(I, X)\)</span>不在<span class="math inline">\(C\)</span>中，则将其添加到<span class="math inline">\(C\)</span>中。</p></li></ul><h2 id="textlr0分析器"><span class="math inline">\(\text{LR}(0)\)</span>分析器</h2><h3 id="textlr0分析表的结构"><span class="math inline">\(\text{LR}(0)\)</span>分析表的结构</h3><p><span class="math inline">\(\text{LR}(0)\)</span>分析表是一个二维表格，它的行数等于文法<span class="math inline">\(G\)</span>的规范<span class="math inline">\(\text{LR}(0)\)</span>项集族中元素个数，列数等于<span class="math inline">\(G\)</span>中文法符号的个数。分析表中的每一个单元表示在某个状态下遇到某个文法符号时，下一步需要进行的操作。整个分析表被划分为<span class="math inline">\(\text{ACTION}\)</span>和<span class="math inline">\(\text{GOTO}\)</span>两个区域，落入对应区域的单元分别表示遇到终结符和非终结符时所进行的操作。</p><p>对于<span class="math inline">\(\text{ACTION}\)</span>：</p><ul><li><p>如果为<span class="math inline">\(s_{i}\)</span>，则表示移入（shift）操作，分析器将输入指针指向的符号移入符号栈，然后将状态<span class="math inline">\(S_{i}\)</span>移入状态栈。</p></li><li><p>如果为<span class="math inline">\(r_{i}\)</span>，则表示归约（reduce）操作，分析器将使用第<span class="math inline">\(i\)</span>个产生式对符号栈顶的句柄进行归约操作。</p></li></ul><p>对于<span class="math inline">\(\text{GOTO}\)</span>，单元格中所有的元素都是数字，<span class="math inline">\(j = \text{GOTO}[S_{i}, X]\)</span>表示状态<span class="math inline">\(S_{i}\)</span>遇到栈顶为非终结符<span class="math inline">\(X\)</span>时将状态<span class="math inline">\(S_{j}\)</span>入栈。</p><h3 id="textlr0分析器的结构"><span class="math inline">\(\text{LR}(0)\)</span>分析器的结构</h3><p><span class="math inline">\(\text{LR}(0)\)</span>分析器包含4个主要部分：</p><ul><li><p>输入缓冲</p></li><li><p>符号和状态栈</p></li><li><p><span class="math inline">\(\text{LR}(0)\)</span>分析表</p></li><li><p>驱动程序</p></li></ul><p>它的运行中的格局是：</p><ol type="1"><li>初始格局为：</li></ol><p><span class="math display">\[\begin{align}&amp;S_{0} \\&amp;\$ &amp;a_{1}a_{2}\cdots a_{n}\$\\\end{align}\]</span></p><p>其中<span class="math inline">\(S_{0}\)</span>表示初始状态，对应<span class="math inline">\(S^{\prime}\rightarrow \cdot S\)</span>的项目集闭包。</p><ol start="2" type="1"><li>假设运行时的一个格局是：</li></ol><p><span class="math display">\[\begin{align}&amp;S_{0}S_{1}S_{2}\cdots S_{m} \\&amp;\$ X_{1}X_{2}\cdots X_{m} &amp;a_{i}a_{i + 1}\cdots a_{n}\$\\\end{align}\]</span></p><ul><li><p>若<span class="math inline">\(\text{ACTION}[S_{m}, a_{i}] = s_{x}\)</span>，则进行移入操作，格局变为： <span class="math display">\[\begin{align}&amp;S_{0}S_{1}S_{2}\cdots S_{m}S_{x} \\&amp;\$ X_{1}X_{2}\cdots X_{m}a_{i} &amp;a_{i + 1}\cdots a_{n}\$\\  \end{align}\]</span></p></li><li><p>若<span class="math inline">\(\text{ACTION}[S_{m}, a_{i}] = r_{x}\)</span>，则进行归约操作，使用第<span class="math inline">\(x\)</span>个产生式<span class="math inline">\(A\rightarrow X_{m - (k - 1)}\cdots X_{m}\)</span>，格局变为： <span class="math display">\[\begin{align}&amp;S_{0}S_{1}S_{2}\cdots S_{m - k} \\&amp;\$ X_{1}X_{2}\cdots X_{m - k}A &amp;a_{i}a_{i + 1}\cdots a_{n}\$\\  \end{align}\]</span></p></li></ul><p>而后查找<span class="math inline">\(\text{GOTO}\)</span>表，若<span class="math inline">\(\text{GOTO}[S_{m - k}, A] = y\)</span>，则进行状态转移，格局变为：</p><p><span class="math display">\[\begin{align}&amp;S_{0}S_{1}S_{2}\cdots S_{m - k}S_{y} \\&amp;\$ X_{1}X_{2}\cdots X_{m - k}A &amp;a_{i}a_{i + 1}\cdots a_{n}\$\\  \end{align}\]</span></p><ul><li>若<span class="math inline">\(\text{ACTION}[S_{m}, a_{i}] = \text{acc}\)</span>，则分析成功。</li><li>若<span class="math inline">\(\text{ACTION}[S_{m}, a_{i}] = \text{err}\)</span>，则分析失败。</li></ul><h3 id="构造textlr0分析表">构造<span class="math inline">\(\text{LR}(0)\)</span>分析表</h3><p>构造<span class="math inline">\(\text{LR}(0)\)</span>分析表的方法是：</p><ol type="1"><li><p>首先求文法<span class="math inline">\(G\)</span>的<span class="math inline">\(\text{LR}(0)\)</span>项集族<span class="math inline">\(C\)</span></p></li><li><p>对于<span class="math inline">\(C\)</span>中的每一个项目集<span class="math inline">\(I\)</span>：</p><ol type="1"><li><p>如果<span class="math inline">\(\text{GOTO}(I, \alpha) = I^{\prime}\)</span>，则<span class="math inline">\(\text{ACTION}[I, \alpha] = S_{I^{\prime}}\)</span></p></li><li><p>如果<span class="math inline">\(\text{GOTO}(I, A) = I^{\prime}\)</span>，则<span class="math inline">\(\text{GOTO}[I, A] = I^{\prime}\)</span></p></li><li><p>如果<span class="math inline">\(I\)</span>中有归约项，则<span class="math inline">\(\forall \alpha, \text{ACTION}[I, \alpha] = r_{x}\)</span>，其中<span class="math inline">\(x\)</span>为归约项对应产生式的编号</p></li></ol></li></ol>]]></content>
    
    
    <summary type="html">语法分析的自底向上分析技术中，LR(k)是常用的文法分类方法，而LR(0)则是一切方法的基础。本文将介绍如何构建LR(0)分析器中核心的LR(0)分析表。</summary>
    
    
    
    <category term="note" scheme="http://miaohao-oops.github.io/categories/note/"/>
    
    
    <category term="编译原理" scheme="http://miaohao-oops.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>nju-pa摸鱼记4-指令的生命周期</title>
    <link href="http://miaohao-oops.github.io/2022/02/07/nju-pa%E6%91%B8%E9%B1%BC%E8%AE%B04-%E6%8C%87%E4%BB%A4%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://miaohao-oops.github.io/2022/02/07/nju-pa%E6%91%B8%E9%B1%BC%E8%AE%B04-%E6%8C%87%E4%BB%A4%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2022-02-07T05:48:32.000Z</published>
    <updated>2022-03-09T00:59:19.415Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一前言">一、前言</h2><p>在之前的3篇专栏中，主要探讨了NEMU中一些巧妙的宏定义，以及关于计算模型的思考。从本篇开始，将专注于“模拟器如何模拟真实计算机”这一话题。计算机最基础、最核心的功能是执行指令，因此执行指令也是NEMU模拟器最基本的功能。</p><h2 id="二计算机中指令的生命周期">二、计算机中指令的生命周期</h2><p>对于精简指令集系统，五级流水线是一种经典的CPU核结构，它将一条指令的处理过程分为5个阶段：</p><ul><li><p>取指：维护PC寄存器，发起访存请求从内存中取出指令；</p></li><li><p>译码：翻译取出的指令，确定指令的操作方法和操作对象；</p></li><li><p>执行：通过运算部件（如ALU，乘法器等）对操作对象进行算</p></li><li><p>访存：若为访存类指令，则在这个阶段进行访存；</p></li><li><p>写回：将指令的运算、访存等结果写回目的寄存器。</p></li></ul><p>这五个阶段轮流往复地运行，计算机便能自动地运行下去。</p><h2 id="三nemu中指令的生命周期">三、NEMU中指令的生命周期</h2><p>在真实的CPU中，为了提升效率，在取指完成后PC跳转到紧接着当前指令的下一条指令继续取指，如果遇到跳转指令，可以冲刷流水线或者使用分支预测等技术增大取指的正确率。而在模拟器中则没有对于性能的要求，完全可以等到指令执行结束再更新PC，然后开始取下一条指令，在NEMU中，指令执行阶段的划分为：</p><ul><li><p>取指：通过PC值访问“内存”，取出指令；</p></li><li><p>译码：分析指令，确定操作方法和操作数；</p></li><li><p>执行：通过对应的处理函数对操作数进行处理，同时将结果写回“寄存器”；</p></li><li><p>更新PC：根据指令的执行情况更新PC，此PC一定是正确的PC。</p></li></ul><p>下面是一条语句在NEMU中的执行过程：</p><ol type="1"><li><p>NEMU调用定义在<code>src/cpu/cpu-exec.c</code>中的<code>cpu_exec()</code>函数，该函数将反复进行取指、译码、执行、更新PC这个过程，直到遇到停机、断点或是什么别的情况。</p></li><li><p><code>cpu_exec()</code>函数的核心是一个死循环，其中包括了<code>fetch_decode_exec_updatepc()</code>函数，该函数的定义如下：</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// src/cpu/cpu-exec.c</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fetch_decode_exec_updatepc</span><span class="hljs-params">(Decode *s)</span> </span>&#123;<br>  fetch_decode(s, cpu.pc);  <span class="hljs-comment">// fetch and decode</span><br>  s-&gt;EHelper(s);            <span class="hljs-comment">// exec</span><br>  cpu.pc = s-&gt;dnpc;         <span class="hljs-comment">// update pc</span><br>&#125;<br></code></pre></td></tr></table></figure><p>它将取指译码、执行和更新PC解构，分别对应函数中的三条语句。</p><ol start="3" type="1"><li>首先调用<code>fetch_decode()</code>函数，该函数的核心功能可以简化如下：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// src/cpu/cpu-exec.c</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fetch_decode</span><span class="hljs-params">(Decode *s, <span class="hljs-keyword">vaddr_t</span> pc)</span> </span>&#123;<br>  s-&gt;pc = pc;<br>  s-&gt;snpc = pc;<br>  <span class="hljs-keyword">int</span> idx = isa_fetch_decode(s);<br>  s-&gt;dnpc = s-&gt;snpc;<br>  s-&gt;EHelper = g_exec_table[idx];<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>fetch_decode()</code>函数中，通过<code>isa_fetch_decode()</code>函数得到指令所对应的序号，该序号和这条指令对应处理函数在列表中的下标相同，然后为函数指针<code>s-&gt;EHelper</code>赋值为对应的处理函数。</p><ol start="4" type="1"><li>进入<code>isa_fetch_decode()</code>函数，取指和译码进一步被解构，<code>instr_fetch()</code>函数负责与内存交互取指令；<code>table_main()</code>函数是译码函数，将取回的函数和模式串一一比对，若匹配成功则返回该指令对应的序号，若失败则返回一个无效指令序号，这将导致NEMU产生运行异常报给用户。同时在译码时，也将获取该指令的所有操作数，包括立即数和寄存器，它们都将被存在<code>Decode</code>结构中。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// src/isa/risCV64/instr/decode.c</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isa_fetch_decode</span><span class="hljs-params">(Decode *s)</span> </span>&#123;<br>  s-&gt;isa.instr.val = instr_fetch(&amp;s-&gt;snpc, <span class="hljs-number">4</span>);<br>  <span class="hljs-keyword">int</span> idx = table_main(s);<br>  <span class="hljs-keyword">return</span> idx;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="5" type="1"><li>现在返回到<code>fetch_decode_exec_updatepc()</code>函数中，它的第二条语句调用了<code>s-&gt;EHelper()</code>函数执行该指令，这些执行函数被定义在<code>src/isa/$ISA/instr</code>下的若干<code>.h</code>文件中，比如说lui指令的处理函数：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// src/isa/$ISA/instr/compute.h</span><br>def_EHelper(lui) &#123;<br>  rtl_li(s, ddest, id_src1-&gt;imm);<br>&#125;<br></code></pre></td></tr></table></figure><p>它是由更加细化的rtl级函数<code>rtl_li</code>所完成的，所有指令的终点都是若干rtl函数，也就是将指令拆解成“微指令”。</p><ol start="6" type="1"><li>执行完<code>s-&gt;EHelper()</code>后，语句</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">cpu.pc = s-&gt;dnpc;         <span class="hljs-comment">// update pc</span><br></code></pre></td></tr></table></figure><p>将完成更新PC的过程。</p>]]></content>
    
    
    <summary type="html">从计算机组成的角度窥探NEMU是如何运作的。</summary>
    
    
    
    <category term="NEMU" scheme="http://miaohao-oops.github.io/categories/NEMU/"/>
    
    
    <category term="C语言" scheme="http://miaohao-oops.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="计算机组成原理" scheme="http://miaohao-oops.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>nju-pa摸鱼记3-NEMU中宏的源码阅读</title>
    <link href="http://miaohao-oops.github.io/2022/02/05/nju-pa%E6%91%B8%E9%B1%BC%E8%AE%B03-nemu%E4%B8%AD%E5%AE%8F%E7%9A%84%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <id>http://miaohao-oops.github.io/2022/02/05/nju-pa%E6%91%B8%E9%B1%BC%E8%AE%B03-nemu%E4%B8%AD%E5%AE%8F%E7%9A%84%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</id>
    <published>2022-02-05T09:35:27.000Z</published>
    <updated>2022-03-09T00:59:19.410Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一前言">一、前言</h2><p>有关于如何使用宏定义检测某个宏是否存在在前两篇专栏中已经讨论得差不多了，本篇将目光转回NEMU的代码框架，探讨<code>include/macro.h</code>中的有关宏的原理。</p><h2 id="二macro.h">二、macro.h</h2><p>NEMU代码框架中的<code>include/macro.h</code>文件中定义了一些列宏</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// keep the code if a boolean macro is defined</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IFDEF(macro, ...) MUXDEF(macro, __KEEP, __IGNORE)(__VA_ARGS__)</span><br><span class="hljs-comment">// keep the code if a boolean macro is undefined</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IFNDEF(macro, ...) MUXNDEF(macro, __KEEP, __IGNORE)(__VA_ARGS__)</span><br><span class="hljs-comment">// keep the code if a boolean macro is defined to 1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IFONE(macro, ...) MUXONE(macro, __KEEP, __IGNORE)(__VA_ARGS__)</span><br><span class="hljs-comment">// keep the code if a boolean macro is defined to 0</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IFZERO(macro, ...) MUXZERO(macro, __KEEP, __IGNORE)(__VA_ARGS__)</span><br></code></pre></td></tr></table></figure><p>从注释中可以看出，这些宏都是根据布尔宏（即若被定义则只有可能被定义为<code>0</code>或<code>1</code>）是否被定义或者定义为什么值而决定后面变长参数表中的代码在预编译时是否被保留。由于它们的原理是相通的，所以这里只分析宏<code>IFDEF(macro, ...)</code>，并使用自顶向下的方法，从顶层宏定义一直追踪到最深层的定义。</p><p>宏<code>IFDEF(macro, ...)</code>的第一个参数是一个布尔宏，第二个参数是变长列表，可以传入语句或代码块。若宏<code>macro</code>被定义则保留代码，反之什么都不保留。在它的顶层定义中使用了宏<code>MUXDEF(macro, a, b)</code>，它是一个广义的选择器，不管<code>a</code>和<code>b</code>的类型是什么。在这里，<code>__KEEP</code>和<code>__IGNORE</code>是两个宏函数，它们的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __IGNORE(...)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __KEEP(...) __VA_ARGS__</span><br></code></pre></td></tr></table></figure><p>它们的功能和它们的名字相同，<code>__KEEP</code>将保留所有的输入，而<code>__IGNORE</code>将所有输入舍弃。所以，在这里宏<code>IFDEF</code>使用宏<code>MUXDEF</code>选择<code>__KEEP</code>宏函数或<code>__IGNORE</code>宏函数中的一个，然后再将选出来的宏函数作用到后面的代码上，决定这段代码的去留。</p><p>举个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;macro.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOO 1</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>IFDEF(FOO, <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, World!\n&quot;</span>);)<br>   <span class="hljs-comment">// =&gt; __KEEP(printf(&quot;Hello, World!\n&quot;);)</span><br>   <span class="hljs-comment">// =&gt; printf(&quot;Hello, World!\n&quot;);</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的例子中，因为宏<code>FOO</code>已经被定义了，所以再<code>MUXDEF</code>的作用下，宏函数<code>__KEEP</code>被选择出来作用在<code>printf</code>语句上，最后这个语句被保留了下来。</p><p>接下来看宏<code>MUXDEF</code>是怎么实现的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CHOOSE2nd(a, b, ...) b</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MUX_WITH_COMMA(contain_comma, a, b) CHOOSE2nd(contain_comma a, b)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MUX_MACRO_PROPERTY(p, macro, a, b) MUX_WITH_COMMA(concat(p, macro), a, b)</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __P_DEF_0  X,</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __P_DEF_1  X,</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MUXDEF(macro, X, Y) MUX_MACRO_PROPERTY(__P_DEF_, macro, X, Y)</span><br></code></pre></td></tr></table></figure><p>宏<code>MUXDEF</code>又调用了宏<code>MUX_MACRO_PROPERTY</code>，它的作用是使用宏<code>concat</code>为宏<code>macro</code>添加一个前缀<code>__P_DEF_</code>，然后将处理过的宏传给宏<code>MUX_WITH_COMMA</code>。上一篇所介绍的技术在这里体现了出来：如果布尔宏被定义了，那么加上前缀后将得到<code>__P_DEF_0</code>或<code>__P_DEF_1</code>，然后再定义这两个宏，通过逗号控制最后传入<code>CHOOSE2nd</code>宏的第二个参数为<code>a</code>，最终选择结果为<code>a</code>；如果宏没有被定义，那么加上前缀后的宏不会再进行解释，那么“<code>contain_comma a</code>”部分将作为传入<code>CHOOSE2nd</code>的第一个参数，最终选择结果为<code>b</code>。</p>]]></content>
    
    
    <summary type="html">在前两篇的基础上，解读NEMU中macro.h中相关宏的实现原理。</summary>
    
    
    
    <category term="NEMU" scheme="http://miaohao-oops.github.io/categories/NEMU/"/>
    
    
    <category term="C语言" scheme="http://miaohao-oops.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>My First Article</title>
    <link href="http://miaohao-oops.github.io/2022/02/02/My-First-Article/"/>
    <id>http://miaohao-oops.github.io/2022/02/02/My-First-Article/</id>
    <published>2022-02-02T06:03:12.000Z</published>
    <updated>2022-03-09T00:59:19.419Z</updated>
    
    <content type="html"><![CDATA[<h2 id="chapter-1">Chapter 1</h2><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, World!\n&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="chapter-2">Chapter 2</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;Hello, World!\n&quot;</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="chapter-3">Chapter 3</h2><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/usr/bin/bash</span><br>echo &quot;Hello, World!&quot;<br></code></pre></td></tr></table></figure><h2 id="chapter-4">Chapter 4</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-meta">#!/usr/bin/ruby</span><br>puts <span class="hljs-string">&quot;Hello, World!&quot;</span><br></code></pre></td></tr></table></figure><h2 id="chapter-5">Chapter 5</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello, World!&quot;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Hello, World!</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>try latex</title>
    <link href="http://miaohao-oops.github.io/2022/02/01/try-latex/"/>
    <id>http://miaohao-oops.github.io/2022/02/01/try-latex/</id>
    <published>2022-02-01T14:21:13.000Z</published>
    <updated>2022-03-09T00:59:19.417Z</updated>
    
    <content type="html"><![CDATA[<p><span class="math inline">\(a=\lambda x.x\)</span></p><p>Hello!</p><p><span class="math display">\[A = \begin{bmatrix}        a_{11}    &amp; a_{12}    &amp; ...    &amp; a_{1n}\\        a_{21}    &amp; a_{22}    &amp; ...    &amp; a_{2n}\\        a_{31}    &amp; a_{22}    &amp; ...    &amp; a_{3n}\\        \vdots    &amp; \vdots    &amp; \ddots &amp; \vdots\\        a_{n1}    &amp; a_{n2}    &amp; ... &amp; a_{nn}\\    \end{bmatrix} , b = \begin{bmatrix}        b_{1}  \\        b_{2}  \\        b_{3}  \\        \vdots \\        b_{n}  \\    \end{bmatrix}\]</span></p><p><img src="/img/a.png" /></p>]]></content>
    
    
    <summary type="html">Hello!</summary>
    
    
    
    <category term="blog" scheme="http://miaohao-oops.github.io/categories/blog/"/>
    
    
    <category term="LaTeX" scheme="http://miaohao-oops.github.io/tags/LaTeX/"/>
    
  </entry>
  
  <entry>
    <title>nju-pa摸鱼记2-计算机与λ演算</title>
    <link href="http://miaohao-oops.github.io/2022/02/01/nju-pa%E6%91%B8%E9%B1%BC%E8%AE%B02-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8E%CE%BB%E6%BC%94%E7%AE%97/"/>
    <id>http://miaohao-oops.github.io/2022/02/01/nju-pa%E6%91%B8%E9%B1%BC%E8%AE%B02-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8E%CE%BB%E6%BC%94%E7%AE%97/</id>
    <published>2022-02-01T08:40:20.000Z</published>
    <updated>2022-03-09T00:59:19.412Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一前言">一、前言</h2><p>在<a href="https://miaohao-oops.github.io/2022/01/31/nju-pa%E6%91%B8%E9%B1%BC%E8%AE%B01-%E5%AE%8F%E7%9A%84%E5%A6%99%E7%94%A8/">上一篇</a>中，讨论了如何使用预处理指令或是宏来识别某个宏是否被定义，以实现通过配置进行有选择的编译。不过，仅使用上一篇讨论的<code>isdef</code>宏还不能达到和预处理指令一样的效果，本篇将继续讨论框架中如何使用宏来实现“<strong>如果某个宏被定义，则预处理后保留某些语句或代码块，反之抛弃这些部分</strong>”的功能。之所以提到<span class="math inline">\(\lambda\)</span>演算，是由于我在搞明白代码框架中的宏是如何运作之后，发现其颇有“函数式编程”的风格，而<span class="math inline">\(\lambda\)</span>演算是函数式编程的基础，遂记录于此。</p><h2 id="二浅谈lambda演算">二、浅谈<span class="math inline">\(\lambda\)</span>演算</h2><h3 id="简介">1、简介</h3><p><span class="math inline">\(\lambda\)</span>演算是一种和图灵机等价的计算模型（<strong>丘奇-图灵论题</strong>），它可以描述任何可计算问题，又称为“最小的编程语言”。简单来说，<span class="math inline">\(\lambda\)</span>演算的核心是<strong>抽象化定义的函数</strong>，它的参数没有类型的限制，可以是数字，函数或者字符串等等。一个最基础的函数是恒等函数：</p><p><span class="math display">\[\lambda x.x\]</span></p><p>其中<span class="math inline">\(\lambda\)</span>后的<span class="math inline">\(x\)</span>是这个函数的<strong>输入</strong>，点号后的<span class="math inline">\(x\)</span>是函数的<strong>输出</strong>。可以将这个函数作用在变量<span class="math inline">\(a\)</span>上，就得到：</p><p><span class="math display">\[\lambda x.x(a) = a\]</span></p><p>通过<strong>柯里化</strong>方法，可以定义二输入函数：</p><p><span class="math display">\[\lambda x.\lambda y.x+y\]</span></p><p>其中<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>是该函数的两个输入，该函数的输出是两个输入的和。</p><h3 id="用抽象化函数表示布尔逻辑">2、用抽象化函数表示布尔逻辑</h3><p>在<span class="math inline">\(\lambda\)</span>演算中，没有布尔值的概念，但是可以定义两个函数来表示布尔逻辑：</p><p><span class="math display">\[\text{TRUE} = \lambda x.\lambda y.x\]</span></p><p><span class="math display">\[\text{FALSE} = \lambda x.\lambda y.y\]</span></p><p>用自然语言来描述<span class="math inline">\(\text{TRUE}\)</span>函数的作用：“输入两个参数<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>，输出第一个参数”，<span class="math inline">\(\text{FALSE}\)</span>函数的功能同理。这样的话，可以把布尔值<span class="math inline">\(1\)</span>和<span class="math inline">\(0\)</span>分别定义成<span class="math inline">\(\text{TRUE}\)</span>函数和<span class="math inline">\(\text{FALSE}\)</span>函数。接下来可以定义最基本的非、与、或运算：</p><p><span class="math display">\[\begin{cases}\text{NOT} &amp;= \lambda x.x\ \text{FALSE}\ \text{TRUE} \\\text{AND} &amp;= \lambda x.\lambda y.x\ y\ \text{FALSE} \\\text{OR} &amp;= \lambda x.\lambda y. x\ \text{TRUE}\ y \\\end{cases}\]</span></p><p>上面的三个函数都是利用了<span class="math inline">\(\lambda\)</span>演算中参数可以是函数的性质，输入的<span class="math inline">\(\text{TRUE}\)</span>或<span class="math inline">\(\text{FALSE}\)</span>都可以作为函数继续运算，下面以<span class="math inline">\(\text{AND}\)</span>函数为例进行验证：</p><p><span class="math display">\[\begin{align*}\text{AND}(\text{FALSE})(\text{FALSE}) &amp;= \text{FALSE}(\text{FALSE})(\text{FALSE}) \\&amp;= \text{FALSE}\end{align*}\]</span></p><p><span class="math display">\[\begin{align*}\text{AND}(\text{FALSE})(\text{TRUE}) &amp;= \text{FALSE}(\text{TRUE})(\text{FALSE}) \\&amp;= \text{FALSE}\end{align*}\]</span></p><p><span class="math display">\[\begin{align*}\text{AND}(\text{TRUE})(\text{FALSE}) &amp;= \text{TRUE}(\text{FALSE})(\text{FALSE}) \\&amp;= \text{FALSE}\end{align*}\]</span></p><p><span class="math display">\[\begin{align*}\text{AND}(\text{TRUE})(\text{TRUE}) &amp;= \text{TRUE}(\text{TRUE})(\text{FALSE}) \\&amp;= \text{TRUE}\end{align*}\]</span></p><p>当且仅当<span class="math inline">\(x\)</span>与<span class="math inline">\(y\)</span>均为<span class="math inline">\(\text{TRUE}\)</span>时，<span class="math inline">\(\text{AND}\)</span>的值为<span class="math inline">\(\text{TRUE}\)</span>。因此，函数<span class="math inline">\(\text{AND}\)</span>的定义正确。</p><h3 id="lambda演算与计算机的联系">3、<span class="math inline">\(\lambda\)</span>演算与计算机的联系</h3><p><span class="math inline">\(\text{TRUE}\)</span>和<span class="math inline">\(\text{FALSE}\)</span>这两个函数的功能用一个词来概括就是“<strong>选择</strong>”，在数字电路中，也有一个可以做选择的模块：<strong>选择器</strong>。选择器有三个输入端口<span class="math inline">\(a\)</span>，<span class="math inline">\(b\)</span>和<span class="math inline">\(sel\)</span>，一个输出端口<span class="math inline">\(y\)</span>，根据<span class="math inline">\(sel\)</span>的值可以决定<span class="math inline">\(y\)</span>的值是和<span class="math inline">\(a\)</span>相同还是和<span class="math inline">\(b\)</span>相同（比如当<span class="math inline">\(sel = \text{TRUE}\)</span>时，<span class="math inline">\(y=a\)</span>；<span class="math inline">\(sel = \text{FALSE}\)</span>时，<span class="math inline">\(y = b\)</span>），类似的，可以构建函数：</p><p><span class="math display">\[\text{MUX} = \lambda a.\lambda b.\lambda sel.sel\ a\ b\]</span></p><p>这个函数看起来有些奇怪，似乎只是把三个参数排列在一起输出了，并不能看出其中的“选择功能”，但是<span class="math inline">\(\lambda\)</span>表达式的特别之处就在于输入的参数可以是函数，从而可以进一步作用在后面的参数上。下面来验证一下的功能：</p><p><span class="math display">\[\begin{align*}\text{MUX}(a)(b)(\text{TRUE}) &amp;= \text{TRUE}(a)(b) = a \\\text{MUX}(a)(b)(\text{FALSE}) &amp;= \text{FALSE}(a)(b) = b \\\end{align*}\]</span></p><p><span class="math inline">\(\text{MUX}\)</span>函数的工作行为与选择器完全一致！放在硬件中，<span class="math inline">\(\text{MUX}\)</span>函数是选择器，而在软件中，它就是<code>if</code>语句：</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (sel) &#123;<br>  a<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  b<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三更进一步">三、更进一步</h2><p>有了<span class="math inline">\(\text{MUX}\)</span>函数，就可以实现宏定义的“条件编译”了，只需要改变一下它0的输入参数即可：</p><p><span class="math display">\[\text{MUX}(code\_block, , \text{isdef}(macro))\]</span></p><p>其中<code>isdef</code>是在上一篇定义的宏函数，如果<span class="math inline">\(macro\)</span>已经被定义了，它将返回<span class="math inline">\(\text{TRUE}\)</span>，反之返回<span class="math inline">\(\text{FALSE}\)</span>。<span class="math inline">\(code_block\)</span>是在宏<span class="math inline">\(macro\)</span>被定义后希望在预处理时被保留下来的代码块。传给<span class="math inline">\(\text{MUX}\)</span>函数的第二个参数是一个空串，也就是说在<span class="math inline">\(macro\)</span>未被定义时，预处理后会留下一个空串，对于最后的预处理结果没有任何影响。</p><p>通过上面的抽象定义，已经实现了预期的功能，但是到C语言中，还面临着一些细节问题。首先，<code>isdef</code>的值是<code>1</code>或<code>0</code>，而不是上面定义的和函数。这就导致C语言预处理器并不会把<code>isdef</code>替换为<code>1</code>或<code>0</code>后再当作一个“函数”来解释。其次，<code>isdef</code>中使用了<code>strcmp</code>函数，这显然不能在函数外面使用，函数的运行结果在运行时才被计算出来。</p><p>对于第一个问题，如何将<code>isdef</code>的值解释为一个函数呢？由于<code>1</code>和<code>0</code>在C语言中被解释为整型字面量，所以可以给这个<code>1</code>或者<code>0</code>“加点东西”，然后定义新的宏，这里用到了<code>##</code>运算符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> concat(a, b) a ## b</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MUX_MID(a, b, p, sel) MUX(a, b, concat(p, sel))</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MUX_OUT(a, b, sel) MUX_MID(a, b, PREFIX_, sel)</span><br></code></pre></td></tr></table></figure><p>宏<code>concat</code>将两个参数粘连起来，<code>MUX</code>仍然是上面抽象的函数。假设<code>MUX_OUT</code>的输入参数是<code>(code_block, , isdef(foo)</code>，并且宏<code>foo</code>已经被定义过，先不考虑其他问题，经过宏<code>MUX_MID</code>和<code>concat</code>，最终传入<code>MUX</code>的参数将会变为<code>(code_block, , PREFIX_1)</code>。如果我们继续定义宏函数<code>PREFIX_1</code>和<code>PREFIX_0</code>，就可以解决第一个问题了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TRUE(a, b) a</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FALSE(a, b) b</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PREFIX_1(a, b) TRUE(a, b)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PREFIX_0(a, b) FALSE(a, b)\</span><br></code></pre></td></tr></table></figure><p>这里定义的<code>TRUE</code>和<code>FALSE</code>宏函数其实就是上面<span class="math inline">\(\lambda\)</span>演算中的<span class="math inline">\(\text{TRUE}\)</span>和<span class="math inline">\(\text{FALSE}\)</span>！现在，考虑宏<code>MUX</code>怎么定义，我们想要将最后的<code>PREFIX_1</code>或者<code>PREFIX_0</code>作用在<code>a</code>和<code>b</code>上，那么只需要改一下参数的顺序，再加个括号就行了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MUX(a, b, sel) sel(a, b)</span><br></code></pre></td></tr></table></figure><p>下面来看第二个问题，宏<code>isdef</code>在预处理阶段不会被替换为<code>1</code>或<code>0</code>，因此，不能通过<code>MUX_OUT(a, b, isdef(macro))</code>来使用这个宏，这样肯定是有问题的。需要一个宏，能在预处理阶段就产生<code>1</code>或<code>0</code>的结果。由于我们是在配置编译时使用，所以对于某个选项，要么它被定义了，要么它没被定义，而被定义的宏我们并不在乎它是什么值，所以可以限制为：“一旦定义，就将它定义为<code>t</code>”（这个限制只在本篇中成立）。</p><p>再整理一下，现在需要一个宏，来检测一个“一旦定义，就被一定被定义成<code>t</code>”的宏是否被定义，如果被定义了，预处理时它会被替换成<code>1</code>，否则被替换成<code>0</code>。在这个假设下，被定义了的宏会被替换为<code>t</code>，而没有被定义的宏在预处理阶段会保留为宏名。可以使用刚才的“加点东西”技术，把替换后的<code>t</code>再进一步替换为别的东西：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> choose2nd(a, b, ...) b</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PREFIX_t t,</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> choose2nd_mid(p_macro, a, b) choose2nd(p_macro a, b)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> choose2nd_out(macro, a, b) choose2nd_mid(concat(PREFIX_, macro), a, b)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IFDEF(macro) choose2nd_out(macro, 1, 0)</span><br></code></pre></td></tr></table></figure><p>这一系列宏的关键之处在于<code>choose2nd_mid</code>宏定义中<code>p_macro</code>和<code>a</code>之间没有逗号，如果<code>macro</code>被定义成了<code>t</code>，则会被替换为“<code>t,</code>”（<code>t</code>后面有一个逗号分隔），从而成为了第二个参数；当未被定义或者被定义成别的，是第二个参数。</p><p>上面的讨论中已经涉及了大部分NEMU框架中所使用的技巧和方法，实现这些宏的思路与<span class="math inline">\(\lambda\)</span>演算关系密切，这种思路也许就是“函数式编程”。</p><h2 id="四参考资料">四、参考资料</h2><ul><li><p><a href="https://github.com/NJU-ProjectN/ics-pa">南京大学ics-pa在github上的项目</a></p></li><li><p><a href="https://www.bilibili.com/video/BV1VA411H7Ym?share_source=copy_web"><span class="math inline">\(\lambda\)</span>演算简介</a></p></li></ul>]]></content>
    
    
    <summary type="html">从计算机原理出发，以函数式编程的思想定义出检测宏是否存在的宏。</summary>
    
    
    
    <category term="NEMU" scheme="http://miaohao-oops.github.io/categories/NEMU/"/>
    
    
    <category term="C语言" scheme="http://miaohao-oops.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="理论计算机科学" scheme="http://miaohao-oops.github.io/tags/%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>nju-pa摸鱼记1-宏的妙用</title>
    <link href="http://miaohao-oops.github.io/2022/01/31/nju-pa%E6%91%B8%E9%B1%BC%E8%AE%B01-%E5%AE%8F%E7%9A%84%E5%A6%99%E7%94%A8/"/>
    <id>http://miaohao-oops.github.io/2022/01/31/nju-pa%E6%91%B8%E9%B1%BC%E8%AE%B01-%E5%AE%8F%E7%9A%84%E5%A6%99%E7%94%A8/</id>
    <published>2022-01-31T07:39:49.000Z</published>
    <updated>2022-03-09T00:59:19.421Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一前言">一、前言</h2><p>上学期在课内学习了《计算机体系结构》，一直对最后一章老师讲到的硬件模拟器念念不忘，好奇它的工作原理。好巧不巧，某日在我刷github的时候南京大学的<a href="https://github.com/NJU-ProjectN/ics-pa">ics-pa项目</a>出现在了我的首页推荐中，于是我便打算利用寒假的时间过一下这个项目，并通过<a href="https://www.bilibili.com/read/cv15072569">B站的专栏</a>（现在同步到我的个人博客上）记录一些新的知识或者是心得体会。</p><h2 id="二使用宏配置编译选项">二、使用宏配置编译选项</h2><p>在项目代码进行编译前，需要先使用</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">make menuconfig<br></code></pre></td></tr></table></figure><p>对项目进行配置，在勾选了一些选项退出后，<code>menuconfig</code>会根据之前的选项生成一些宏保存到若干文件中，供之后的.c文件或Makefile文件所包含（使用include）。这样，在C语言源文件或makefile脚本中通过对这些宏加以判断，就可以在编译时使用或抛弃某些特定的功能。</p><h2 id="三c语言中检测宏是否被定义">三、C语言中检测宏是否被定义</h2><h3 id="使用条件编译指令">1、使用条件编译指令</h3><p>在C语言源文件中，可以使用条件编译指令</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> FOO</span><br>  ...<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>将宏<code>FOO</code>对应功能的代码包围起来，如果在<code>menuconfig</code>中勾选了该宏所对应的选项，则宏<code>FOO</code>会被定义，最终这段代码也会被编译。</p><h3 id="使用宏定义">2、使用宏定义</h3><p>除了使用条件编译指令，代码框架还提供了另一种方式检测某个宏是否被定义。之所以要使用另一种方式，是因为条件编译指令不能使用在宏定义中，而频繁地使用条件编译指令会使代码的可读性大打折扣。实现这个功能的关键代码包括：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// macro.h</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> _MACRO_H_</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _MACRO_H_</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> str_temp(x) #x</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> str(x) str_temp(x)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> isdef(macro) (strcmp(<span class="hljs-meta-string">&quot;&quot;</span> #macro, <span class="hljs-meta-string">&quot;&quot;</span> str(macro)) != 0)</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>其中宏<code>str(x)</code>使用<code>#</code>运算符将<code>x</code>转化为一个字符串。下面举一个例子来说明<code>isdef</code>这个宏是怎么工作的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// main.c</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;macro.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOO 123</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> a = isdef(FOO);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>经过预处理</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -o main.i -E main.c<br></code></pre></td></tr></table></figure><p>main.i中的内容为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// main.i</span><br>...<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> a = (<span class="hljs-built_in">strcmp</span>(<span class="hljs-string">&quot;&quot;</span> <span class="hljs-string">&quot;FOO&quot;</span>, <span class="hljs-string">&quot;&quot;</span> <span class="hljs-string">&quot;123&quot;</span>) != <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>...<br></code></pre></td></tr></table></figure><p>可以发现，<code>strcmp</code>函数的第一个参数对应<code>isdef</code>宏定义中的<code>"" #macro</code>，它直接将宏参数的名称转换为了字符串，而第二个参数对应<code>"" str(macro)</code>，它先将<code>FOO</code>替换为<code>123</code>，然后将<code>123</code>转换为字符串。因此当这两个参数不同时，说明宏已经被定义过。</p><p>    通过上面的分析可以发现，宏<code>isdef</code>不能检测宏定义的值与宏定义名称相同的宏，比如说</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOO FOO</span><br></code></pre></td></tr></table></figure><p>宏<code>FOO</code>在预处理时仍然被替换为<code>FOO</code>，最后将导致错误的结果。</p><p>四、参考资料</p><ul><li><p><a href="https://stackoverflow.com/questions/26099745/test-if-preprocessor-symbol-is-defined-inside-macro">stackoverflow上关于如何判断宏是否被定义的讨论</a></p></li><li><p><a href="https://github.com/NJU-ProjectN/ics-pa">南京大学ics-pa项目</a></p></li></ul>]]></content>
    
    
    <summary type="html">通过menuconfig工具，可以根据配置选项生成含有一些宏的文件，然后在代码中检测这些宏的存在以实现“配置编译选项”的功能。</summary>
    
    
    
    <category term="NEMU" scheme="http://miaohao-oops.github.io/categories/NEMU/"/>
    
    
    <category term="C语言" scheme="http://miaohao-oops.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://miaohao-oops.github.io/1970/01/01/hello-world/"/>
    <id>http://miaohao-oops.github.io/1970/01/01/hello-world/</id>
    <published>1970-01-01T00:00:00.000Z</published>
    <updated>2022-03-09T00:59:19.414Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
