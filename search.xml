<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>LR(0)分析方法</title>
    <url>/2022/03/29/LR-0-%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="基本概念">基本概念</h2>
<h3 id="项目-item">项目 item</h3>
<blockquote>
<p>项目是对文法中产生式的扩展，通过在产生式右部添加<span
class="math inline">\(\cdot\)</span>的方法来表示语法分析器在分析过程中的某个状态。</p>
</blockquote>
<p>例子：</p>
<p>对于产生式<span class="math inline">\(A\rightarrow \alpha
X\)</span>，它产生以下几个项：</p>
<p><span class="math display">\[
\begin{align}
A&amp;\rightarrow \cdot \alpha X &amp;(1)\\
A&amp;\rightarrow \alpha \cdot X &amp;(2)\\
A&amp;\rightarrow \alpha X \cdot &amp;(3)\\
\end{align}
\]</span></p>
<p>其中，</p>
<ul>
<li><p>式<span
class="math inline">\((1)\)</span>的点号右侧是一个终结符，意味着在当前状态下，分析器期待从输入流中读入符号<span
class="math inline">\(\alpha\)</span>，因此它被定义为一个<strong>移入项</strong>。</p></li>
<li><p>式<span
class="math inline">\((2)\)</span>中点号右侧是一个非终结符，此时分析器期待后面的输入归约得到非终结符<span
class="math inline">\(X\)</span>，因此它被定义为一个<strong>待约项</strong>。</p></li>
<li><p>式<span
class="math inline">\((3)\)</span>的点号位于整个产生式的结尾，此时意味着分析器将进行归约操作，将<span
class="math inline">\(\alpha X\)</span>归约为<span
class="math inline">\(A\)</span>，因此它被定义为一个<strong>归约项</strong>。</p></li>
</ul>
<h3 id="增广文法-augmented-grammar">增广文法 augmented grammar</h3>
<p>为了得到唯一的终止产生式，定义一个文法<span
class="math inline">\(G\)</span>的增广文法<span
class="math inline">\(G^{\prime}\)</span>：</p>
<blockquote>
<p>对于文法<span class="math inline">\(G\)</span>的开始符号<span
class="math inline">\(S\)</span>，将产生式<span
class="math inline">\(S^{\prime}\rightarrow S\)</span>添加到<span
class="math inline">\(G\)</span>中，就得到了文法<span
class="math inline">\(G^{\prime}\)</span>。</p>
</blockquote>
<p>这样，当分析器进入状态<span
class="math inline">\(S^{\prime}\rightarrow
S\cdot\)</span>时，如果输入流已经读完，就表示进入了接受状态。</p>
<h3 id="textclosure函数"><span
class="math inline">\(\text{CLOSURE}\)</span>函数</h3>
<p><span
class="math inline">\(\text{CLOSURE}\)</span>函数将一个项目集合映射到另一个项目集合，它的输入是项目集合<span
class="math inline">\(I\)</span>，输出是该项目集合的闭包<span
class="math inline">\(\text{CLOSURE}(I)\)</span>。它的意义在于将一些在状态上等价的项聚集起来形成一个状态，而不是对于文法的每一个项作为一个状态，避免语法分析器的状态数过多。定义<span
class="math inline">\(\text{CLOSURE}(I)\)</span>：</p>
<blockquote>
<ol type="1">
<li>初始，<span class="math inline">\(\text{CLOSURE}(I) =
\phi\)</span></li>
<li><span class="math inline">\(\text{CLOSURE}(I) =
\text{CLOSURE}(I)\cup I\)</span></li>
<li>如果<span class="math inline">\(A\rightarrow \alpha \cdot B \beta
\in \text{CLOSURE}(I)\)</span>，并且<span class="math inline">\(\exists
B\rightarrow \cdot \gamma \notin \text{CLOSURE}(I)\)</span>，那么<span
class="math inline">\(\text{CLOSURE}(I) = \text{CLOSURE}(I)\cup
B\rightarrow \cdot \gamma\)</span></li>
</ol>
</blockquote>
<p>不断重复<span
class="math inline">\((3)\)</span>直到没有新的项能添加到<span
class="math inline">\(\text{CLOSURE}(I)\)</span>中。上面各式的含义是：</p>
<ul>
<li><p><span class="math inline">\((2)\)</span>的含义是所有<span
class="math inline">\(I\)</span>中的项都在<span
class="math inline">\(I\)</span>的闭包中</p></li>
<li><p><span class="math inline">\((3)\)</span>的含义是如果<span
class="math inline">\(\text{CLOSURE}(I)\)</span>中某个项的点号的右侧是一个非终结符，那么以该非终结符为左部且点号在右部最左侧的项也在<span
class="math inline">\(\text{CLOSURE}(I)\)</span>中。进一步也就是说如果此时分析器期待对非终结符<span
class="math inline">\(B\)</span>的归约，那么它也同样期待着由<span
class="math inline">\(B\)</span>产生的那些符号，因为只有那些符号才能归约成<span
class="math inline">\(B\)</span>。</p></li>
</ul>
<h3 id="textgoto函数"><span
class="math inline">\(\text{GOTO}\)</span>函数</h3>
<p><span
class="math inline">\(\text{GOTO}\)</span>函数也将一个项目集合映射到另一个项目集合，它的输入是项目集合<span
class="math inline">\(I\)</span>和一个文法符号<span
class="math inline">\(X\)</span>，输出是该项目集合中所有项遇到文法符号<span
class="math inline">\(X\)</span>后所有后继项的闭包。</p>
<blockquote>
<p>后继项：对于项<span class="math inline">\(A\rightarrow X\cdot
YZ\)</span>而言，它的后继项就是将点号移动到项右部的下一个文法符号，即<span
class="math inline">\(A\rightarrow XY\cdot Z\)</span>。</p>
</blockquote>
<p>它的意义是求出分析器状态机中的所有状态转移。定义<span
class="math inline">\(\text{GOTO}\)</span>函数：</p>
<blockquote>
<p><span class="math inline">\(\text{GOTO}(I, X) =
\text{CLOSURE}(\{A\rightarrow \alpha X\cdot \beta \ |\ \forall
A\rightarrow \alpha \cdot X \beta \in I \})\)</span></p>
</blockquote>
<h3 id="规范textlr0项集族-canonical-lr0-collection">规范<span
class="math inline">\(\text{LR}(0)\)</span>项集族 canonical LR(0)
collection</h3>
<p>所谓项集族，指的是项目集合的集合，也就是说项集族中每一个元素都是一个项目的集合。利用<span
class="math inline">\(\text{CLOSURE}\)</span>函数和<span
class="math inline">\(\text{GOTO}\)</span>函数，可以构造出一个文法的规范<span
class="math inline">\(\text{LR}(0)\)</span>项集族。定义规范<span
class="math inline">\(\text{LR}(0)\)</span>项集族：</p>
<blockquote>
<p><span class="math inline">\(C = \{I_{0}\}\cup \{I\ |\ \exists J\in C,
X\in V_{N}\cup V_{T}, I = \text{GOTO}(J, X)\}\)</span></p>
</blockquote>
<p>上面表达式的含义是：</p>
<ul>
<li><p><span class="math inline">\(C\)</span>中包含了项<span
class="math inline">\(S^{\prime}\rightarrow \cdot
S\)</span>的闭包。</p></li>
<li><p>对<span class="math inline">\(C\)</span>中的每一个项目集合<span
class="math inline">\(I\)</span>和文法中每一个符号<span
class="math inline">\(X\)</span>，如果<span
class="math inline">\(\text{GOTO}(I, X)\)</span>不在<span
class="math inline">\(C\)</span>中，则将其添加到<span
class="math inline">\(C\)</span>中。</p></li>
</ul>
<h2 id="textlr0分析器"><span
class="math inline">\(\text{LR}(0)\)</span>分析器</h2>
<h3 id="textlr0分析表的结构"><span
class="math inline">\(\text{LR}(0)\)</span>分析表的结构</h3>
<p><span
class="math inline">\(\text{LR}(0)\)</span>分析表是一个二维表格，它的行数等于文法<span
class="math inline">\(G\)</span>的规范<span
class="math inline">\(\text{LR}(0)\)</span>项集族中元素个数，列数等于<span
class="math inline">\(G\)</span>中文法符号的个数。分析表中的每一个单元表示在某个状态下遇到某个文法符号时，下一步需要进行的操作。整个分析表被划分为<span
class="math inline">\(\text{ACTION}\)</span>和<span
class="math inline">\(\text{GOTO}\)</span>两个区域，落入对应区域的单元分别表示遇到终结符和非终结符时所进行的操作。</p>
<p>对于<span class="math inline">\(\text{ACTION}\)</span>：</p>
<ul>
<li><p>如果为<span
class="math inline">\(s_{i}\)</span>，则表示移入（shift）操作，分析器将输入指针指向的符号移入符号栈，然后将状态<span
class="math inline">\(S_{i}\)</span>移入状态栈。</p></li>
<li><p>如果为<span
class="math inline">\(r_{i}\)</span>，则表示归约（reduce）操作，分析器将使用第<span
class="math inline">\(i\)</span>个产生式对符号栈顶的句柄进行归约操作。</p></li>
</ul>
<p>对于<span
class="math inline">\(\text{GOTO}\)</span>，单元格中所有的元素都是数字，<span
class="math inline">\(j = \text{GOTO}[S_{i}, X]\)</span>表示状态<span
class="math inline">\(S_{i}\)</span>遇到栈顶为非终结符<span
class="math inline">\(X\)</span>时将状态<span
class="math inline">\(S_{j}\)</span>入栈。</p>
<h3 id="textlr0分析器的结构"><span
class="math inline">\(\text{LR}(0)\)</span>分析器的结构</h3>
<p><span
class="math inline">\(\text{LR}(0)\)</span>分析器包含4个主要部分：</p>
<ul>
<li><p>输入缓冲</p></li>
<li><p>符号和状态栈</p></li>
<li><p><span class="math inline">\(\text{LR}(0)\)</span>分析表</p></li>
<li><p>驱动程序</p></li>
</ul>
<p>它的运行中的格局是：</p>
<ol type="1">
<li>初始格局为：</li>
</ol>
<p><span class="math display">\[\begin{align}
&amp;S_{0} \\
&amp;\$ &amp;a_{1}a_{2}\cdots a_{n}\$\\
\end{align}\]</span></p>
<p>其中<span class="math inline">\(S_{0}\)</span>表示初始状态，对应<span
class="math inline">\(S^{\prime}\rightarrow \cdot
S\)</span>的项目集闭包。</p>
<ol start="2" type="1">
<li>假设运行时的一个格局是：</li>
</ol>
<p><span class="math display">\[\begin{align}
&amp;S_{0}S_{1}S_{2}\cdots S_{m} \\
&amp;\$ X_{1}X_{2}\cdots X_{m} &amp;a_{i}a_{i + 1}\cdots a_{n}\$\\
\end{align}\]</span></p>
<ul>
<li><p>若<span class="math inline">\(\text{ACTION}[S_{m}, a_{i}] =
s_{x}\)</span>，则进行移入操作，格局变为： <span
class="math display">\[\begin{align}
&amp;S_{0}S_{1}S_{2}\cdots S_{m}S_{x} \\
&amp;\$ X_{1}X_{2}\cdots X_{m}a_{i} &amp;a_{i + 1}\cdots a_{n}\$\\
  \end{align}\]</span></p></li>
<li><p>若<span class="math inline">\(\text{ACTION}[S_{m}, a_{i}] =
r_{x}\)</span>，则进行归约操作，使用第<span
class="math inline">\(x\)</span>个产生式<span
class="math inline">\(A\rightarrow X_{m - (k - 1)}\cdots
X_{m}\)</span>，格局变为： <span class="math display">\[\begin{align}
&amp;S_{0}S_{1}S_{2}\cdots S_{m - k} \\
&amp;\$ X_{1}X_{2}\cdots X_{m - k}A &amp;a_{i}a_{i + 1}\cdots a_{n}\$\\
  \end{align}\]</span></p></li>
</ul>
<p>而后查找<span class="math inline">\(\text{GOTO}\)</span>表，若<span
class="math inline">\(\text{GOTO}[S_{m - k}, A] =
y\)</span>，则进行状态转移，格局变为：</p>
<p><span class="math display">\[\begin{align}
&amp;S_{0}S_{1}S_{2}\cdots S_{m - k}S_{y} \\
&amp;\$ X_{1}X_{2}\cdots X_{m - k}A &amp;a_{i}a_{i + 1}\cdots a_{n}\$\\
  \end{align}\]</span></p>
<ul>
<li>若<span class="math inline">\(\text{ACTION}[S_{m}, a_{i}] =
\text{acc}\)</span>，则分析成功。</li>
<li>若<span class="math inline">\(\text{ACTION}[S_{m}, a_{i}] =
\text{err}\)</span>，则分析失败。</li>
</ul>
<h3 id="构造textlr0分析表">构造<span
class="math inline">\(\text{LR}(0)\)</span>分析表</h3>
<p>构造<span
class="math inline">\(\text{LR}(0)\)</span>分析表的方法是：</p>
<ol type="1">
<li><p>首先求文法<span class="math inline">\(G\)</span>的<span
class="math inline">\(\text{LR}(0)\)</span>项集族<span
class="math inline">\(C\)</span></p></li>
<li><p>对于<span class="math inline">\(C\)</span>中的每一个项目集<span
class="math inline">\(I\)</span>：</p>
<ol type="1">
<li><p>如果<span class="math inline">\(\text{GOTO}(I, \alpha) =
I^{\prime}\)</span>，则<span class="math inline">\(\text{ACTION}[I,
\alpha] = S_{I^{\prime}}\)</span></p></li>
<li><p>如果<span class="math inline">\(\text{GOTO}(I, A) =
I^{\prime}\)</span>，则<span class="math inline">\(\text{GOTO}[I, A] =
I^{\prime}\)</span></p></li>
<li><p>如果<span class="math inline">\(I\)</span>中有归约项，则<span
class="math inline">\(\forall \alpha, \text{ACTION}[I, \alpha] =
r_{x}\)</span>，其中<span
class="math inline">\(x\)</span>为归约项对应产生式的编号</p></li>
</ol></li>
</ol>
]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>My First Article</title>
    <url>/2022/02/02/My-First-Article/</url>
    <content><![CDATA[<h2 id="chapter-1">Chapter 1</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, World!\n&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="chapter-2">Chapter 2</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;Hello, World!\n&quot;</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="chapter-3">Chapter 3</h2>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/usr/bin/bash</span><br>echo &quot;Hello, World!&quot;<br></code></pre></td></tr></table></figure>
<h2 id="chapter-4">Chapter 4</h2>
<figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby"><span class="hljs-meta">#!/usr/bin/ruby</span><br>puts <span class="hljs-string">&quot;Hello, World!&quot;</span><br></code></pre></td></tr></table></figure>
<h2 id="chapter-5">Chapter 5</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello, World!&quot;</span>)<br></code></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>chisel 使用浅测</title>
    <url>/2022/06/02/chisel%E4%BD%BF%E7%94%A8%E6%B5%85%E6%B5%8B/</url>
    <content><![CDATA[<h2 id="什么是-chisel">什么是 chisel</h2>
<p>关于“什么是
chisel”这个问题，在网上已经有了详尽的讨论：它是硬件描述语言，它是 scala
的包等等。在我的使用范畴下，我认为它是一个编译器，依托于 scala
包的形式存在，有些类似于 LLVM
以库的形式存在的特点。它具有编译器的特点：源语言是 scala，目标语言是
verilog，此外还具有中间表示 FIRRTL。chisel 的工作过程可以理解为：通过在
scala 代码中调用一些 chisel 包中的类和方法，再运行这段 scala
代码，产生可综合的 verilog。</p>
<h2 id="chisel-的优势">chisel 的优势</h2>
<p>chisel 的敏捷性源于它更高层次的抽象以及 scala
语言本身面向对象、函数式的特点。</p>
<h3 id="丰富的数据类型">丰富的数据类型</h3>
<p>下面是 <a href="https://www.chisel-lang.org/">chisel 官网</a>
中数据类型的继承关系图：</p>
<p><img src="/img/chisel_type_hierarchy.svg" /></p>
<p>比较常用的数据类型有
<code>UInt</code>，<code>SInt</code>，<code>Bool</code>，<code>Clock</code>
和 <code>Reset</code>。此外还可以通过 <code>Vec</code> 和
<code>Bundle</code> 将它们聚集起来，<code>Vec</code>
用于聚集相同的类型，而 <code>Bundle</code> 用于聚集不同的类型。</p>
<h3 id="简单的硬件模型">简单的硬件模型</h3>
<p>在 chisel 中的硬件模型只有两种：线网 <code>Wire</code> 和寄存器
<code>Reg</code>，并且使用了 <code>Reg</code>
声明的变量最终一定会产生寄存器，而不像 verilog 一样不能确定。</p>
<p>声明一个硬件需要将数据类型和硬件模型结合起来使用：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> foo = <span class="hljs-type">Wire</span>(<span class="hljs-type">UInt</span>(<span class="hljs-number">32.</span><span class="hljs-type">W</span>))<br><span class="hljs-keyword">val</span> bar = <span class="hljs-type">Reg</span>(<span class="hljs-type">Bool</span>())<br></code></pre></td></tr></table></figure>
<p><code>foo</code> 描述了一个 32 位宽的线，<code>bar</code> 描述了一个
1 位宽的寄存器。需要注意的是，在 chisel
中的时钟和复位信号是隐含的，<code>Reg</code>
默认使用该寄存器所在模块的同步时钟和复位信号。</p>
<h3 id="自定义类型">自定义类型</h3>
<p>在编写 verilog
时，常常因为散乱的接口而难以维护，陷入“设计一小时，模块编码一小时，接线两小时”的窘境，chisel
的自定义类型解决了这一问题。</p>
<h4 id="bundle-继承">Bundle 继承</h4>
<p>通过继承 <code>Bundle</code>
类，用户可以自定义线束类型，将不同类型的线聚集起来：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBundle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Bundle</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> src = <span class="hljs-type">Vec</span>(<span class="hljs-number">2</span>, <span class="hljs-type">UInt</span>(<span class="hljs-number">32.</span><span class="hljs-type">W</span>))<br>  <span class="hljs-keyword">val</span> op = <span class="hljs-type">Vec</span>(<span class="hljs-number">12</span>, <span class="hljs-type">Bool</span>())<br>&#125;<br></code></pre></td></tr></table></figure>
<p>定义了由两个 32 位操作数 <code>src</code> 和一个 12 位操作码
<code>op</code>
所组成的线束。在模块中，可以使用自定义类型产生硬件并对其进行连接：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> myBundle = <span class="hljs-type">Wire</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">MyBundle</span>)<br>myBundle.src(<span class="hljs-number">0</span>) := <span class="hljs-number">0.</span><span class="hljs-type">U</span><br>myBundle.src(<span class="hljs-number">1</span>) := <span class="hljs-number">1.</span><span class="hljs-type">U</span><br>myBundle.op := <span class="hljs-string">&quot;b000100&quot;</span>.<span class="hljs-type">U</span><br></code></pre></td></tr></table></figure>
<h4 id="module-继承">Module 继承</h4>
<p>Module 是电路中基本组成单元，chisel 中的模块同样抽象为 IO
接口和内部逻辑，通过继承 Module 可以自定义模块：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyModule</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Module</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> io = <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Bundle</span>()&#123;<br>    <span class="hljs-keyword">val</span> in = <span class="hljs-type">Input</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">MyBundle</span>)<br>    <span class="hljs-keyword">val</span> out = <span class="hljs-type">Output</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Bundle</span>()&#123;<br>      <span class="hljs-keyword">val</span> res = <span class="hljs-type">UInt</span>(<span class="hljs-number">32.</span><span class="hljs-type">W</span>)<br>    &#125;)<br>  &#125;)<br><br>  io.out.res := <span class="hljs-type">Mux1H</span>(<span class="hljs-type">Seq</span>(<br>    io.in.op(<span class="hljs-number">0</span>) -&gt; io.in.src(<span class="hljs-number">0</span>) + io.in.src(<span class="hljs-number">1</span>),<br>    io.in.op(<span class="hljs-number">1</span>) -&gt; io.in.src(<span class="hljs-number">0</span>) - io.in.src(<span class="hljs-number">1</span>),<br>    ...<br>  ))<br>&#125;<br></code></pre></td></tr></table></figure>
<p>定义了一个使用 12 位独热码作为操作码的 alu 模块。其中值
<code>io</code> 定义了该模块的 IO 接口。为了创建它，定义了一个匿名的
Bundle 对象，其中包含 <code>in</code> 和 <code>out</code>
分别定义输入接口和输出接口。定义 IO 接口中的 3 个方法
<code>IO</code>，<code>Input</code> 和 <code>Output</code>
接受的参数都是 <code>Bundle</code>
的对象，因此在这里可以使用自定义的线束类型。<code>MyModule</code>
中剩余部分是该模块的内部逻辑，这里使用了原语 <code>Mux1H</code>
生成一个独热码选择器。</p>
<h4 id="快速连接模块">快速连接模块</h4>
<p>chisel 中基本的连接算符是 <code>:=</code>
，信号的流动方向是从右向左。chisel 中还提供了一种 element-wise
的连接算符
<code>&lt;&gt;</code>，它可以快速连接线束中的<strong>同名元素</strong>，并检查其类型是否相同：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyModuleWrap</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Module</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> io = <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Bundle</span>()&#123;<br>    <span class="hljs-keyword">val</span> in = <span class="hljs-type">Input</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">MyBundle</span>)<br>    <span class="hljs-keyword">val</span> out = <span class="hljs-type">Output</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Bundle</span>()&#123;<br>      <span class="hljs-keyword">val</span> res = <span class="hljs-type">UInt</span>(<span class="hljs-number">32.</span><span class="hljs-type">W</span>)<br>    &#125;)<br>  &#125;)<br>  <span class="hljs-keyword">val</span> myAlu = <span class="hljs-type">Module</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">MyModule</span>)<br><br>  myAlu.io&lt;&gt;io<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="强大的语法检查">强大的语法检查</h3>
<p>正如上文所提到的，在 chisel
进行编译时，编译器将检查连接左右硬件的数据类型是否相同，若不同则报错，停止编译。实际上，chisel
编译器还做了更多的事情，能够帮助在编码时就检查出一些设计功能无关的错误，节省开发时间。</p>
<h3 id="参数化模块">参数化模块</h3>
<p>由于所有类型的定义都是基于 scala
的类，因此可以使用类的初始化参数对模块进行参数化定义：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBundle</span>(<span class="hljs-params">xLen:<span class="hljs-type">Int</span> = 32</span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Bundle</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> src = <span class="hljs-type">Vec</span>(<span class="hljs-number">2</span>, <span class="hljs-type">UInt</span>(xLen.<span class="hljs-type">W</span>))<br>  <span class="hljs-keyword">val</span> op = <span class="hljs-type">Vec</span>(<span class="hljs-number">12</span>, <span class="hljs-type">Bool</span>())<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyModule</span>(<span class="hljs-params">xLen:<span class="hljs-type">Int</span> = 32</span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Module</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> io = <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Bundle</span>()&#123;<br>    <span class="hljs-keyword">val</span> in = <span class="hljs-type">Input</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">MyBundle</span>(xLen))<br>    <span class="hljs-keyword">val</span> out = <span class="hljs-type">Output</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Bundle</span>()&#123;<br>      <span class="hljs-keyword">val</span> res = <span class="hljs-type">UInt</span>(xLen.<span class="hljs-type">W</span>)<br>    &#125;)<br>  &#125;)<br><br>  io.out.res := <span class="hljs-type">Mux1H</span>(<span class="hljs-type">Seq</span>(<br>    io.in.op(<span class="hljs-number">0</span>) -&gt; io.in.src(<span class="hljs-number">0</span>) + io.in.src(<span class="hljs-number">1</span>),<br>    io.in.op(<span class="hljs-number">1</span>) -&gt; io.in.src(<span class="hljs-number">0</span>) - io.in.src(<span class="hljs-number">1</span>),<br>    ...<br>  ))<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在实例化模块时，可以通过改变传入的参数定制不同的模块：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> myModule1 = <span class="hljs-type">Module</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">MyModule</span>(<span class="hljs-number">16</span>))<br><span class="hljs-keyword">val</span> myModule2 = <span class="hljs-type">Module</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">MyModule</span>(<span class="hljs-number">32</span>))<br></code></pre></td></tr></table></figure>
<h3 id="scala-集合类型和函数式编程">scala 集合类型和函数式编程</h3>
<p>集合类型和函数式编程都是 scala 的语言特性，由于 chisel 是 scala
的包，因此可以使用这些特性用于构造硬件生成器。</p>
<p>比如说对于设计 CPU
核而言，一个明显的集合是<strong>指令集</strong>，在 chisel
中，可以将所有指令放到一个查找表中，利用 scala 的
<code>ListLookUp</code> 方法生成译码逻辑：</p>
<ol type="1">
<li>首先，构造查找表，它使用一个指令作为索引，查找结果是控制信号：</li>
</ol>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">DecodeConstants</span> </span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">CtrlIdx</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">scala</span>.<span class="hljs-title">Enumeration</span> </span>&#123;<br>    <span class="hljs-keyword">val</span> selSrc0, selSrc1, selImm, selWnum, fuType, fuOp, rfWen, illegal = <span class="hljs-type">Value</span><br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">default</span></span>: <span class="hljs-type">List</span>[<span class="hljs-type">UInt</span>] = <span class="hljs-comment">// no instruction</span><br>  <span class="hljs-comment">//     SelSrc(0)</span><br>  <span class="hljs-comment">//     |   SelSrc(1)</span><br>  <span class="hljs-comment">//     |   |   SelImm</span><br>  <span class="hljs-comment">//     |   |   |    SelWnum</span><br>  <span class="hljs-comment">//     |   |   |    |      FuType</span><br>  <span class="hljs-comment">//     |   |   |    |      |    FuOp</span><br>  <span class="hljs-comment">//     |   |   |    |      |    |    rfWen</span><br>  <span class="hljs-comment">//     |   |   |    |      |    |    |  illegal</span><br>    <span class="hljs-type">List</span>(rs, rt, nan, dzero, alu, sll, f, t)<br>  <span class="hljs-keyword">val</span> table: <span class="hljs-type">Array</span>[(<span class="hljs-type">BitPat</span>, <span class="hljs-type">List</span>[<span class="hljs-type">UInt</span>])]<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">MIPS32I</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">DecodeConstants</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> table: <span class="hljs-type">Array</span>[(<span class="hljs-type">BitPat</span>, <span class="hljs-type">List</span>[<span class="hljs-type">UInt</span>])] = <span class="hljs-type">Array</span>(<br>    <span class="hljs-type">SLL</span>   -&gt; rTypeRAlu(sll),<br>    <span class="hljs-type">SRL</span>   -&gt; rTypeRAlu(srl),<br>    <span class="hljs-type">SRA</span>   -&gt; rTypeRAlu(sra),<br><br>    <span class="hljs-type">JR</span>    -&gt; rTypeJr(jumpr),<br><br>    <span class="hljs-type">ADDU</span>  -&gt; rTypeRAlu(add),<br>    <span class="hljs-type">SUBU</span>  -&gt; rTypeRAlu(sub),<br><br>    <span class="hljs-type">AND</span>   -&gt; rTypeRAlu(and),<br>    <span class="hljs-type">OR</span>    -&gt; rTypeRAlu(or),<br>    <span class="hljs-type">XOR</span>   -&gt; rTypeRAlu(xor),<br>    <span class="hljs-type">NOR</span>   -&gt; rTypeRAlu(nor),<br>    <span class="hljs-type">SLT</span>   -&gt; rTypeRAlu(slt),<br>    <span class="hljs-type">SLTU</span>  -&gt; rTypeRAlu(sltu),<br><br>    <span class="hljs-type">JAL</span>   -&gt; jTypeJal(jump),<br><br>    <span class="hljs-type">BEQ</span>   -&gt; iTypeBr(beq),<br>    <span class="hljs-type">BNE</span>   -&gt; iTypeBr(bne),<br><br>    <span class="hljs-type">ADDIU</span> -&gt; iTypeUAlu(add),<br><br>    <span class="hljs-type">LUI</span>   -&gt; iTypeUAlu(lui),<br><br>    <span class="hljs-type">LW</span>    -&gt; iTypeLd(lw),<br><br>    <span class="hljs-type">SW</span>    -&gt; iTypeSt(sw)<br>  )<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>table</code>
定义了所需要的查找表，它的表项是一系列键-值对，键-值对在 scala 中使用
<code>-&gt;</code>
表示，左边是键，右边是值。在查找表中，所有键的类型都是
<code>BitPat</code>，它是 chisel
中的一种用于做二进制串模式匹配的类型；所有值的类型都是
<code>List[UInt]</code>，即由 <code>UInt</code>
对象组成的列表，用于表示某条指令对应的控制信号的具体取值。</p>
<ol start="2" type="1">
<li>定义控制信号的线束：</li>
</ol>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ControlSignals</span>(<span class="hljs-params">xLen:<span class="hljs-type">Int</span> = 32</span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Bundle</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> selSrc0 = <span class="hljs-type">UInt</span>()<br>  <span class="hljs-keyword">val</span> selSrc1 = <span class="hljs-type">UInt</span>()<br>  <span class="hljs-keyword">val</span> selImm = <span class="hljs-type">UInt</span>()<br>  <span class="hljs-keyword">val</span> selWnum = <span class="hljs-type">UInt</span>()<br>  <span class="hljs-keyword">val</span> fuType = <span class="hljs-type">UInt</span>()<br>  <span class="hljs-keyword">val</span> fuOp = <span class="hljs-type">UInt</span>()<br>  <span class="hljs-keyword">val</span> rfWen = <span class="hljs-type">Bool</span>()<br>  <span class="hljs-keyword">val</span> illegal = <span class="hljs-type">Bool</span>()<br><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">signals</span> </span>= <span class="hljs-type">Array</span>(<br>    <span class="hljs-type">MIPS32I</span>.<span class="hljs-type">CtrlIdx</span>.selSrc0 -&gt; selSrc0,<br>    <span class="hljs-type">MIPS32I</span>.<span class="hljs-type">CtrlIdx</span>.selSrc1 -&gt; selSrc1,<br>    <span class="hljs-type">MIPS32I</span>.<span class="hljs-type">CtrlIdx</span>.selImm -&gt; selImm,<br>    <span class="hljs-type">MIPS32I</span>.<span class="hljs-type">CtrlIdx</span>.selWnum -&gt; selWnum,<br>    <span class="hljs-type">MIPS32I</span>.<span class="hljs-type">CtrlIdx</span>.fuType -&gt; fuType,<br>    <span class="hljs-type">MIPS32I</span>.<span class="hljs-type">CtrlIdx</span>.fuOp -&gt; fuOp,<br>    <span class="hljs-type">MIPS32I</span>.<span class="hljs-type">CtrlIdx</span>.rfWen -&gt; rfWen,<br>    <span class="hljs-type">MIPS32I</span>.<span class="hljs-type">CtrlIdx</span>.illegal -&gt; illegal<br>  )<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里没有指定信号的位宽，在编译时 chisel
将自动推导出它们的宽度。另外，定义了 <code>signal</code>
方法，它返回一个
<code>Array</code>，存储这些信号在查找结果中的索引和具体信号值的键-值对，方便在模块中对其进行迭代。</p>
<ol start="3" type="1">
<li>定义译码模块：</li>
</ol>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Instruction</span>(<span class="hljs-params">xLen:<span class="hljs-type">Int</span> = 32</span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Bundle</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> instr = <span class="hljs-type">UInt</span>(xLen.<span class="hljs-type">W</span>)<br>  <span class="hljs-keyword">val</span> pc = <span class="hljs-type">UInt</span>(xLen.<span class="hljs-type">W</span>)<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ControlIO</span>(<span class="hljs-params">xLen:<span class="hljs-type">Int</span> = 32</span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Bundle</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> in = <span class="hljs-type">Input</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Instruction</span>(xLen))<br>  <span class="hljs-keyword">val</span> out = <span class="hljs-type">Output</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">ControlSignals</span>(xLen))<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Control</span>(<span class="hljs-params">xLen:<span class="hljs-type">Int</span> = 32</span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Module</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> io = <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">ControlIO</span>(xLen))<br><br>  <span class="hljs-keyword">val</span> ctrlSignals = <span class="hljs-type">ListLookup</span>(io.in.instr, <span class="hljs-type">MIPS32I</span>.<span class="hljs-keyword">default</span>, <span class="hljs-type">MIPS32I</span>.table)<br>  io.out.signals.map(x =&gt; x._2 := ctrlSignals(x._1.id))<br>&#125;<br></code></pre></td></tr></table></figure>
<p>译码模块 <code>Control</code> 的输入是一条指令及其对应的
<code>pc</code>，输出是控制信号。该模块的巧妙之处在于控制信号的生成。</p>
<p>首先，使用 <code>ListLookup</code>
方法对之前构建的查找表进行查找，查找的结果是一个 <code>UInt</code>
组成的 <code>List</code>，将其存储在 <code>ctrlSignals</code> 中。</p>
<p>然后调用 <code>Array</code>（<code>io.out.signals</code> 方法返回一个
<code>Array</code>）的 <code>map</code>
方法进行迭代。该方法传入了一个匿名函数
<code>x =&gt; x._2 := ctrlSignals(x._1.id)</code>，它将
<code>Array</code>中的每一项取出，使用该项的键索引查找结果，然后将其连接到对应的值上。最终的效果是将查找结果的每一项都连接到了对应的控制信号上。</p>
<h3 id="scala-泛型">scala 泛型</h3>
<p>由于 scala 泛型的存在，可以对电路进行更高层次的抽象。</p>
<p>比如说对于流水线寄存器而言，可以将其抽象为：</p>
<ol type="1">
<li>IO 接口：</li>
</ol>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">名称</th>
<th style="text-align: center;">方向</th>
<th style="text-align: center;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">io.in.data.valid</td>
<td style="text-align: center;">input</td>
<td style="text-align: center;">输入数据有效</td>
</tr>
<tr class="even">
<td style="text-align: center;">io.in.data.bits</td>
<td style="text-align: center;">input</td>
<td style="text-align: center;">输入数据</td>
</tr>
<tr class="odd">
<td style="text-align: center;">io.in.stall</td>
<td style="text-align: center;">input</td>
<td style="text-align: center;">流水级暂停</td>
</tr>
<tr class="even">
<td style="text-align: center;">io.in.flush</td>
<td style="text-align: center;">input</td>
<td style="text-align: center;">流水级冲刷</td>
</tr>
<tr class="odd">
<td style="text-align: center;">io.out.data.valid</td>
<td style="text-align: center;">output</td>
<td style="text-align: center;">输出数据有效</td>
</tr>
<tr class="even">
<td style="text-align: center;">io.out.data.bits</td>
<td style="text-align: center;">outptu</td>
<td style="text-align: center;">输出数据</td>
</tr>
</tbody>
</table>
<ol start="2" type="1">
<li>内部逻辑（伪代码）：</li>
</ol>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StageReg</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Module</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> io = <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">StageRegIO</span>)<br><br>  <span class="hljs-keyword">val</span> validReg = <span class="hljs-type">Reg</span>(<span class="hljs-type">Bool</span>())<br>  <span class="hljs-keyword">val</span> dataReg = <span class="hljs-type">Reg</span>(<span class="hljs-type">DataType</span>())<br><br>  when(reset.asBool || io.in.flush) &#123;<br>    validReg := <span class="hljs-number">0.</span><span class="hljs-type">U</span><br>  &#125; .elsewhen(!io.in.stall) &#123;<br>    validReg := io.in.data.valid<br>  &#125;<br><br>  when (!io.in.stall) &#123;<br>    dataReg := io.in.data.bits<br>  &#125;<br><br>  io.out.data.valid := validReg<br>  io.out.data.bits := dataReg<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在实际使用中，IO 接口和内部逻辑都是不变的，发生变化的是输入数据的类型
<code>DataType</code>，因此可以对于输入的数据类型使用泛型：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StageRegIn</span>[<span class="hljs-type">T</span>&lt;:<span class="hljs-type">Bundle</span>](<span class="hljs-params">xLen:<span class="hljs-type">Int</span> = 32, dataType: <span class="hljs-type">T</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Bundle</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> stall = <span class="hljs-type">Input</span>(<span class="hljs-type">Bool</span>())<br>  <span class="hljs-keyword">val</span> flush = <span class="hljs-type">Input</span>(<span class="hljs-type">Bool</span>())<br>  <span class="hljs-keyword">val</span> data = <span class="hljs-type">Flipped</span>(<span class="hljs-type">Valid</span>(dataType))<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StageRegOut</span>[<span class="hljs-type">T</span>&lt;:<span class="hljs-type">Bundle</span>](<span class="hljs-params">xLen:<span class="hljs-type">Int</span> = 32, dataType: <span class="hljs-type">T</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Bundle</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> data = <span class="hljs-type">Valid</span>(dataType)<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StageRegIO</span>[<span class="hljs-type">T</span>&lt;:<span class="hljs-type">Bundle</span>](<span class="hljs-params">xLen:<span class="hljs-type">Int</span> = 32, dataType: <span class="hljs-type">T</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Bundle</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> in = <span class="hljs-keyword">new</span> <span class="hljs-type">StageRegIn</span>(xLen, dataType)<br>  <span class="hljs-keyword">val</span> out = <span class="hljs-keyword">new</span> <span class="hljs-type">StageRegOut</span>(xLen, dataType)<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StageReg</span>[<span class="hljs-type">T</span>&lt;:<span class="hljs-type">Bundle</span>](<span class="hljs-params">xLen:<span class="hljs-type">Int</span> = 32, dataType: <span class="hljs-type">T</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Module</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> io = <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">StageRegIO</span>(xLen, dataType))<br><br>  <span class="hljs-keyword">val</span> validReg = <span class="hljs-type">Reg</span>(<span class="hljs-type">Bool</span>())<br>  <span class="hljs-keyword">val</span> dataReg = <span class="hljs-type">Reg</span>(dataType)<br><br>  when(reset.asBool || io.in.flush) &#123;<br>    validReg := <span class="hljs-number">0.</span><span class="hljs-type">U</span><br>  &#125; .elsewhen(!io.in.stall) &#123;<br>    validReg := io.in.data.valid<br>  &#125;<br><br>  when (!io.in.stall) &#123;<br>    dataReg := io.in.data.bits<br>  &#125;<br><br>  io.out.data.valid := validReg<br>  io.out.data.bits := dataReg<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在实例化一个流水级寄存器时，可以传入自定义类型以定制寄存器的输入输出数据类型：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> myStageReg = <span class="hljs-type">Module</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">StageReg</span>(<span class="hljs-number">32</span>, <span class="hljs-keyword">new</span> <span class="hljs-type">MyBundle</span>))<br></code></pre></td></tr></table></figure>
<h2 id="chisel-的劣势">chisel 的劣势</h2>
<h3 id="学习成本高">学习成本高</h3>
<p>chisel 是基于 scala 开发的包，因此使用 chisel 需要先学习
scala。相比于 C 而言，scala
是一门完全不同的语言，其中面向对象、函数式编程的特性是 C
所不具备的，需要从头学习。之所以需要学习这些高级特性，是因为只有使用了这些特性才能充分利用
chisel 的优势，否则 chisel 的使用体验和 verilog 差不多。</p>
<h3 id="对工业级开发流程支持尚不完善">对工业级开发流程支持尚不完善</h3>
<p>目前，我只把 chisel 当作一个工具，用于使用更少、更易于维护的代码生成
verilog，然后将 verilog 导入 vivado 工程，作为 SOC
的一部分进行仿真、综合、实现、比特流生成和上板。虽然 chisel
中包含测试模块，但是它完全不支持对于 IP 核的调用。</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><p><a
href="https://www.chisel-lang.org/chisel3/docs/introduction.html">chisel
官方文档</a>：包含了一些 chisel 的基本使用方法</p></li>
<li><p><a
href="https://www.chisel-lang.org/api/latest/index.html">chisel API
文档</a>：包含所有 chisel API 的原型和使用方法</p></li>
<li><p><a
href="https://github.com/freechipsproject/chisel-bootcamp">chisel
bootcamp</a>：一个 chisel/scala 从零入门教程</p></li>
</ul>
]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>硬件描述语言</tag>
        <tag>chisel</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/10/25/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very
first post. Check <a href="https://hexo.io/docs/">documentation</a> for
more info. If you get any problems when using Hexo, you can find the
answer in <a
href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or
you can ask me on <a
href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="quick-start">Quick Start</h2>
<h3 id="create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure>
<p>More info: <a
href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure>
<p>More info: <a
href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure>
<p>More info: <a
href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>nju-pa摸鱼记1-宏的妙用</title>
    <url>/2022/01/31/nju-pa%E6%91%B8%E9%B1%BC%E8%AE%B01-%E5%AE%8F%E7%9A%84%E5%A6%99%E7%94%A8/</url>
    <content><![CDATA[<h2 id="一前言">一、前言</h2>
<p>上学期在课内学习了《计算机体系结构》，一直对最后一章老师讲到的硬件模拟器念念不忘，好奇它的工作原理。好巧不巧，某日在我刷github的时候南京大学的<a
href="https://github.com/NJU-ProjectN/ics-pa">ics-pa项目</a>出现在了我的首页推荐中，于是我便打算利用寒假的时间过一下这个项目，并通过<a
href="https://www.bilibili.com/read/cv15072569">B站的专栏</a>（现在同步到我的个人博客上）记录一些新的知识或者是心得体会。</p>
<h2 id="二使用宏配置编译选项">二、使用宏配置编译选项</h2>
<p>在项目代码进行编译前，需要先使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">make menuconfig<br></code></pre></td></tr></table></figure>
<p>对项目进行配置，在勾选了一些选项退出后，<code>menuconfig</code>会根据之前的选项生成一些宏保存到若干文件中，供之后的.c文件或Makefile文件所包含（使用include）。这样，在C语言源文件或makefile脚本中通过对这些宏加以判断，就可以在编译时使用或抛弃某些特定的功能。</p>
<h2 id="三c语言中检测宏是否被定义">三、C语言中检测宏是否被定义</h2>
<h3 id="使用条件编译指令">1、使用条件编译指令</h3>
<p>在C语言源文件中，可以使用条件编译指令</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> FOO</span><br>  ...<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure>
<p>将宏<code>FOO</code>对应功能的代码包围起来，如果在<code>menuconfig</code>中勾选了该宏所对应的选项，则宏<code>FOO</code>会被定义，最终这段代码也会被编译。</p>
<h3 id="使用宏定义">2、使用宏定义</h3>
<p>除了使用条件编译指令，代码框架还提供了另一种方式检测某个宏是否被定义。之所以要使用另一种方式，是因为条件编译指令不能使用在宏定义中，而频繁地使用条件编译指令会使代码的可读性大打折扣。实现这个功能的关键代码包括：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// macro.h</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> _MACRO_H_</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _MACRO_H_</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> str_temp(x) #x</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> str(x) str_temp(x)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> isdef(macro) (strcmp(<span class="hljs-meta-string">&quot;&quot;</span> #macro, <span class="hljs-meta-string">&quot;&quot;</span> str(macro)) != 0)</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure>
<p>其中宏<code>str(x)</code>使用<code>#</code>运算符将<code>x</code>转化为一个字符串。下面举一个例子来说明<code>isdef</code>这个宏是怎么工作的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// main.c</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;macro.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOO 123</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> a = isdef(FOO);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>经过预处理</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">gcc -o main.i -E main.c<br></code></pre></td></tr></table></figure>
<p>main.i中的内容为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// main.i</span><br>...<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> a = (<span class="hljs-built_in">strcmp</span>(<span class="hljs-string">&quot;&quot;</span> <span class="hljs-string">&quot;FOO&quot;</span>, <span class="hljs-string">&quot;&quot;</span> <span class="hljs-string">&quot;123&quot;</span>) != <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>...<br></code></pre></td></tr></table></figure>
<p>可以发现，<code>strcmp</code>函数的第一个参数对应<code>isdef</code>宏定义中的<code>"" #macro</code>，它直接将宏参数的名称转换为了字符串，而第二个参数对应<code>"" str(macro)</code>，它先将<code>FOO</code>替换为<code>123</code>，然后将<code>123</code>转换为字符串。因此当这两个参数不同时，说明宏已经被定义过。</p>
<p>    通过上面的分析可以发现，宏<code>isdef</code>不能检测宏定义的值与宏定义名称相同的宏，比如说</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOO FOO</span><br></code></pre></td></tr></table></figure>
<p>宏<code>FOO</code>在预处理时仍然被替换为<code>FOO</code>，最后将导致错误的结果。</p>
<p>四、参考资料</p>
<ul>
<li><p><a
href="https://stackoverflow.com/questions/26099745/test-if-preprocessor-symbol-is-defined-inside-macro">stackoverflow上关于如何判断宏是否被定义的讨论</a></p></li>
<li><p><a
href="https://github.com/NJU-ProjectN/ics-pa">南京大学ics-pa项目</a></p></li>
</ul>
]]></content>
      <categories>
        <category>NEMU</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>nju-pa摸鱼记2-计算机与λ演算</title>
    <url>/2022/02/01/nju-pa%E6%91%B8%E9%B1%BC%E8%AE%B02-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8E%CE%BB%E6%BC%94%E7%AE%97/</url>
    <content><![CDATA[<h2 id="一前言">一、前言</h2>
<p>在<a
href="https://miaohao-oops.github.io/2022/01/31/nju-pa%E6%91%B8%E9%B1%BC%E8%AE%B01-%E5%AE%8F%E7%9A%84%E5%A6%99%E7%94%A8/">上一篇</a>中，讨论了如何使用预处理指令或是宏来识别某个宏是否被定义，以实现通过配置进行有选择的编译。不过，仅使用上一篇讨论的<code>isdef</code>宏还不能达到和预处理指令一样的效果，本篇将继续讨论框架中如何使用宏来实现“<strong>如果某个宏被定义，则预处理后保留某些语句或代码块，反之抛弃这些部分</strong>”的功能。之所以提到<span
class="math inline">\(\lambda\)</span>演算，是由于我在搞明白代码框架中的宏是如何运作之后，发现其颇有“函数式编程”的风格，而<span
class="math inline">\(\lambda\)</span>演算是函数式编程的基础，遂记录于此。</p>
<h2 id="二浅谈lambda演算">二、浅谈<span
class="math inline">\(\lambda\)</span>演算</h2>
<h3 id="简介">1、简介</h3>
<p><span
class="math inline">\(\lambda\)</span>演算是一种和图灵机等价的计算模型（<strong>丘奇-图灵论题</strong>），它可以描述任何可计算问题，又称为“最小的编程语言”。简单来说，<span
class="math inline">\(\lambda\)</span>演算的核心是<strong>抽象化定义的函数</strong>，它的参数没有类型的限制，可以是数字，函数或者字符串等等。一个最基础的函数是恒等函数：</p>
<p><span class="math display">\[\lambda x.x\]</span></p>
<p>其中<span class="math inline">\(\lambda\)</span>后的<span
class="math inline">\(x\)</span>是这个函数的<strong>输入</strong>，点号后的<span
class="math inline">\(x\)</span>是函数的<strong>输出</strong>。可以将这个函数作用在变量<span
class="math inline">\(a\)</span>上，就得到：</p>
<p><span class="math display">\[\lambda x.x(a) = a\]</span></p>
<p>通过<strong>柯里化</strong>方法，可以定义二输入函数：</p>
<p><span class="math display">\[\lambda x.\lambda y.x+y\]</span></p>
<p>其中<span class="math inline">\(x\)</span>和<span
class="math inline">\(y\)</span>是该函数的两个输入，该函数的输出是两个输入的和。</p>
<h3 id="用抽象化函数表示布尔逻辑">2、用抽象化函数表示布尔逻辑</h3>
<p>在<span
class="math inline">\(\lambda\)</span>演算中，没有布尔值的概念，但是可以定义两个函数来表示布尔逻辑：</p>
<p><span class="math display">\[\text{TRUE} = \lambda x.\lambda
y.x\]</span></p>
<p><span class="math display">\[\text{FALSE} = \lambda x.\lambda
y.y\]</span></p>
<p>用自然语言来描述<span
class="math inline">\(\text{TRUE}\)</span>函数的作用：“输入两个参数<span
class="math inline">\(x\)</span>和<span
class="math inline">\(y\)</span>，输出第一个参数”，<span
class="math inline">\(\text{FALSE}\)</span>函数的功能同理。这样的话，可以把布尔值<span
class="math inline">\(1\)</span>和<span
class="math inline">\(0\)</span>分别定义成<span
class="math inline">\(\text{TRUE}\)</span>函数和<span
class="math inline">\(\text{FALSE}\)</span>函数。接下来可以定义最基本的非、与、或运算：</p>
<p><span class="math display">\[
\begin{cases}
\text{NOT} &amp;= \lambda x.x\ \text{FALSE}\ \text{TRUE} \\
\text{AND} &amp;= \lambda x.\lambda y.x\ y\ \text{FALSE} \\
\text{OR} &amp;= \lambda x.\lambda y. x\ \text{TRUE}\ y \\
\end{cases}
\]</span></p>
<p>上面的三个函数都是利用了<span
class="math inline">\(\lambda\)</span>演算中参数可以是函数的性质，输入的<span
class="math inline">\(\text{TRUE}\)</span>或<span
class="math inline">\(\text{FALSE}\)</span>都可以作为函数继续运算，下面以<span
class="math inline">\(\text{AND}\)</span>函数为例进行验证：</p>
<p><span class="math display">\[
\begin{align*}
\text{AND}(\text{FALSE})(\text{FALSE}) &amp;=
\text{FALSE}(\text{FALSE})(\text{FALSE}) \\
&amp;= \text{FALSE}
\end{align*}
\]</span></p>
<p><span class="math display">\[
\begin{align*}
\text{AND}(\text{FALSE})(\text{TRUE}) &amp;=
\text{FALSE}(\text{TRUE})(\text{FALSE}) \\
&amp;= \text{FALSE}
\end{align*}
\]</span></p>
<p><span class="math display">\[
\begin{align*}
\text{AND}(\text{TRUE})(\text{FALSE}) &amp;=
\text{TRUE}(\text{FALSE})(\text{FALSE}) \\
&amp;= \text{FALSE}
\end{align*}
\]</span></p>
<p><span class="math display">\[
\begin{align*}
\text{AND}(\text{TRUE})(\text{TRUE}) &amp;=
\text{TRUE}(\text{TRUE})(\text{FALSE}) \\
&amp;= \text{TRUE}
\end{align*}
\]</span></p>
<p>当且仅当<span class="math inline">\(x\)</span>与<span
class="math inline">\(y\)</span>均为<span
class="math inline">\(\text{TRUE}\)</span>时，<span
class="math inline">\(\text{AND}\)</span>的值为<span
class="math inline">\(\text{TRUE}\)</span>。因此，函数<span
class="math inline">\(\text{AND}\)</span>的定义正确。</p>
<h3 id="lambda演算与计算机的联系">3、<span
class="math inline">\(\lambda\)</span>演算与计算机的联系</h3>
<p><span class="math inline">\(\text{TRUE}\)</span>和<span
class="math inline">\(\text{FALSE}\)</span>这两个函数的功能用一个词来概括就是“<strong>选择</strong>”，在数字电路中，也有一个可以做选择的模块：<strong>选择器</strong>。选择器有三个输入端口<span
class="math inline">\(a\)</span>，<span
class="math inline">\(b\)</span>和<span
class="math inline">\(sel\)</span>，一个输出端口<span
class="math inline">\(y\)</span>，根据<span
class="math inline">\(sel\)</span>的值可以决定<span
class="math inline">\(y\)</span>的值是和<span
class="math inline">\(a\)</span>相同还是和<span
class="math inline">\(b\)</span>相同（比如当<span
class="math inline">\(sel = \text{TRUE}\)</span>时，<span
class="math inline">\(y=a\)</span>；<span class="math inline">\(sel =
\text{FALSE}\)</span>时，<span class="math inline">\(y =
b\)</span>），类似的，可以构建函数：</p>
<p><span class="math display">\[\text{MUX} = \lambda a.\lambda b.\lambda
sel.sel\ a\ b\]</span></p>
<p>这个函数看起来有些奇怪，似乎只是把三个参数排列在一起输出了，并不能看出其中的“选择功能”，但是<span
class="math inline">\(\lambda\)</span>表达式的特别之处就在于输入的参数可以是函数，从而可以进一步作用在后面的参数上。下面来验证一下的功能：</p>
<p><span class="math display">\[
\begin{align*}
\text{MUX}(a)(b)(\text{TRUE}) &amp;= \text{TRUE}(a)(b) = a \\
\text{MUX}(a)(b)(\text{FALSE}) &amp;= \text{FALSE}(a)(b) = b \\
\end{align*}
\]</span></p>
<p><span
class="math inline">\(\text{MUX}\)</span>函数的工作行为与选择器完全一致！放在硬件中，<span
class="math inline">\(\text{MUX}\)</span>函数是选择器，而在软件中，它就是<code>if</code>语句：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (sel) &#123;<br>  a<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  b<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="三更进一步">三、更进一步</h2>
<p>有了<span
class="math inline">\(\text{MUX}\)</span>函数，就可以实现宏定义的“条件编译”了，只需要改变一下它0的输入参数即可：</p>
<p><span class="math display">\[
\text{MUX}(code\_block, , \text{isdef}(macro))
\]</span></p>
<p>其中<code>isdef</code>是在上一篇定义的宏函数，如果<span
class="math inline">\(macro\)</span>已经被定义了，它将返回<span
class="math inline">\(\text{TRUE}\)</span>，反之返回<span
class="math inline">\(\text{FALSE}\)</span>。<span
class="math inline">\(code_block\)</span>是在宏<span
class="math inline">\(macro\)</span>被定义后希望在预处理时被保留下来的代码块。传给<span
class="math inline">\(\text{MUX}\)</span>函数的第二个参数是一个空串，也就是说在<span
class="math inline">\(macro\)</span>未被定义时，预处理后会留下一个空串，对于最后的预处理结果没有任何影响。</p>
<p>通过上面的抽象定义，已经实现了预期的功能，但是到C语言中，还面临着一些细节问题。首先，<code>isdef</code>的值是<code>1</code>或<code>0</code>，而不是上面定义的和函数。这就导致C语言预处理器并不会把<code>isdef</code>替换为<code>1</code>或<code>0</code>后再当作一个“函数”来解释。其次，<code>isdef</code>中使用了<code>strcmp</code>函数，这显然不能在函数外面使用，函数的运行结果在运行时才被计算出来。</p>
<p>对于第一个问题，如何将<code>isdef</code>的值解释为一个函数呢？由于<code>1</code>和<code>0</code>在C语言中被解释为整型字面量，所以可以给这个<code>1</code>或者<code>0</code>“加点东西”，然后定义新的宏，这里用到了<code>##</code>运算符：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> concat(a, b) a ## b</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MUX_MID(a, b, p, sel) MUX(a, b, concat(p, sel))</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MUX_OUT(a, b, sel) MUX_MID(a, b, PREFIX_, sel)</span><br></code></pre></td></tr></table></figure>
<p>宏<code>concat</code>将两个参数粘连起来，<code>MUX</code>仍然是上面抽象的函数。假设<code>MUX_OUT</code>的输入参数是<code>(code_block, , isdef(foo)</code>，并且宏<code>foo</code>已经被定义过，先不考虑其他问题，经过宏<code>MUX_MID</code>和<code>concat</code>，最终传入<code>MUX</code>的参数将会变为<code>(code_block, , PREFIX_1)</code>。如果我们继续定义宏函数<code>PREFIX_1</code>和<code>PREFIX_0</code>，就可以解决第一个问题了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TRUE(a, b) a</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FALSE(a, b) b</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PREFIX_1(a, b) TRUE(a, b)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PREFIX_0(a, b) FALSE(a, b)\</span><br></code></pre></td></tr></table></figure>
<p>这里定义的<code>TRUE</code>和<code>FALSE</code>宏函数其实就是上面<span
class="math inline">\(\lambda\)</span>演算中的<span
class="math inline">\(\text{TRUE}\)</span>和<span
class="math inline">\(\text{FALSE}\)</span>！现在，考虑宏<code>MUX</code>怎么定义，我们想要将最后的<code>PREFIX_1</code>或者<code>PREFIX_0</code>作用在<code>a</code>和<code>b</code>上，那么只需要改一下参数的顺序，再加个括号就行了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MUX(a, b, sel) sel(a, b)</span><br></code></pre></td></tr></table></figure>
<p>下面来看第二个问题，宏<code>isdef</code>在预处理阶段不会被替换为<code>1</code>或<code>0</code>，因此，不能通过<code>MUX_OUT(a, b, isdef(macro))</code>来使用这个宏，这样肯定是有问题的。需要一个宏，能在预处理阶段就产生<code>1</code>或<code>0</code>的结果。由于我们是在配置编译时使用，所以对于某个选项，要么它被定义了，要么它没被定义，而被定义的宏我们并不在乎它是什么值，所以可以限制为：“一旦定义，就将它定义为<code>t</code>”（这个限制只在本篇中成立）。</p>
<p>再整理一下，现在需要一个宏，来检测一个“一旦定义，就被一定被定义成<code>t</code>”的宏是否被定义，如果被定义了，预处理时它会被替换成<code>1</code>，否则被替换成<code>0</code>。在这个假设下，被定义了的宏会被替换为<code>t</code>，而没有被定义的宏在预处理阶段会保留为宏名。可以使用刚才的“加点东西”技术，把替换后的<code>t</code>再进一步替换为别的东西：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> choose2nd(a, b, ...) b</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PREFIX_t t,</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> choose2nd_mid(p_macro, a, b) choose2nd(p_macro a, b)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> choose2nd_out(macro, a, b) choose2nd_mid(concat(PREFIX_, macro), a, b)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IFDEF(macro) choose2nd_out(macro, 1, 0)</span><br></code></pre></td></tr></table></figure>
<p>这一系列宏的关键之处在于<code>choose2nd_mid</code>宏定义中<code>p_macro</code>和<code>a</code>之间没有逗号，如果<code>macro</code>被定义成了<code>t</code>，则会被替换为“<code>t,</code>”（<code>t</code>后面有一个逗号分隔），从而成为了第二个参数；当未被定义或者被定义成别的，是第二个参数。</p>
<p>上面的讨论中已经涉及了大部分NEMU框架中所使用的技巧和方法，实现这些宏的思路与<span
class="math inline">\(\lambda\)</span>演算关系密切，这种思路也许就是“函数式编程”。</p>
<h2 id="四参考资料">四、参考资料</h2>
<ul>
<li><p><a
href="https://github.com/NJU-ProjectN/ics-pa">南京大学ics-pa在github上的项目</a></p></li>
<li><p><a
href="https://www.bilibili.com/video/BV1VA411H7Ym?share_source=copy_web"><span
class="math inline">\(\lambda\)</span>演算简介</a></p></li>
</ul>
]]></content>
      <categories>
        <category>NEMU</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>理论计算机科学</tag>
      </tags>
  </entry>
  <entry>
    <title>nju-pa摸鱼记3-NEMU中宏的源码阅读</title>
    <url>/2022/02/05/nju-pa%E6%91%B8%E9%B1%BC%E8%AE%B03-nemu%E4%B8%AD%E5%AE%8F%E7%9A%84%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
    <content><![CDATA[<h2 id="一前言">一、前言</h2>
<p>有关于如何使用宏定义检测某个宏是否存在在前两篇专栏中已经讨论得差不多了，本篇将目光转回NEMU的代码框架，探讨<code>include/macro.h</code>中的有关宏的原理。</p>
<h2 id="二macro.h">二、macro.h</h2>
<p>NEMU代码框架中的<code>include/macro.h</code>文件中定义了一些列宏</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// keep the code if a boolean macro is defined</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IFDEF(macro, ...) MUXDEF(macro, __KEEP, __IGNORE)(__VA_ARGS__)</span><br><span class="hljs-comment">// keep the code if a boolean macro is undefined</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IFNDEF(macro, ...) MUXNDEF(macro, __KEEP, __IGNORE)(__VA_ARGS__)</span><br><span class="hljs-comment">// keep the code if a boolean macro is defined to 1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IFONE(macro, ...) MUXONE(macro, __KEEP, __IGNORE)(__VA_ARGS__)</span><br><span class="hljs-comment">// keep the code if a boolean macro is defined to 0</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IFZERO(macro, ...) MUXZERO(macro, __KEEP, __IGNORE)(__VA_ARGS__)</span><br></code></pre></td></tr></table></figure>
<p>从注释中可以看出，这些宏都是根据布尔宏（即若被定义则只有可能被定义为<code>0</code>或<code>1</code>）是否被定义或者定义为什么值而决定后面变长参数表中的代码在预编译时是否被保留。由于它们的原理是相通的，所以这里只分析宏<code>IFDEF(macro, ...)</code>，并使用自顶向下的方法，从顶层宏定义一直追踪到最深层的定义。</p>
<p>宏<code>IFDEF(macro, ...)</code>的第一个参数是一个布尔宏，第二个参数是变长列表，可以传入语句或代码块。若宏<code>macro</code>被定义则保留代码，反之什么都不保留。在它的顶层定义中使用了宏<code>MUXDEF(macro, a, b)</code>，它是一个广义的选择器，不管<code>a</code>和<code>b</code>的类型是什么。在这里，<code>__KEEP</code>和<code>__IGNORE</code>是两个宏函数，它们的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __IGNORE(...)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __KEEP(...) __VA_ARGS__</span><br></code></pre></td></tr></table></figure>
<p>它们的功能和它们的名字相同，<code>__KEEP</code>将保留所有的输入，而<code>__IGNORE</code>将所有输入舍弃。所以，在这里宏<code>IFDEF</code>使用宏<code>MUXDEF</code>选择<code>__KEEP</code>宏函数或<code>__IGNORE</code>宏函数中的一个，然后再将选出来的宏函数作用到后面的代码上，决定这段代码的去留。</p>
<p>举个例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;macro.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOO 1</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	IFDEF(FOO, <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, World!\n&quot;</span>);)<br>   <span class="hljs-comment">// =&gt; __KEEP(printf(&quot;Hello, World!\n&quot;);)</span><br>   <span class="hljs-comment">// =&gt; printf(&quot;Hello, World!\n&quot;);</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在上面的例子中，因为宏<code>FOO</code>已经被定义了，所以再<code>MUXDEF</code>的作用下，宏函数<code>__KEEP</code>被选择出来作用在<code>printf</code>语句上，最后这个语句被保留了下来。</p>
<p>接下来看宏<code>MUXDEF</code>是怎么实现的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CHOOSE2nd(a, b, ...) b</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MUX_WITH_COMMA(contain_comma, a, b) CHOOSE2nd(contain_comma a, b)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MUX_MACRO_PROPERTY(p, macro, a, b) MUX_WITH_COMMA(concat(p, macro), a, b)</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __P_DEF_0  X,</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __P_DEF_1  X,</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MUXDEF(macro, X, Y) MUX_MACRO_PROPERTY(__P_DEF_, macro, X, Y)</span><br></code></pre></td></tr></table></figure>
<p>宏<code>MUXDEF</code>又调用了宏<code>MUX_MACRO_PROPERTY</code>，它的作用是使用宏<code>concat</code>为宏<code>macro</code>添加一个前缀<code>__P_DEF_</code>，然后将处理过的宏传给宏<code>MUX_WITH_COMMA</code>。上一篇所介绍的技术在这里体现了出来：如果布尔宏被定义了，那么加上前缀后将得到<code>__P_DEF_0</code>或<code>__P_DEF_1</code>，然后再定义这两个宏，通过逗号控制最后传入<code>CHOOSE2nd</code>宏的第二个参数为<code>a</code>，最终选择结果为<code>a</code>；如果宏没有被定义，那么加上前缀后的宏不会再进行解释，那么“<code>contain_comma a</code>”部分将作为传入<code>CHOOSE2nd</code>的第一个参数，最终选择结果为<code>b</code>。</p>
]]></content>
      <categories>
        <category>NEMU</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>nju-pa摸鱼记4-指令的生命周期</title>
    <url>/2022/02/07/nju-pa%E6%91%B8%E9%B1%BC%E8%AE%B04-%E6%8C%87%E4%BB%A4%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<h2 id="一前言">一、前言</h2>
<p>在之前的3篇专栏中，主要探讨了NEMU中一些巧妙的宏定义，以及关于计算模型的思考。从本篇开始，将专注于“模拟器如何模拟真实计算机”这一话题。计算机最基础、最核心的功能是执行指令，因此执行指令也是NEMU模拟器最基本的功能。</p>
<h2 id="二计算机中指令的生命周期">二、计算机中指令的生命周期</h2>
<p>对于精简指令集系统，五级流水线是一种经典的CPU核结构，它将一条指令的处理过程分为5个阶段：</p>
<ul>
<li><p>取指：维护PC寄存器，发起访存请求从内存中取出指令；</p></li>
<li><p>译码：翻译取出的指令，确定指令的操作方法和操作对象；</p></li>
<li><p>执行：通过运算部件（如ALU，乘法器等）对操作对象进行算</p></li>
<li><p>访存：若为访存类指令，则在这个阶段进行访存；</p></li>
<li><p>写回：将指令的运算、访存等结果写回目的寄存器。</p></li>
</ul>
<p>这五个阶段轮流往复地运行，计算机便能自动地运行下去。</p>
<h2 id="三nemu中指令的生命周期">三、NEMU中指令的生命周期</h2>
<p>在真实的CPU中，为了提升效率，在取指完成后PC跳转到紧接着当前指令的下一条指令继续取指，如果遇到跳转指令，可以冲刷流水线或者使用分支预测等技术增大取指的正确率。而在模拟器中则没有对于性能的要求，完全可以等到指令执行结束再更新PC，然后开始取下一条指令，在NEMU中，指令执行阶段的划分为：</p>
<ul>
<li><p>取指：通过PC值访问“内存”，取出指令；</p></li>
<li><p>译码：分析指令，确定操作方法和操作数；</p></li>
<li><p>执行：通过对应的处理函数对操作数进行处理，同时将结果写回“寄存器”；</p></li>
<li><p>更新PC：根据指令的执行情况更新PC，此PC一定是正确的PC。</p></li>
</ul>
<p>下面是一条语句在NEMU中的执行过程：</p>
<ol type="1">
<li><p>NEMU调用定义在<code>src/cpu/cpu-exec.c</code>中的<code>cpu_exec()</code>函数，该函数将反复进行取指、译码、执行、更新PC这个过程，直到遇到停机、断点或是什么别的情况。</p></li>
<li><p><code>cpu_exec()</code>函数的核心是一个死循环，其中包括了<code>fetch_decode_exec_updatepc()</code>函数，该函数的定义如下：</p></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// src/cpu/cpu-exec.c</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fetch_decode_exec_updatepc</span><span class="hljs-params">(Decode *s)</span> </span>&#123;<br>  fetch_decode(s, cpu.pc);  <span class="hljs-comment">// fetch and decode</span><br>  s-&gt;EHelper(s);            <span class="hljs-comment">// exec</span><br>  cpu.pc = s-&gt;dnpc;         <span class="hljs-comment">// update pc</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>它将取指译码、执行和更新PC解构，分别对应函数中的三条语句。</p>
<ol start="3" type="1">
<li>首先调用<code>fetch_decode()</code>函数，该函数的核心功能可以简化如下：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// src/cpu/cpu-exec.c</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fetch_decode</span><span class="hljs-params">(Decode *s, <span class="hljs-keyword">vaddr_t</span> pc)</span> </span>&#123;<br>  s-&gt;pc = pc;<br>  s-&gt;snpc = pc;<br>  <span class="hljs-keyword">int</span> idx = isa_fetch_decode(s);<br>  s-&gt;dnpc = s-&gt;snpc;<br>  s-&gt;EHelper = g_exec_table[idx];<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在<code>fetch_decode()</code>函数中，通过<code>isa_fetch_decode()</code>函数得到指令所对应的序号，该序号和这条指令对应处理函数在列表中的下标相同，然后为函数指针<code>s-&gt;EHelper</code>赋值为对应的处理函数。</p>
<ol start="4" type="1">
<li>进入<code>isa_fetch_decode()</code>函数，取指和译码进一步被解构，<code>instr_fetch()</code>函数负责与内存交互取指令；<code>table_main()</code>函数是译码函数，将取回的函数和模式串一一比对，若匹配成功则返回该指令对应的序号，若失败则返回一个无效指令序号，这将导致NEMU产生运行异常报给用户。同时在译码时，也将获取该指令的所有操作数，包括立即数和寄存器，它们都将被存在<code>Decode</code>结构中。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// src/isa/risCV64/instr/decode.c</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isa_fetch_decode</span><span class="hljs-params">(Decode *s)</span> </span>&#123;<br>  s-&gt;isa.instr.val = instr_fetch(&amp;s-&gt;snpc, <span class="hljs-number">4</span>);<br>  <span class="hljs-keyword">int</span> idx = table_main(s);<br>  <span class="hljs-keyword">return</span> idx;<br>&#125;<br></code></pre></td></tr></table></figure>
<ol start="5" type="1">
<li>现在返回到<code>fetch_decode_exec_updatepc()</code>函数中，它的第二条语句调用了<code>s-&gt;EHelper()</code>函数执行该指令，这些执行函数被定义在<code>src/isa/$ISA/instr</code>下的若干<code>.h</code>文件中，比如说lui指令的处理函数：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// src/isa/$ISA/instr/compute.h</span><br>def_EHelper(lui) &#123;<br>  rtl_li(s, ddest, id_src1-&gt;imm);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>它是由更加细化的rtl级函数<code>rtl_li</code>所完成的，所有指令的终点都是若干rtl函数，也就是将指令拆解成“微指令”。</p>
<ol start="6" type="1">
<li>执行完<code>s-&gt;EHelper()</code>后，语句</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">cpu.pc = s-&gt;dnpc;         <span class="hljs-comment">// update pc</span><br></code></pre></td></tr></table></figure>
<p>将完成更新PC的过程。</p>
]]></content>
      <categories>
        <category>NEMU</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>rcore ch2 学习笔记</title>
    <url>/2023/10/20/rcore-ch2/</url>
    <content><![CDATA[<h2 id="应用管理器-appmanager">应用管理器 AppManager</h2>
<p>在 ch2 的批处理操作系统中，<code>batch</code>
模块中定义了一个应用管理器 <code>AppManager</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AppManager</span></span> &#123;<br>    num_app: <span class="hljs-built_in">usize</span>,<br>    current_app: <span class="hljs-built_in">usize</span>,<br>    app_start: [<span class="hljs-built_in">usize</span>; MAX_APP_NUM + <span class="hljs-number">1</span>],<br>&#125;<br></code></pre></td></tr></table></figure>
<ol type="1">
<li><code>lazy_static!</code> 宏</li>
</ol>
<p><code>lazy_static!</code> 宏将静态的 <code>AppManager</code> 实例
<code>APP_MANAGER</code> 包裹起来，效果是仅在使用
<code>APP_MANAGER</code> 时，才运行其初始化代码。</p>
<ol start="2" type="1">
<li><p><code>run_next_app()</code> 中的 <code>drop()</code></p>
<ul>
<li>该函数最终调用
<code>__restore()</code>，不会返回，因此，<code>app_manager</code> 的
<code>drop</code> 方法不会被调用。</li>
<li><code>APP_MANAGER</code> 的类型是
<code>UPSafeCell&lt;AppManager&gt;</code>，该类型基于
<code>RefCell&lt;T&gt;</code> 实现：</li>
</ul>
<p><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">UPSafeCell</span></span>&lt;T&gt; &#123;<br><span class="hljs-comment">/// inner data</span><br>inner: RefCell&lt;T&gt;,<br>&#125;<br></code></pre></td></tr></table></figure></p>
<ul>
<li>获取 <code>app_manager</code> 时调用了
<code>APP_MANAGER.exclusive_access()</code>，内部实现为
<code>RefCell&lt;T&gt;</code> 中的 <code>borrow_mut()</code>：</li>
</ul>
<p><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span>&lt;T&gt; UPSafeCell&lt;T&gt; &#123;<br>    ...<br>    <span class="hljs-comment">/// Panic if the data has been borrowed.</span><br>    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">exclusive_access</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; RefMut&lt;<span class="hljs-symbol">&#x27;_</span>, T&gt; &#123;<br>        <span class="hljs-keyword">self</span>.inner.borrow_mut()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<ul>
<li><p>若 <code>app_manager</code>
的在它离开作用域（<code>run_next_app()</code>
函数体）时不被调用，则下次调用
<code>APP_MANAGER.exclusive_access()</code> 时，其内部
<code>RefCell&lt;T&gt;</code> 的可变引用数将大于 1，从而触发
<code>panic!()</code>。</p></li>
<li><p>因此需要手动调用 <code>drop()</code>，将 <code>app_manager</code>
所占有的可变引用计数释放。</p></li>
</ul></li>
<li><p><code>core::mem::drop()</code> 的实现原理</p>
<p><code>core::mem::drop()</code> 实现为：</p>
<p><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[inline]</span><br><span class="hljs-meta">#[stable(feature = <span class="hljs-meta-string">&quot;rust1&quot;</span>, since = <span class="hljs-meta-string">&quot;1.0.0&quot;</span>)]</span><br><span class="hljs-meta">#[cfg_attr(not(test), rustc_diagnostic_item = <span class="hljs-meta-string">&quot;mem_drop&quot;</span>)]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">drop</span></span>&lt;T&gt;(_x: T) &#123;&#125;<br></code></pre></td></tr></table></figure></p>
<p>即一个空函数，将参数变量所有权移入，而后在退出 <code>drop()</code>
函数时调用 <code>_x</code> 的 <code>drop()</code> 方法。</p></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>try latex</title>
    <url>/2022/02/01/try-latex/</url>
    <content><![CDATA[<p><span class="math inline">\(a=\lambda x.x\)</span></p>
<p>Hello!</p>
<p><span class="math display">\[
A = \begin{bmatrix}
        a_{11}    &amp; a_{12}    &amp; ...    &amp; a_{1n}\\
        a_{21}    &amp; a_{22}    &amp; ...    &amp; a_{2n}\\
        a_{31}    &amp; a_{22}    &amp; ...    &amp; a_{3n}\\
        \vdots    &amp; \vdots    &amp; \ddots &amp; \vdots\\
        a_{n1}    &amp; a_{n2}    &amp; ... &amp; a_{nn}\\
    \end{bmatrix} , b = \begin{bmatrix}
        b_{1}  \\
        b_{2}  \\
        b_{3}  \\
        \vdots \\
        b_{n}  \\
    \end{bmatrix}
\]</span></p>
<p><img src="/img/a.png" /></p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu 打开热点共享网络</title>
    <url>/2022/09/05/ubuntu-%E6%89%93%E5%BC%80%E7%83%AD%E7%82%B9%E5%85%B1%E4%BA%AB%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h2 id="问题">问题</h2>
<p>在 ubuntu 的 <code>settings -&gt; Wi-Fi -&gt; ...</code>
中，有一个“Turn on Wi-Fi
hotspot”选项。但遗憾的是，该选项是灰色的，无法直接通过系统自带的设置打开热点。</p>
<h2 id="解决">解决</h2>
<p>在网上搜索后，找到了一种可行的办法，步骤如下：</p>
<ol type="1">
<li><code>Alt + F2</code>，在弹出的输入框中输入
<code>nm-connection-editor</code>；</li>
<li>点击 <code>+</code>，类型选择 Wi-Fi；</li>
<li>随意设置 SSID 和 Connection Name；</li>
<li>Wi-Fi Security 选择
<code>WPA &amp; WPA2 Personal</code>，设置连接密码；</li>
<li>点击 <code>apply</code> 后，Wi-Fi
设置界面已经出现了相应的热点信息；</li>
<li>关闭后再次打开需要在 <code>...</code> 中选择
<code>Connect to Hidden Network</code>，然后选择热点对应的连接即可。</li>
</ol>
]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>软件配置</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>三月三十一日于西北食堂用午餐作诗一首</title>
    <url>/2022/04/01/%E4%B8%89%E6%9C%88%E4%B8%89%E5%8D%81%E4%B8%80%E6%97%A5%E4%BA%8E%E8%A5%BF%E5%8C%97%E9%A3%9F%E5%A0%82%E7%94%A8%E5%8D%88%E9%A4%90%E4%BD%9C%E8%AF%97%E4%B8%80%E9%A6%96/</url>
    <content><![CDATA[<p><img src="/img/0401-1.jpg" /></p>
<blockquote>
<p>三奎肉饭十六元，三两口就全吃完。<br />
西北食堂物价高，以后换个小点盘。</p>
</blockquote>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
  </entry>
  <entry>
    <title>使用 nginx 在服务器上反向代理 Tomcat</title>
    <url>/2022/05/02/%E4%BD%BF%E7%94%A8nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86Tomcat/</url>
    <content><![CDATA[<h2 id="反向代理概述">反向代理概述</h2>
<p>在服务器上使用 nginx
软件并添加相关配置就可以实现反向代理。所谓反向代理，就是通过访问代理服务器（安装并配置了
nginx）的特定端口或域名，将访问请求转发到其他服务器或其他服务上。举例来说，我在服务器上运行了
Tomcat 软件，它打开的是
<code>localhost:8080</code>，现在我想通过服务器的 IP 地址从外网访问
Tomcat 服务（比如：<code>服务器IP:8082</code>），那么这时就可以使用
nginx 进行反向代理。在上面的例子里，nginx
的大致工作过程是：经过配置后，nginx 将开始监听服务器的 <code>8082</code>
端口，当服务器收到来自 <code>8082</code> 端口的访问请求时，nginx
将请求转发到 <code>localhost:8080</code>，返回数据也是同样的过程，相当于
nginx 在中间起到了仲裁的作用。</p>
<h2 id="配置过程">配置过程</h2>
<p>我的服务器上的 nginx 配置文件位于
<code>/usr/local/nginx/conf/nginx.conf</code> 中，在文件的
<code>http&#123; ... &#125;</code> 大括号中加入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs conf">server<br>&#123;<br>    listen 8082;<br>    server_name _;<br><br>    location / &#123;<br>        proxy_pass http://localhost:8080/;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>然后重启 nginx （我这里使用的是 lnmp，也可以使用不同的方法重启
nginx）：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">sudo lnmp nginx restart<br></code></pre></td></tr></table></figure>
<p>现在，在浏览器的地址栏输入
<code>服务器IP:8082</code>，就可以访问运行在服务器上的
Tomcat服务了。</p>
<h2 id="小插曲">小插曲</h2>
<p>实际上在配置完成后我并不能直接访问服务器的 <code>8082</code>
端口，这是因为我使用的阿里云服务器没有对外打开这个端口。需要进入阿里云控制台，在防火墙配置中将该端口打开才能正常访问。</p>
]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>软件配置</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>向一个新的 ARM 平台移植 Xenomai</title>
    <url>/2023/01/11/%E5%90%91%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84ARM%E5%B9%B3%E5%8F%B0%E7%A7%BB%E6%A4%8DXenomai/</url>
    <content><![CDATA[<h2 id="目的">目的</h2>
<p>本文档是 Gilles Chanteperdrix 为 Xenomai
项目撰写的文章<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>的一个延伸，详细介绍了将中断流水线引入
ARM 内核所带来的变化。</p>
<p>本文致力于引导读者了解如何移植 I-pipe 核心到一个新的 ARM
SoC，从而实现一个实时的、双内核的系统。</p>
<h2 id="术语">术语</h2>
<p>如果你正在阅读本文档，那么你将有几乎将 I-pipe 运行在一个基于 ARM
的<em>开发板</em>上。<strong>开发板</strong>的一些例子是：<em>beagleboard</em>，<em>beaglebone</em>，<em>raspberry
pi</em>。</p>
<p>开发板是使用了基于 ARM 的 <em>SoC</em> 构建的。一些
<strong>SoC</strong> 的例子是：Atmel AT91RM9200，Atmel AT91SAM9263，TI
OMAP3530，TI OMAP4430，Freescale IMX53。我们使用 <em>SoC
家族</em>粗略地指定一组
SoC，它们具有许多相似的外设，从而这些外设的驱动程序可以共享。举个例子，对于“AT91”家族，其中包括
SoC AT91RM9200 和 AT91SAM9263 等等。</p>
<p>SoC 的核心则是处理器<em>核</em>，它们实现了 ARM
指令集。处理器<strong>核</strong>的例子有 ARM 926EJ-S，Intel/Marvell
Xscale，Marvell Feroceon，ARM Cortex A8，ARM Cortex A9。</p>
<p>最后，处理器核实现了一种 ARM <em>架构</em>，或者说 ARM
指令集的某个版本。ARM <strong>架构</strong>包括 armv4，armv5，armv6 以及
armv7。</p>
<p>举个例子来说，IGEPv2 <em>开发板</em> 使用了 TI OMAP3530
<em>SoC</em>，属于 OMAP <em>SoC 家族</em>，基于 ARM Cortex A8
处理器<em>核</em>，实现了 armv7 <em>架构</em>。</p>
<div class="note note-warning">
            <p>自 4.14 版本内核开始，I-pipe 已经不再支持 armv4 和 armv5 架构，只有armv6 仍然支持。</p>
          </div>
<h2 id="定位需要移植的-arm-架构代码">定位需要移植的 ARM 架构代码</h2>
<p>在一切开始之前，你应该确定开发板所使用的
SoC，处理器核以及架构，然后定位到对应的 SoC 以及开发板的特定代码上。</p>
<p>为了得到这些信息，你可以使用 Linux 内核源码中存在于各个子目录中的
Kconfig 与 Makefile 文件。Linux 源码通过将目录命名为 arch/arm/mach-X
或者 arch/arm/plat-X 来指定基于 ARM 的 SoC 或者 SoC 家族
X。还有一些代码可能位于 drivers/ 目录中，特别是
drivers/clocksource，drivers/gpio 或者 drivers/irqchip。</p>
<p>一些由 I-pipe
核心所管理的设备（硬件计时器，高精度计数器，中断控制器，GPIO
控制器）也许对于每一个 SoC 都是不同的，因此为了运行
I-pipe，需要进行适配。</p>
<div class="note note-info">
            <p>如果处理器核为 ARM CortexA9，那么事情将会变得稍微简单一点。这是因为其核内集成了中断控制器，硬件计时器和高精度计数器，而这些设备的驱动程序已经被移植到I-pipe 中了。</p>
          </div>
<h2 id="硬件计时器">硬件计时器</h2>
<p>I-pipe 的“客户端”（如协同内核）需要一个可编程的硬件计时器，以
one-shot 模式进行计时。I-pipe 核心中使用 <code>struct ipipe_timer</code>
对其进行抽象。</p>
<p>对于大多数 ARM SoC，硬件计时器的细节对于每一个 SoC 或者 SoC
家族是特定的，因此在每一个 SoC 的基础上都必须要添加
<code>ipipe_timer</code> 描述符。有很多方法都可以在 I-pipe
核心中实现这个计时器描述符。</p>
<h3 id="a9-计时器">A9 计时器</h3>
<p>如果你所使用的 SoC 不是基于 ARM Cortex A9 核的，请跳到<a
href="#非-a9-计时器">下一节</a>。对于搭载了 ARM Cortex A9 核的
SoC，硬件计时器是由处理器核提供的，与 SoC
之间关联不大：带来的好处是计时器这部分代码已经在 I-pipe
核心代码中得到移植，并支持了 <code>struct ipipe_timer</code>
描述符（详见 arch/arm/kernel/smp_twd.c）。需要注意的是，在为你的 SoC
编译内核时，应保证将 ARM Cortex A9 的硬件计时器代码编译进内核中。</p>
<p>为此，你应该确保 <code>smp_twd</code>
计时器已注册，它声明了一个时钟源，并使用了包含 <em>twd-timer</em>
的字符串。</p>
<p>如果 SoC 没有使用 <code>smp_twd</code>
计时器，并且也没有内核配置选项可以选择它，那么你就需要使用<a
href="#非-a9-计时器">下一节</a>的方法注册 per-cpu 计时器。</p>
<div class="note note-info">
            <p>在某些情况下，Cortex A9 计数器的 Linux 支持代码可能会在 I-pipe更新补丁打上后给出不准确的计时器频率校准结果，这种结果将导致计时器中断提前触发。通过提供适当的设备树，驱动器可以自动确定适当的时钟频率，而无需进行任何不精确的校准。</p>
          </div>
<h3 id="非-a9-计时器">非 A9 计时器</h3>
<p>你需要看一看你使用的 SoC 的硬件计时器支持代码。通常情况下，可以在
drivers/clocksource 或 arch/arm/mach-X/time.c 或 arch/arm/plat-Y/time.c
中找到它们。假设你的开发板使用设备树文件，你应该查找包含
<code>-timer</code> 的设备，并尝试在上述位置之一找到相应的文件。</p>
<p>假设硬件计时器是由 <code>clock_event_device</code> 驱动的，并且支持
one-shot 模式（clock_event_device 的 <code>features</code> 域包含
<code>CLOCK_EVT_FEAT_ONESHOT</code>），那么你的工作将会变得简单。否则，你需要找到包含硬件计时器寄存器说明的文档，看看它是什么类型的计时器（递减器或带匹配寄存器的自由运行计数器），以及如何工作在
one-shot 模式下。</p>
<p>最后你需要决定是协同内核与 Linux
是共享同一个硬件计时器还是使用不同的计时器（一些 SoC
拥有好几个可用的硬件计时器）。推荐使用相同的计时器。</p>
<p><code>ipipe_timer</code> 结构在某种程度上继承了
<code>clock_event_device</code>
结构，增加了协同内核通过中断管道（I-pipe）从计时器硬件接收高精度事件所需的一组功能。下列成员被定义在文件
include/linux/ipipe_tickdev.h 中：</p>
<ul>
<li><p><code>int irq</code></p>
<p>这是计时器中断所使用的 IRQ 号。</p></li>
<li><p><code>void (*request)(struct ipipe_timer *timer, int steal)</code></p>
<p>该回调函数将在协同内核开始使用硬件计时器时被 I-pipe
核心唤醒。它需要将硬件计时器设置为 one-shot 模式。当参数
<code>steal</code> 的值为 <code>true</code> 时，意味着协同内核获得了
Linux 内核正在使用的计时器的控制权。</p>
<p>如果硬件计时器的 Linux 支持代码使用了 <code>clock_event_device</code>
结构，支持 one-shot 模式，并且 I-pipe 核心与 Linux
使用同一个计数器，那么这个处理函数可以被移除。在这种情况下，I-pipe
核心将调用对应 <code>clock_event_device</code> 结构中默认的
<code>set_mode</code> 处理函数。</p></li>
<li><p><code>int (*set)(unsigned long ticks, void *timer)</code></p>
<p>在协同内核请求为硬件计时器写入下一个时钟事件时，该处理函数会被调用。它将控制硬件计时器的流逝以
<code>ticks</code> 为一个单位。</p>
<p>举个例子，如果硬件计时器是基于自减器的，那么这个处理函数就应该将自减寄存器设置为
<code>ticks</code> 值。</p>
<p>如果硬件计时器是基于一个自由运行的计数器和一个匹配寄存器，这个处理函数则需要将匹配寄存器设置为当前计数器与
<code>ticks</code> 值之和。</p>
<p>如果函数运行成功，将返回0；否则，如果延时过短，则将返回一个负值（对于自由运行的计数器和匹配寄存器而言，这种情况可以通过以下方法判断：在设置完匹配寄存器后重新读取计数器的值，如果它超过了匹配寄存器的值，则说明延时过短，导致这个函数运行失败）。</p>
<p>同样地，如果硬件计时器的 Linux 支持代码使用了
<code>clock_event_device</code> 结构，支持 one-shot 模式，并且 I-pipe
核心与 Linux
使用同一个计数器，那么这个处理函数可以被移除。在这种情况下，I-pipe
核心将调用对应 <code>clock_event_device</code> 结构中默认的
<code>set_next_event</code> 处理函数。</p></li>
</ul>
<div class="note note-warning">
            <p>必须注意的是，这个处理函数是在协同内核上下文中被调用的，因此它不会调用任何常规的Linux服务，也不会持有任何常规自旋锁。另外，一个独立的处理函数必须被实现（或者如果需要持有自旋锁，则原本的自旋锁需要被转化为<ahref="#I-pipe-自旋锁">I-pipe自旋锁</a>，需要保证被其覆盖的临界区比较短）。</p>
          </div>
<ul>
<li><p><code>void (*ack)(void)</code></p>
<p>这个处理函数在计时器中断时被调用，它应该在硬件计时器级别确认计时器中断。提供这样的函数几乎总是必要的。</p>
<p>如果这个硬件计时器是与 Liunx 共享的，那么这部分代码已经在 Linux
计时器中断中实现了。这些代码应该被修改为当这个计时器不被协同内核控制时，仅确认计时器中断。参考<a
href="#例子">例子</a>以避免重复确认。</p></li>
<li><p><code>void (*release)(struct ipipe_timer *timer)</code></p>
<p>这个处理函数在协同内核释放硬件计时器时被 I-pipe
核心调用。它的作用是将计时器恢复到调用 <code>request</code>
时的状态。举个例子，如果计时器运行在 periodic 模式下，然后
<code>request</code> 将其切换到了 one-shot
模式，那么这个处理函数就会将其切换回 periodic 模式。</p>
<p>同样地，如果硬件计时器的 Linux 支持代码使用了
<code>clock_event_device</code> 结构，支持 one-shot 模式，并且 I-pipe
核心与 Linux
使用同一个计数器，那么这个处理函数可以被移除。在这种情况下，I-pipe
核心将调用对应 <code>clock_event_device</code> 结构中默认的
<code>set_mode</code> 处理函数。</p></li>
<li><p><code>const char *name</code></p>
<p>计时器的名称。</p>
<p>如果 I-pipe 核心与 Linux
使用同一个计数器，那么这个设置可以被移除，这种情况下将使用
<code>clock_event_device</code> 描述符中该计时器所使用的名称。</p></li>
<li><p><code>unsigned int rating</code></p>
<p>计时器的级别。如果支持的多个硬件计时器有不同级别，那么协同内核将使用级别最高的那一个。</p>
<p>如果 I-pipe 核心与 Linux
使用同一个计数器，那么这个设置可以被移除，这种情况下将使用
<code>clock_event_device</code> 描述符中该计时器所使用的级别。</p></li>
<li><p><code>unsigned long freq</code></p>
<p>硬件计时器的频率。通常这个值可以通过时钟框架的
<code>clk_get_rate()</code> 函数获取。</p>
<p>如果 I-pipe 核心与 Linux
使用同一个计数器，那么这个设置可以被移除，这种情况下将使用
<code>clock_event_device</code> 描述符中该计时器所使用的频率。</p></li>
<li><p><code>unsigned int min_delay_ticks</code></p>
<p>以 ticks
计的硬件时钟最小延迟。几乎对于所有基于计数器和匹配寄存器的计时器而言，都有一个阈值，低于该值时将不能编程。当你使用一个过短的值编入这类计时器，其内部的计数器将持续增加，直到溢出后才能与匹配寄存器相匹配，浙江导致整个计时器停止很长一段时间，然后突然重启。</p>
<p>如果这个最小延迟被称作墙时钟延迟而不是硬件滴答数，函数
<code>ipipe_timer_ns2ticks()</code> 可以用来进行转换，前提是
<code>ipipe_timer.freq</code> 已经设置好。</p>
<p>如果 I-pipe 核心与 Linux
使用同一个计数器，那么这个设置可以被移除，这种情况下将使用
<code>clock_event_device</code> 描述符中该计时器所使用的延迟。</p></li>
<li><p><code>const struct cpumask *cpumask</code></p>
<p>一个 CPU 掩码包括了这个计时器将要运行的一组 CPU。在 SMP
系统中，将存在许多 <code>ipipe_timer</code> 结构体，每一个对应 CPU
掩码中的一个成员。</p>
<p>如果 I-pipe 核心与 Linux
使用同一个计数器，那么这个设置可以被移除，这种情况下将使用
<code>clock_event_device</code> 描述符中该计时器所使用的掩码。</p></li>
</ul>
<p>一旦这个结构被声明，有两种方法向 I-pipe 核心注册：</p>
<ul>
<li><p>如果硬件计时器的 Linux 支持代码使用了
<code>clock_event_device</code> 结构，并且 I-pipe 核心与 Linux
使用同一个计数器，那么其成员 <code>ipipe_timer</code>
应该指向此结构，相当于在常规内核调用
<code>clockevents_register_device()</code> 时自动地进行了注册。</p></li>
<li><p>否则，需要手动调用 <code>ipipe_timer_register()</code>
进行注册。</p></li>
</ul>
<h3 id="例子">例子</h3>
<p>作为一个例子，我们看一看 I-pipe 核心中 OMAP3 的代码。在引入 I-pipe
前，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">irqreturn_t</span> <span class="hljs-title">omap2_gp_timer_interrupt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> irq, <span class="hljs-keyword">void</span> *dev_id)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">clock_event_device</span> *<span class="hljs-title">evt</span> =</span> &amp;clockevent_gpt;<br><br>	__omap_dm_timer_write_status(&amp;clkev, OMAP_TIMER_INT_OVERFLOW);<br><br>	evt-&gt;event_handler(evt);<br>	<span class="hljs-keyword">return</span> IRQ_HANDLED;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>对于函数 <code>__omap_dm_timer_write_status()</code>
的调用确认了硬件计时器中断的级别。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">clock_event_device</span> <span class="hljs-title">clockevent_gpt</span> =</span> &#123;<br>	.name           = <span class="hljs-string">&quot;gp timer&quot;</span>,<br>	.features       = CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT,<br>	.shift          = <span class="hljs-number">32</span>,<br>	.set_next_event = omap2_gp_timer_set_next_event,<br>	.set_mode       = omap2_gp_timer_set_mode,<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>上面的代码展示了 Linux 中对于硬件计时器处理 one-shot
模式的支持代码。进一步观察表明
<code>omap2_gp_timer_set_next_event()</code> 没有调用任何 Linux 服务，而
Linux 服务是无法在 out-of-bound
上下文中被调用的。因此，这些代码可以安全地与协同内核共享。通过以下修改来支持
I-pipe 内核：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">omap2_gp_timer_ack</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>	__omap_dm_timer_write_status(&amp;clkev, OMAP_TIMER_INT_OVERFLOW);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">irqreturn_t</span> <span class="hljs-title">omap2_gp_timer_interrupt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> irq, <span class="hljs-keyword">void</span> *dev_id)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">clock_event_device</span> *<span class="hljs-title">evt</span> =</span> &amp;clockevent_gpt;<br><br>	<span class="hljs-keyword">if</span> (!clockevent_ipipe_stolen(evt))<br>		omap2_gp_timer_ack();<br><br>	evt-&gt;event_handler(evt);<br>	<span class="hljs-keyword">return</span> IRQ_HANDLED;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> CONFIG_IPIPE</span><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ipipe_timer</span> <span class="hljs-title">omap_shared_itimer</span> =</span> &#123;<br>	.ack			= omap2_gp_timer_ack,<br>	.min_delay_ticks	= <span class="hljs-number">3</span>,<br>&#125;;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">/* CONFIG_IPIPE */</span></span><br><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">clock_event_device</span> <span class="hljs-title">clockevent_gpt</span> =</span> &#123;<br>	.features		= CLOCK_EVT_FEAT_PERIODIC |<br>				  CLOCK_EVT_FEAT_ONESHOT,<br>	.rating			= <span class="hljs-number">300</span>,<br>	.set_next_event		= omap2_gp_timer_set_next_event,<br>	.set_state_shutdown	= omap2_gp_timer_shutdown,<br>	.set_state_periodic	= omap2_gp_timer_set_periodic,<br>	.set_state_oneshot	= omap2_gp_timer_shutdown,<br>	.tick_resume		= omap2_gp_timer_shutdown,<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __init <span class="hljs-title">omap2_gp_clockevent_init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> gptimer_id,</span></span><br><span class="hljs-params"><span class="hljs-function">						<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fck_source)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">/* ... */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> CONFIG_IPIPE</span><br>	<span class="hljs-comment">/* ... */</span><br>		omap_shared_itimer.irq = clkev.irq;<br>		clockevent_gpt.ipipe_timer = &amp;omap_shared_itimer;<br>	<span class="hljs-comment">/* ... */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">/* CONFIG_IPIPE */</span></span><br><br>	clockevents_register_device(&amp;clockevent_gpt);<br><br>	<span class="hljs-comment">/* ... */</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="高精度计数器">高精度计数器</h2>
<p>由于协同内核的计时器管理基于一个运行在 one-shot
模式的计时器，为了应用能够测量较短的时间间隔，需要使用一个高精度计数器。</p>
<p>同样地，计数器的使用也与 SoC 有很大的关联。为了纪念第一个在 x86
处理器上使用 I-pipe 技术运行的 Xenomai 协同内核，这个高精度计数器被称为
tsc（timestamp counter 的简写）。</p>
<p>对于计时器管理，一个名为 <code>__ipipe_tscinfo</code>
的结构体需要被注册到 I-pipe 内核。你需要保证编译选项
"CONFIG_IPIPE_ARM_KUSER_TSC" 被开启。举个例子，在
arch/arm/mach-socfpga/Kconfig 中，你将看到：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp">menuconfig ARCH_SOCFPGA<br>	<span class="hljs-built_in">bool</span> <span class="hljs-string">&quot;Altera SOCFPGA family&quot;</span><br>	depends <span class="hljs-keyword">on</span> ARCH_MULTI_V7<br>	...<br>	<span class="hljs-keyword">select</span> IPIPE_ARM_KUSER_TSC <span class="hljs-keyword">if</span> IPIPE<br></code></pre></td></tr></table></figure>
<h3 id="a9-计数器">A9 计数器</h3>
<p>如果你使用的 SoC 不是基于 ARM Cortex A9 核的，跳转到<a
href="#非-a9-计数器">下一节</a>。对于基于 ARM Cortex A9 核的
SoC，硬件使用的高精度计数器是由处理器核提供的（或者说“全局计时器”）。因为这个硬件是
SoC 无关的，为了支持 I-pipe 而已经存在的
<code>__ipipe_tscinfo</code>（arch/arm/kernel/smp_twd.c）可复用。</p>
<h3 id="非-a9-计数器">非 A9 计数器</h3>
<p>定义在 arch/arm/include/asm/ipipe.h 的 <code>__ipipe_tscinfo</code>
结构体拥有如下成员：</p>
<ul>
<li><p><code>unsigned int type</code></p>
<p>计数器的类型，可能的取值为：</p>
<ul>
<li><code>IPIPE_TSC_TYPE_FREERUNNING</code></li>
</ul>
<p>该 tsc 基于自由运行的计数器</p>
<ul>
<li><code>IPIPE_TSC_TYPE_DECREMENTER</code></li>
</ul>
<p>该 tsc 基于自减器</p>
<ul>
<li><code>IPIPE_TSC_TYPE_FREERUNNING_COUNTDOWN</code></li>
</ul>
<p>该 tsc 基于自由运行的计数器，是自减的</p>
<ul>
<li><code>IPIPE_TSC_TYPE_FREERUNNING_TWICE</code></li>
</ul>
<p>该 tsc
基于自由运行的计数器，并且需要读取两次（有是会读出错误值，但两次之中总有一次是正确的）</p>
<p>如果你所使用的硬件不属于上述情况之一，你需要：</p>
<ol type="1">
<li><p>添加一个你的硬件所属于的类型（<code>IPIPE_TSC_TYPE_xxx</code>）</p></li>
<li><p>添加一个读取该计数器并将其扩展到 64
位值的函数（用汇编语言）。参见 arch/arm/kernel/ipipe_tsc_asm.S 与
arch/arm/kernel/ipipe_tsc.c
以获取更多细节。需要注意，汇编函数的实现需要被限制到 96 字节，或者 24 x
32 比特的指令。</p></li>
</ol></li>
<li><p><code>unsigned int freq</code></p>
<p>计数器的频率</p></li>
<li><p><code>unsigned long counter_vaddr</code></p>
<p>计数器的虚拟地址（在内和空间）</p></li>
<li><p><code>unsigned long u.counter_paddr</code></p>
<p>计数器的物理地址</p></li>
<li><p><code>unsigned long u.mask</code></p>
<p>显示计数器有效比特位的掩码。</p>
<p>举个例子，0xffffffff 说明是 32 位计数器，0xffff 表示是 16
位计数器。只有有限的一组值可以表示每种计数器的类型。如果你需要一种不支持的值，arch/arm/kernel/ipipe_tsc.c
和 arch/arm/kernel/ipipe_tsc_asm.S 需要被修改。</p>
<p>一旦类型为 <code>__ipipe_tscinfo</code> 的变量被定义，它可以通过
<code>__ipipe_tsc_register()</code> 函数被注册到 I-pipe 内核。</p></li>
</ul>
<h3 id="例子-1">例子</h3>
<p>作为一个例子，我们可以看到 arch/arm/mach-davinci/time.c 中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> CONFIG_IPIPE</span><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">ipipe_tscinfo</span> <span class="hljs-title">tsc_info</span> =</span> &#123;<br>	.type = IPIPE_TSC_TYPE_FREERUNNING,<br>	.u = &#123;<br>			&#123;<br>				.mask = <span class="hljs-number">0xffffffff</span>,<br>			&#125;,<br>	&#125;,<br>&#125;;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">/* CONFIG_IPIPE */</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> __init <span class="hljs-title">davinci_timer_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> CONFIG_IPIPE</span><br>	tsc_info.freq = davinci_clock_tick_rate;<br>	tsc_info.counter_vaddr = (<span class="hljs-keyword">void</span> *)(timers[TID_CLOCKSOURCE].base +<br>			timers[TID_CLOCKSOURCE].tim_off);<br>	tsc_info.u.counter_paddr = timers[TID_CLOCKSOURCE].pbase +<br>			timers[TID_CLOCKSOURCE].tim_off;<br>	__ipipe_tsc_register(&amp;tsc_info);<br>	<span class="hljs-comment">/* ... */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">/* CONFIG_IPIPE */</span></span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>TODO!()</p>
<h2 id="中断控制器">中断控制器</h2>
<h3 id="ic-handlers">IC handlers</h3>
<h3 id="flow-handlers">flow handlers</h3>
<h3 id="config_multi_irq_handler">CONFIG_MULTI_IRQ_HANDLER</h3>
<h3 id="多处理器系统">多处理器系统</h3>
<h3 id="gpio">GPIO</h3>
<h3 id="实时驱动程序中的-gpio">实时驱动程序中的 GPIO</h3>
<h3 id="gpio-作为中断源">GPIO 作为中断源</h3>
<h2 id="i-pipe-自旋锁">I-pipe 自旋锁</h2>
<div id="footnotes">
<hr>
<div id="footnotelist">
<ol style="list-style:none; padding-left: 0;">
<li id="fn:1">
<span
style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span
style="display: inline-block; vertical-align: top;"><a href="https://xenomai.org/2014/09/porting-xenomai-dual-kernel-to-a-new-arm-soc/">Porting
Xenomai dual kernel to a new ARM
SoC</a></span><a href="#fnref:1" rev="footnote"> ↩︎</a>
</li>
</ol>
</div>
</div>
]]></content>
      <tags>
        <tag>Linux 内核</tag>
      </tags>
  </entry>
  <entry>
    <title>文献阅读: The BSD Packet Filter: A New Architecture for User-level Packet Capture</title>
    <url>/2024/03/05/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB-The-BSD-Packet-Filter-A-New-Architecture-for-User-level-Packet-Capture/</url>
    <content><![CDATA[<h1
id="the-bsd-packet-filter-a-new-architecture-for-user-level-packet-capture">The
BSD Packet Filter: A New Architecture for User-level Packet Capture</h1>
<blockquote>
<p>论文作者：Steven Ray McCanne, Van L Jacobson</p>
<p>发表会议：USENIX'93</p>
<p>发表时间：January 1993</p>
</blockquote>
<h2 id="导览">0 导览</h2>
<p>1992 年的这篇文章首次提出了 BPF，即 “BSD Packet Filter”。最初 Unix
中的数据包过滤器是基于 stack 设计的，在 RISC CPU 中运行效率不高。BPF
基于 register 设计，比原来的设计快了 10 倍，整体性能比相同环境下的 NIT
快 100 倍。</p>
<p>本文主要介绍了 BPF 的设计思路，包括 BPF
的整体架构、理论模型（CFG）、伪语言翻译器、BPF 指令集，并给出了一些 BPF
过滤器的例子，最终通过测试验证了 BPF
的高效性。在文章主要内容的最后，给出了一些 BPF 已有的应用，从侧面说明了
BPF 设计的合理性，是真正能够运用到生产环境中的工具。</p>
<h2 id="introduction">1 Introduction</h2>
<p>BPF 的架构设计特点：</p>
<ul>
<li>register-based：在 RISC CPU 中能够得到更有效的实现，stack-based
面临存储墙问题</li>
<li>non-shared buffer model：得益于更大的地址空间</li>
</ul>
<h2 id="the-network-tap">2 The Network Tap</h2>
<p>BPF 的 2 个主要部件：</p>
<ol type="1">
<li>the network tap：从网络驱动收集包并复制给侦听程序</li>
<li>the packet filter：决定是否接受包，以及复制多少</li>
</ol>
<p><img src="/img/bpf-overview.png" /></p>
<p>当网络数据包到达时：</p>
<ol type="1">
<li>link-level driver <strong>调用 BPF</strong></li>
<li>数据包经过 <strong>user-defined filter</strong></li>
<li>filter 决定哪些包可以被<strong>复制到 buffer</strong></li>
</ol>
<h3 id="packet-filtering">2.1 Packet Filtering</h3>
<p>BPF 相比于 NIT 性能提升的区别是 <strong>BPF 在 filter
之后才进行数据包的拷贝</strong>，而 NIT 是先进行拷贝再进行过滤，因此 NIT
浪费了许多 CPU 周期。</p>
<h3 id="tap-performance-measurements">2.2 Tap Performance
Measurements</h3>
<p>针对 BPF 和 NIT 的 packet-to-buffer 时间进行两组测试：</p>
<ul>
<li><strong>accept all</strong> <img
src="/img/NIT-vs-BPF-accept-all.png" /> BPF 相比 NIT
有更缓慢的增长，y-截距是每个数据包处理的固定开销，BPF：6us，NIT：89us</li>
<li><strong>reject all</strong> <img
src="/img/NIT-vs-BPF-reject-all.png" /> BPF 无增长，NIT
持续增长，最终甚至差了 2 个数量级。</li>
</ul>
<p>上面的测试结果体现了将 filter 和 tap 2
个单独的模块集成到一个单元中带来的巨大性能优势。</p>
<h2 id="the-filter-model">3 The Filter Model</h2>
<blockquote>
<p>Assuming one uses reasonable care inthe design ofthe buffering model,
it will be the dominant cost of packets you accept while <strong>the
packet filter computation will be the dominant cost of packets you
reject</strong>.</p>
</blockquote>
<p>大部分应用拒绝的包数远远大于接受的包数，因此 filter
的性能至关重要。filter 本质上是一个布尔函数，因此有 2 种表示方法：</p>
<ul>
<li>boolean expression tree/CSPF 描述表达式本身，契合于 stack-based
machine（对于一个表达式，我们可以利用栈来递归地进行求值）</li>
<li>CFG（控制流图） 描述表达式的执行流，更契合于 register-based
machine</li>
</ul>
<p><img src="/img/Filter-Function-Representations.png" /></p>
<h3 id="the-cspftree-model">3.1 The CSPF(Tree) Model</h3>
<p>表达式求值实现上的弊端：</p>
<ul>
<li>需要模拟栈：额外的 add/sub
指令来控制栈指针寄存器，以维护一个栈，且频繁的栈访问成为性能瓶颈</li>
<li>通常包含冗余计算：如 <code>a | b</code>，我们无需将 <code>a</code>
和 <code>b</code>
的值都计算出来。这对于网络包过滤是很关键的，因为某些子表达式需要经过多层网络栈才能求值</li>
</ul>
<p>另一方面，CSPF 处理的数据有长度限制。</p>
<p>尽管 CSPF 有诸多限制，但是它提出了很新颖的思路：</p>
<ul>
<li>在内核中加入一个<strong>伪语言翻译器</strong>，以实现过滤器</li>
<li>将过滤的包视为字节数组，从而独立于网络协议</li>
</ul>
<h3 id="the-bpf-model">3.2 The BPF Model</h3>
<p>基于 CFG 的 BPF
的伪机器（也就是虚拟机/翻译器）设计基于以下设计约束：</p>
<ol type="1">
<li>协议无关：将包视为字节数组</li>
<li>通用（指令）</li>
<li>包数据引用最小</li>
<li>通过 C 语言的 <code>switch</code>
语句译码：为了保证译码效率，采用单地址格式编码</li>
<li>抽象机器的寄存器需要在物理寄存器中驻留</li>
</ol>
<p>这些约束导致采用<strong>累加器型</strong>机器是最为合适的。</p>
<h3 id="the-bpf-pseudo-machine">3.3 The BPF Pseudo-Machine</h3>
<h3 id="examples">3.4 Examples</h3>
<h3 id="parsing-packet-headers">3.5 Parsing Packet Headers</h3>
<p>这三节介绍了 BPF 的指令集设计，给出了一些例子，并解释了
<code>4 * ([k] &amp; 0xf)</code> 这一寻址方式的设计意图。</p>
<p>BPF
虚拟机的操作对象包括：一个累加器、一个寄存器、一个存储器、数据包和一个隐式的
PC。</p>
<p>BPF 的指令类型：</p>
<ul>
<li>访存指令在累加器/寄存器和存储器/数据包间移动数据</li>
<li>运算指令将累加器中的值和立即数进行运算</li>
<li>分支指令根据寄存器中的值是否满足条件改变 PC</li>
<li>返回指令返回过滤器的最终判断结果，为 TRUE 则接受数据包</li>
<li>若干杂项指令</li>
</ul>
<h3 id="filter-performance-measurements">3.6 Filter Performance
Measurements</h3>
<p>通过比较 BPF 和 CSPF 过滤器模型的执行指令数，可以发现 BPF
存在显著的性能优势。</p>
<p><img src="/img/BPF-CSPF-Fileter-Performance.png" /></p>
<ul>
<li>Filter 1：BPF 快了 50%</li>
<li>Filter 2：BPF 快了 240%，这主要是由于 CSPF 一次只能处理 16
位的数据，处理一个 32 位数据需要两次运算</li>
<li>Filter 3：更大的性能差距，这是因为 CSPF 中有许多重复运算</li>
</ul>
<h2 id="applications">4 Applications</h2>
<p>BPF 的主要应用：tcpdump、arpwatch 等。</p>
<h2 id="conclusion">5 Conclusion</h2>
<p>BPF
是一个高效的、可伸缩的、可移植的网络监控模型，已经可以运行在大部分的 BSD
发行版上。</p>
]]></content>
      <tags>
        <tag>paper</tag>
      </tags>
  </entry>
  <entry>
    <title>文献阅读: bpftime: userspace eBPF Runtime for Uprobe, Syscall and Kernel-User Interactions</title>
    <url>/2024/03/06/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB-bpftime-userspace-eBPF-Runtime-for-Uprobe-Syscall-and-Kernel-User-Interactions/</url>
    <content><![CDATA[<h1
id="bpftime-userspace-ebpf-runtime-for-uprobe-syscall-and-kernel-user-interactions">bpftime:
userspace eBPF Runtime for Uprobe, Syscall and Kernel-User
Interactions</h1>
<blockquote>
<p>论文作者：Yusheng Zheng, Tong Yu, Yiwei Yang, Yanpeng Hu, Xiaozheng
Lai, Andrew Quinn</p>
<p>发表期刊：arXiv preprint arXiv:2311.07923</p>
<p>发表时间：December 2023</p>
</blockquote>
<h2 id="what">What</h2>
<p>本文提出了 bpftime，一个<em>用户态的 eBPF 运行时环境</em>，用于
uprobe，syscall hook 和内核-用户通信。基于 bpftime 的 uprobe 获得了 10
倍的性能提升。此外，bpftime 还充分考虑了和 eBPF 生态的兼容性，原有的
eBPF 工具链仍然可以在该项目中继续使用，为 eBPF 开发者带来的便利。</p>
<p>bpftime 的特点：</p>
<ul>
<li>High-Performance, general-purpose Userspace eBPF Runtime
compatibility with existing eBPF echosystem：在实现传统 eBPF
用户态功能的基础上实现与现有 eBPF 生态兼容</li>
<li>Programmatic attaching mechanism and Seamless Runtime Injection for
userspace eBPF：ebftime
可以在<em>无需重新编译、无需重新运行</em>的条件下，实现动态插装、注入</li>
<li>Working together with kernel eBPF and Extensible Feature
Set：实现了与 kernel eBPF 协同工作</li>
</ul>
<h2 id="why">Why</h2>
<p>下图为 kernel eBPF 的工作流：</p>
<p><img src="/img/The-Workflow-of-kernel-eBPF-runtime.png" /></p>
<p>传统的 eBPF 面临着性能和安全的双挑战：</p>
<ul>
<li><p>性能上，与 Uprobe 相关的上下文切换开销降低了性能</p>
<p>当使用 eBPF 挂载到 uprobe
事件时，若用户态程序执行到勘测函数，则将陷入内核，运行 eBPF
程序，发生<em>第一次上下文切换</em>。</p>
<p>eBPF
运行完毕后，从内核态返回，发生<em>第二次上下文切换</em>。</p></li>
<li><p>安全上，eBPF 所要求的特权访问增加了攻击面，如 container
escapes、kernel exploits</p>
<p>eBPF 运行需要 root
权限，且它的运行时建立在内核空间，因此增加了攻击面。如果 kernel eBPF
运行时出了问题，那么内核将处于一种危险状态，影响整个系统。</p></li>
</ul>
<p>但 eBPF &amp; uprobe
被广泛应用<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>：</p>
<ul>
<li>用户空间协议追踪：SSL、TLS、HTTP2</li>
<li>内存分配、泄露监控</li>
<li>等等</li>
</ul>
<h2 id="how">How</h2>
<p>下图为 user eBPF
的工作流<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>：</p>
<p><img src="/img/The-Workflow-of-user-eBPF-runtime.png" /></p>
<p>bpftime 的核心机制是将<em>没必要在 kernel space
执行的操作提取出来，放到 user space
执行</em>，从而减少了上下文切换次数。实际上，减少上下文切换次数是操作系统性能优化的一个主要方法。</p>
<p>实现策略包括：</p>
<ul>
<li><em>bpf 系统调用捕获</em>：通过 bpftime-syscall.so 捕获传统 eBPF
程序中 bpf 相关系统调用，将其转换为用户空间操作</li>
<li><em>共享内存</em>：通过共享内存的方式将 eBPF 字节码载入并创建 eBPF
maps，于内核实现交互</li>
<li><em><code>ptrace</code>/<code>LD_PRELOAD</code></em>：实现动态注入，增强了
bpftime 使用的灵活性</li>
<li><em>动态链接</em>：bpftime 本质上实现了 2 个库 bpftime-syscall.so 和
bpftime-agent.so，动态链接技术为 bpftime 的无缝插装提供了可能</li>
<li>“JIT compilation”：即时翻译技术使得 bpftime
运行时可以动态修改进程代码，从而实现 function/syscall hook</li>
</ul>
<p>对于 uprobe
而言，这种机制能够减少上下文切换次数，从而提升性能；而对于 syscall
hook，由于 syscall
本身就需要陷入内核，因此对性能影响不大。这一点在后面的性能测试中也得到了体现。</p>
<h2 id="test">Test</h2>
<h3 id="performance">Performance</h3>
<p>作者运行了 micro-benchmarks 用于性能测试：</p>
<p><img
src="/img/Perfoemance-comparison-of-kernel-and-userspace-probes.png" /></p>
<p>从结果来看，uprobe 性能获得了 10x 的提升，而 syscall hook
的性能反而下降了，但是在可接受范围内。</p>
<p>结论：用户态 uprobe 性能获得了显著的提升，可以作为内核态 uprobe
的替代。</p>
<h3 id="runtime-efficiency">Runtime Efficiency</h3>
<p>这一部分测试了在不同使用场景下 bpftime LLVM JIT 其他用户态 eBPF
运行时、本地代码以及 WASM
的效率，为不同场景下的运行时选择提供了参考。</p>
<p>测试表明，bpftime LLVM JIT
在整数运算和复杂数学操作场景下性能表现优异。</p>
<h3 id="compatibility">Compatibility</h3>
<p>这一部分对 bpftime 进行了兼容性分析，方法为将真实世界采用 bcc 开发的
eBPF 程序运行时更换为 bpftime。</p>
<p>结果表明原有的 eBPF 程序可以将运行时无缝迁移到 bpftime
上，并且功能是等效的。</p>
<div id="footnotes">
<hr>
<div id="footnotelist">
<ol style="list-style:none; padding-left: 0;">
<li id="fn:1">
<span
style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span
style="display: inline-block; vertical-align: top;">https://github.com/plctlab/PLCT-Open-Reports/blob/master/slides/20230929-yunwei-bpftime-userspace-ebpf.pdf</span><a href="#fnref:1" rev="footnote">
↩︎</a>
</li>
<li id="fn:2">
<span
style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span
style="display: inline-block; vertical-align: top;">文章中的图片标题有误，应为“The
Workflow of <em>user</em> eBPF
runtime”</span><a href="#fnref:2" rev="footnote"> ↩︎</a>
</li>
</ol>
</div>
</div>
]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>paper</tag>
      </tags>
  </entry>
  <entry>
    <title>文献阅读专题:系统调用加速</title>
    <url>/2023/11/05/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB%E4%B8%93%E9%A2%98-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8A%A0%E9%80%9F/</url>
    <content><![CDATA[<h1 id="文献阅读专题系统调用加速">文献阅读专题：系统调用加速</h1>
<p>系统调用是用户获取内核服务的一种途径。一般的系统调用过程为：</p>
<ul>
<li>由用户程序使用一条指令触发同步异常</li>
<li>陷入内核，根据系统调用号进行分发</li>
<li>内核运行具体的处理函数</li>
<li>从内核返回</li>
</ul>
<p>系统调用的开销主要包括两个部分：</p>
<ul>
<li>直接开销：包括用户与内核之间的上下文切换，以及系统调用分发的代码</li>
<li>间接开销：地址空间切换造成的缓存污染，包括 cache、TLB 等</li>
</ul>
<p>为了减小系统调用的开销，有以下的思路：</p>
<ul>
<li>将多个系统调用收集起来一同提交给内核，即批处理系统调用
<ul>
<li>Livio Soares 等人的文章 FlexSC: Flexible System Call Scheduling with
Exception-Less System Calls
中，实现了一个内核与用户共享的虚拟页面，用户将所有系统调用请求统一写入该页面，内核收集后进行批处理，而后把处理结果写回该页面</li>
<li>Mohan Rajagopalan 等人的文章 Cassyopia: Compiler Assisted System
Optimization
中提出了一种利用编译器优化将系统调用聚集起来的思路，在编译时减小应用程序中的系统调用次数</li>
</ul></li>
<li>降低用户与内核上下文切换的开销
<ul>
<li>uni-kernel
是一种特别的内核结构，整个内核只运行一个应用程序，因此可以把应用程序直接放在内核态从而消除上下文切换的开销，Hsuan-Chi
Kuo 等人的文章 A Linux in Unikernel Clothing 中，讨论了将通用 Linux
内核通过补丁、配置项修改的方式变化为 uni-kernle 的方法，实现了接近于一般
uni-kernel 的性能</li>
<li>Zhe Zhou 等人的文章 Userspace Bypass: Accelerating Syscall-intensive
Applications
中，实现了用户旁路系统，该系统可以动态地检测当前应用程序的热门系统调用，而后通过二进制翻译的方法将两个频繁发生的系统调用之间的代码安全地移入内核态运行，从而降低了上下文切换次数，达到了与以往系统调用加速方法相近的性能，同时对应用程序实现了二进制兼容</li>
</ul></li>
<li>异步的系统调用
<ul>
<li>Zach Brown 的文章 Asynchronous System Calls 讨论了 Linux
中异步系统调用实现的历史技术路径</li>
</ul></li>
</ul>
<h1
id="userspace-bypass-accelerating-syscall-intensive-applications">Userspace
Bypass: Accelerating Syscall-intensive Applications</h1>
<h2 id="已有的系统调用加速方法">1 已有的系统调用加速方法</h2>
<ul>
<li><p>异步系统调用</p></li>
<li><p>批处理系统调用</p></li>
<li><p>unikernel</p></li>
<li><p>核内沙盒</p></li>
<li><p>内核旁路</p></li>
</ul>
<p>优势：性能佳，但都需要程序员修改应用程序</p>
<h2 id="传统系统调用的开销">2 传统系统调用的开销：</h2>
<ul>
<li><p>直接开销</p>
<p>上下文切换开销：“A no-op system call with KPTI enabled can cost 431
CPU cycles, as measured by Mi et al. on Intel Skylake and seL4” (<a
href="zotero://select/library/items/ISSWZ2LY">Zhou et al., p. 35</a>)
(<a
href="zotero://open-pdf/library/items/V3ILCBMH?page=4">pdf</a>)</p></li>
<li><p>间接开销</p>
<p>缓存污染开销：“Also on our platform, a pwrite syscall can degrade the
IPC of the following userspace instructions from 2.9 to 0.2 (indirect
costs). The IPC slowly goes back to 2.1 after executing 20,000
instructions. Figure 2 shows the trend of IPC by time elapsed.” (<a
href="zotero://select/library/items/ISSWZ2LY">Zhou et al., p. 35</a>)
(<a
href="zotero://open-pdf/library/items/V3ILCBMH?page=4">pdf</a>)</p></li>
</ul>
<h2 id="ub-设计概览">3 UB 设计概览</h2>
<ol type="1">
<li><p>最小化开发者的负担：二进制兼容</p></li>
<li><p>最小化对内核架构的修改</p></li>
<li><p>尽量达到其他方法的性能</p></li>
</ol>
<ul>
<li><p>“Hot syscall identifier.” (<a
href="zotero://select/library/items/ISSWZ2LY">Zhou et al., p. 37</a>)
(<a
href="zotero://open-pdf/library/items/V3ILCBMH?page=6">pdf</a>)</p></li>
<li><p>“BTC translator.” (<a
href="zotero://select/library/items/ISSWZ2LY">Zhou et al., p. 37</a>)
(<a
href="zotero://open-pdf/library/items/V3ILCBMH?page=6">pdf</a>)</p></li>
</ul>
<h2 id="hot-syscall-identifier">4 Hot Syscall Identifier</h2>
<ul>
<li><p>UB 标准</p>
<ul>
<li>Tpath = 1000 instructions</li>
</ul></li>
<li><p>模块实现</p>
<ul>
<li><p>系统调用采样：系统调用密集型每秒 100K 次，采样 10%，每分钟小于
500K 次，不会带来显著开销</p></li>
<li><p>粗糙剖析：对于每秒系统调用小于 50K
次的线程，不进行下一步精细剖析</p></li>
<li><p>精细剖析：每轮监控 15K 次，并维护表格记录</p>
<ul>
<li><p>系统调用的 RIP</p></li>
<li><p>该系统调用接下来 4us（Tpath时间）内产生系统调用的次数</p></li>
</ul>
<p>若大于 900 次，则认为是频繁的</p></li>
</ul></li>
<li><p>实验证明该模块对平台参数不敏感</p></li>
</ul>
<h2 id="btc-runtime-and-translator">5 BTC Runtime and Translator</h2>
<p>思考1：如果存在一种运行时检查机制，保证应用程序的安全性，是否还需要特权级？</p>
<p>思考2：如何对应用程序加以约束（尽量小地影响功能）以保证程序员在编程时就避免危险操作？</p>
<p>思考3：内核架构之间的相互转换关系，能否实现动态转换？是否需要硬件的支持？</p>
<h2 id="实验">6 实验</h2>
<p>性能与其他相当，逊于 eBPF，这是因为 UB 仅优化了上下文切换的开销。</p>
<p>结论：它的好处在与对应用程序的编写没有约束，无需重构</p>
<p>局限：</p>
<ul>
<li><p>安全</p>
<ol type="1">
<li><p>侧信道攻击，因为用户空间代码被提升为了内核代码，可能用于窃取内核内存数据</p></li>
<li><p>BTC translater 可能无法清除未知特权记录的 x86
指令，可通过指定指令白名单，遇到不在名单内的指令就停止提升</p></li>
<li><p>内核竞争导致的 TOCTOU 攻击</p></li>
</ol></li>
<li><p>性能还不够好（相比于其他优化方法）</p></li>
<li><p>异步 IO 不是 UB
优化的目标，如：线程划分，一些线程进行运算密集型任务，另一些进行
IO，可能被阻塞</p></li>
</ul>
<h1 id="a-linux-in-unikernel-clothing">A Linux in Unikernel
Clothing</h1>
<h2 id="披着-unikernel-外衣的-linux">1 披着 unikernel 外衣的 Linux</h2>
<ul>
<li><p>系统调用开销消除</p></li>
<li><p>通过配置进行裁减和定制</p></li>
</ul>
<p>特点：融入了 Linux 软件生态，并且具有 unikernel 的特征</p>
<h2 id="unikernel">2 unikernel</h2>
<p>两类：</p>
<ul>
<li><p>language-based：特定的编程语言运行时</p>
<ul>
<li><p>小镜像</p></li>
<li><p>基于编译的检查和优化</p></li>
<li><p>基于语言的安全性</p></li>
</ul></li>
<li><p>POSIX-like：尝试提供 POSIX 兼容，单地址空间、单特权级</p></li>
</ul>
<p>问题：基于语言的 unikernel 需要重构应用，而类 POSIX 则是在重复实现
Linux（却无法融入 Linux 社区）</p>
<h2 id="lupine-linux-kuo-et-al.-2020-p.-3-pdf">3 “Lupine Linux” (<a
href="zotero://select/library/items/MRLPXXKV">Kuo et al., 2020, p.
3</a>) (<a
href="zotero://open-pdf/library/items/KLMR3M8J?page=3">pdf</a>)</h2>
<ul>
<li><p>specialization</p>
<ul>
<li>Lupine 仅保留了283 个内核配置项，作为基础</li>
</ul></li>
<li><p>system call overhead elimination</p></li>
</ul>
<p>应用程序清单：</p>
<ul>
<li><p>内核配置</p></li>
<li><p>启动脚本</p></li>
</ul>
<h2 id="实现">4 实现</h2>
<ul>
<li><p>config 裁减</p>
<ul>
<li><p>应用程序特定的配置</p>
<ul>
<li><p>可以精确到应用使用了哪些系统调用</p></li>
<li><p>精确到使用哪些内核服务：proc 文件系统、压缩、加密</p></li>
<li><p>无需配置内核的 debug 功能</p></li>
</ul>
<p>unikernel 的最小化哲学，以应用需要为中心</p></li>
<li><p>非必要配置</p>
<ul>
<li><p>unikernel 面向单核场景</p></li>
<li><p>unikernel 面向特定平台</p>
<p>因此可以针对性地对配置项进行缩减</p></li>
</ul></li>
</ul></li>
<li><p>KML patch</p>
<ul>
<li><p>对内核的补丁：将唯一一个程序提升到内核态运行</p></li>
<li><p>对 libc 的补丁，将 syscall 指令替换为 call</p></li>
</ul></li>
</ul>
<h2 id="评估">5 评估</h2>
<p>结论：</p>
<ul>
<li><p>首先，我们确认<strong>内核专业化（定制）</strong>非常重要：与最先进的
VM 相比，Lupine 的映像大小减少了 73%，启动时间加快了 59%，内存占用减少了
28%，吞吐量提高了
33%。然而，我们发现<strong>应用程序级粒度的专业化可能并不重要</strong>：只有
19 个特定于应用程序的选项涵盖了 20 个最流行的应用程序（占所有下载量的
83%），并且我们发现使用通用的应用程序配置最多会降低 4% 的性能。</p></li>
<li><p>其次，我们发现，虽然在相同权限域中运行应用程序在微基准测试中性能提高了
40%，但在宏基准测试中仅提高了 4%，这表明系统调用开销不应成为unikernel
开发人员的主要关注点。</p></li>
<li><p>最后，我们表明 Lupine 避免了类 POSIX unikernels
的主要缺陷，这些缺陷源于不基于
Linux，包括缺乏对未经修改的应用程序的支持以及高度优化的代码的性能。</p></li>
</ul>
<h3 id="配置">配置</h3>
<ul>
<li><p>20 个热门应用占据了 83% 的下载量</p></li>
<li><p>手动测试需要打开哪些配置选项 <code>CONFIG</code></p></li>
</ul>
<h2 id="超越-unikernel">6 超越 unikernel</h2>
<ul>
<li><p>unikernel
的限制：多处理器、特权级等，导致不是所有应用都能运行，往往导致其丧失了通用性</p></li>
<li><p>实验一：后台控制进程对系统调用延迟几乎没有影响</p></li>
<li><p>实验二：资源竞争且有上下文切换</p>
<ul>
<li><p>线程切换：模拟 unikernel 的情景</p></li>
<li><p>进程切换</p></li>
</ul>
<p>进程切换不比线程切换慢！</p></li>
<li><p>实验三：SMP 的影响</p></li>
</ul>
<h2 id="讨论">7 讨论</h2>
<ul>
<li><p>有效性威胁</p>
<ul>
<li><p>构成 Lupine 的最小配置可能不唯一，如 -O2 和 -Os</p></li>
<li><p>如何获得配置清单？</p></li>
<li><p>有些语言的包管理器可以分析依赖，从而得到“配置清单”</p></li>
</ul></li>
<li><p>未达到的一些 unikernel 特点</p>
<ul>
<li><p>无法在 unikernel 监视器上运行</p></li>
<li><p>不可变的基础设施（？）</p></li>
<li><p>缺乏足够的编译时优化</p></li>
</ul></li>
<li><p>未来工作</p>
<ul>
<li>“Future research efforts should focus on making Linux specialization
more effective and accessible.” (<a
href="zotero://select/library/items/MRLPXXKV">Kuo et al., 2020, pp.
-</a>) (<a
href="zotero://open-pdf/library/items/KLMR3M8J?page=13">pdf</a>)</li>
</ul></li>
</ul>
<h1 id="cassyopia-compiler-assisted-system-optimization">Cassyopia:
Compiler Assisted System Optimization</h1>
<h2 id="简介">1 简介</h2>
<p>本质上是通过编译手段将多个系统系统调用合为一个，从而减少开销。</p>
<p>只需要修改编译器，而不需要修改应用程序代码</p>
<h2 id="实现-1">2 实现</h2>
<p>如何发掘这些可以优化的机会？</p>
<ul>
<li><p>系统调用流图，类似于程序流图</p>
<ul>
<li><p>每个结点代表一次系统调用</p></li>
<li><p>相邻的系统调用使用箭头连接</p></li>
<li><p>边的权重表示序列重复的次数</p></li>
</ul></li>
<li><p>目标：找到图中高频率的调用序列，如果不相邻，则尝试通过编译技术重构代码让它们相邻</p></li>
</ul>
<p>实现：在内核中添加了 240
号系统调用与可加载的内核模块，对编译器进行针对性修改以达到将系统调用聚集的目的</p>
<h2 id="测试">3 测试</h2>
<p>测试：</p>
<ul>
<li><p>拷贝程序提升不大，因为受到 IO 速度的限制</p></li>
<li><p>视频软件解码器提升很大（25%左右），因为属于 CPU 密集型</p></li>
</ul>
]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>paper</tag>
      </tags>
  </entry>
  <entry>
    <title>第六届“龙芯杯”大赛参赛总结</title>
    <url>/2022/08/23/%E7%AC%AC%E5%85%AD%E5%B1%8A%E2%80%9C%E9%BE%99%E8%8A%AF%E6%9D%AF%E2%80%9D%E5%A4%A7%E8%B5%9B%E5%8F%82%E8%B5%9B%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<blockquote>
<p>第六届“龙芯杯”大赛已经落下帷幕，我所在的队伍是我们学校唯一的团队赛参赛队，最终获得了三等奖的成绩。</p>
</blockquote>
<h1 id="比赛简介">比赛简介</h1>
<p>“龙芯杯”大赛是全国大学生计算机系统能力大赛（英文简称
NSCSCC）的赛道之一，NSCSCC 总共有 3 个赛道，分别为：</p>
<ul>
<li>操作系统：主要是做系统软件方面的工作</li>
<li>编译系统：构建编译系统并进行编译优化</li>
<li>CPU：设计并实现一个计算机系统，并能够运行系统软件</li>
</ul>
<p>“龙芯杯”则对应 CPU 赛道。“龙芯杯”下又分 3 项赛事，分别为：</p>
<ul>
<li>个人赛：该赛事我校无人参加，具体内容不太清楚；</li>
<li>团队赛：基于 MIPS32I
实现计算机系统，要求通过大赛提供的功能、性能和系统测试。团队赛分为初赛和决赛，能否进入决赛主要看前面
3
项测试得分；决赛排名主要看性能得分、系统完备性（稳定启动操作系统、支持外设）和答辩表现；</li>
<li>LoongArch
挑战赛：第六届“龙芯杯”新增赛事，据说只有成功启动操作系统才能进入决赛。</li>
</ul>
<h1 id="比赛筹备">比赛筹备</h1>
<blockquote>
<p>须知少日拏云志，曾许人间第一流。</p>
</blockquote>
<h2 id="开始契机">开始契机</h2>
<p>我们是从寒假里开始准备比赛的（寒假在二月份，比赛最终提交是当年的八月份），因此实际上有半年左右的准备时间。具体开始的契机是上届参加比赛的学长在寒假里组织了参赛培训。培训结束后，同班的徐同学问我是否有组队意愿，我正好也准备参加比赛，于是我们一拍即合，创建了队伍。</p>
<h2 id="第一个流水线">第一个流水线</h2>
<p>真正开始设计是开学后，当时我们聚在一起商量了一下，决定花一到两周的时间重写上学习体系结构的五级流水线，最后看谁的时序较好。这时候我正好在自学
chisel，于是我先用 chisel 写了一个简单的 <a
href="https://github.com/MiaoHao-oops/naive-chisel-project">LoongArch32
CPU 核</a>练手。写完后，我陷入了抉择：是使用 chisel
进行开发，还是继续使用熟悉的 Verilog？思量过后我决定还是使用 Verilog
更为稳妥，毕竟是团队赛事，翻车了可是 4 个人的心血。于是，我开始使用
Verilog 重写流水线。</p>
<p>我们第一次商量的结果是将五级改为四级，去掉看上去没什么用的写回级，以减轻流水线刷新的惩罚。在我重构的代码中，主要的改动有下：</p>
<ul>
<li>将流水线控制逻辑由“互锁式”改为“无互锁式”（参考了《计算机组成与设计--硬件/软件接口》）</li>
<li>去掉写回级，将流水线缩短为四级</li>
<li>将指令集替换为 MIPS</li>
<li>加入了自行编写的华莱士树乘法器和位移除法器</li>
</ul>
<p>完成了基本功能的调试后，一跑综合，时钟频率竟然能达到惊人的 120
MHz。两周过后，大家似乎都比较忙，只有我将代码完全从头写了一遍，因此也基本确定了由我来进行内核设计和开发的分工。</p>
<h2 id="丰富流水线的功能">丰富流水线的功能</h2>
<p>完成了基本的流水线后，我按照上学期的思路开始增加例外处理和类-SRAM
总线，其他同学则按照分工开始做 Cache 和
TLB。例外处理的实现相对而言比较简单，最让人头疼的是类-SRAM
总线上事务的取消。</p>
<p>在流水线中，经常会遇到重定向请求冲刷流水线，这时取指或访存的事务就需要被取消。取消这些进行中的事务在我看来是一个比较繁琐的过程，原因有三：</p>
<ol type="1">
<li>重定向随时都可能发生，此时事务处理可能处在任何一个阶段；</li>
<li>总线协议无法对一个已经请求握手的协议进行直接取消，只能由流水线取回再丢弃；</li>
<li>类-SRAM 总线需要主方保证返回的数据一定有地方缓存。</li>
</ol>
<p>最终，纠结了几天后，我打算采用一种队列的结构处理访存请求。这主要是因为类-SRAM
总线上返回数据的顺序与发起请求顺序一致，于是便可以借助队列结构简化访存逻辑。而对于事务取消，在队列里对应的访存请求上添加一个
cancel
标记即可，加入标记的请求仍然继续访存，只不过流水线直接将其丢弃。这种“队列化”的访存控制器一直沿用到最终设计的取指部分，访存由于不存在“取消正在执行的事务”这种需求而采用了“流水化”的控制器。</p>
<p>另一方面，由于初赛不需要 TLB，因此另一项重要的工作是将 cache 接入 CPU
核。在之前的课程中，由于时间关系，我们最终并没有将 cache 接入 CPU
的经验，因此调试起来花费了一番功夫。由于核内和访存子系统分别由我和徐同学开发，因此调试时常常需要约个事件一块看波形，谁也没法保证自己负责的部分是完全正确的。</p>
<p>一个学期过的很快，在开始的一个月过后，由于学业压力，我们的开发过程也被迫暂停了，之后的很长一段时间里进展都十分缓慢。</p>
<h2 id="前后端分离">前后端分离</h2>
<p>这一个学期里，流水线最大变化是进行了前后端的分离。所谓前端，指的是流水线中负责取回指令的部分；而后端则是负责执行指令、改变处理器状态的部分。分离前后段的核心是一个指令队列，它的功能如下：</p>
<ul>
<li>暂存前端取回但还无法向后端发射的指令（取指宽度小于发射宽度）</li>
<li>切断从写回级一直反串到取指流水级的控制信号</li>
</ul>
<p>经过前后端分离后，我又进一步修改前端和 i-cache，将取指宽度拓宽为了
16B（4
条指令）。做前后端分离本是为了之后改双发射做准备，但遗憾的是，最终未能尝试双发射结构，决赛提交的是一个单发射流水线。</p>
<h2 id="弄巧成拙的延迟槽">弄巧成拙的延迟槽</h2>
<p>在之前的课程中，老师常说 MIPS
的延迟槽是一个历史包袱，之前说实话我并不理解这句话的含义，直到开始做分支预测器。分支预测器是由另外两位罗同学和肖同学负责的，罗同学先写了一个简单的基于局部历史和两位饱和计数器的预测器，而肖同学则依据调研的论文进行设计。拿到罗同学的预测器，我按照核内的需求修改了接口，但是很快遇到了一个问题。</p>
<p>MIPS
最著名的特征之一便是转移延迟槽，它的设计初衷是在发生分支跳转时能够少刷掉一条指令，从而提升
IPC。但是，对于非同步 RAM
的访存接口和分支预测来说，它却成了一个“包袱”。遇到的问题是：</p>
<ul>
<li>如何保证分支发生时，延迟槽指令一定被取回了？由哪个阶段来保证？</li>
<li>分支预测时，发生分支的指令到底是分支指令？还是延迟槽指令？</li>
</ul>
<p>如何解决这个问题？我陷入了思考。解决这个问题的关键在与如何理解“分支”：从处理器外部看来，分支的发生将原本顺序的取指序地址转移到了另一个位置。在想明白“分支”后，对于
MIPS
而言，发生取指地址转移的位置是延迟槽指令，而非分支指令。于是，自然想到将所有分支在流水线中的发生都延迟到延迟槽指令进行，让延迟槽真正成为延迟槽。这样便解决了上面的两个问题：</p>
<ul>
<li>分支发生由延迟槽指令发起，流水线只需要刷掉后面所有指令即可，无需保证；</li>
<li>分支预测的对象应为延迟槽指令。</li>
</ul>
<p>具体实现方法是：分支指令流过执行级时不会立刻触发分支，而是拨动一个“开关”，告诉下一条延迟槽指令是否需要触发分支；待延迟槽指令到达执行级时再触发分支。</p>
<h2 id="尝试启动-ucore">尝试启动 ucore</h2>
<p>实际上在启动 ucore
前，就已经调试过一个系统软件，也就是大赛初赛要求的系统测试。该系统测试全部使用汇编语言编写，但与功能、性能测试不同的是，需要将
CPU 核集成到一个小型的 SOC 中，操作 UART
控制器这样的外设。由于系统中存在外设，也就不能再通过仿真进行调试，好在
Vivado
工具链中包含一种基于内部逻辑分析单元（ILA）的在线调试工具。它的工作原理是：通过在
SOC 中加入 ILA
单元（综合后占用一些硬件资源）连接到想要抓取的信号上，然后在上板时设定一些触发条件，抓取满足触发条件的时刻附近的波形。上板调试的难度在于真正的硬件具有一定的随机性，不会像仿真那样每次跑出来的结果都一样。而解决的办法也只能是在随机中找规律，按照代码一个函数一个函数地检查，最终定位
CPU 卡住/出错的地方。最后我们发现，大多数错误都与 uncache
访存有关，访存顺序和访存大小都是需要特别注意的。</p>
<p>真正开始尝试启动 ucore
已经是决赛提交前夕。经过我与徐同学的讨论，我们决定跳过 PMON 直接启动
ucore。一方面是因为启动 PMON
需要额外添加若干指令，而我们又没有测试这些指令的代码和环境，从头搭建又要花许多时间，但
ucore 需要添加的指令不多，可以等遇到了再调试；另一方面是因为 ucore
本身体积不大，可以直接烧录到板载的 flash 中，再用一个简易的 bootloader
将其加载到内存中，而无需先启动 PMON 这样稍微复杂一些的 BIOS 兼
bootloader。</p>
<p>由于我们没有搭建 SOC 的经验，因此一开始启动 ucore
时使用的是大赛提供的 soc_up，该 SOC 中支持不少外设，但 ucore 中只有 UART
驱动，因此在接入 CPU 核时我删掉了其他用不到的外设。启动 ucore
主要遇到了两大问题：一是 UART 在读取数据时总是和输入差了 15
个字符；二是进入内核后常陷入例外，多为保留指令和 TLB 例外。</p>
<p>对于第二个问题，经过上板排查后发现是 TLB 例外在 MIPS
规范中的一个空洞。我们的 TLB 延续了体系结构实验中的“并行查找”风格，各
TLB 项之间没有任何优先级；而 ucore
在处理充填的过程中也没有保证同一个虚拟双页对应的 TLB
项唯一，结果运行时一旦遇到同时命中 2
项的虚地址，转换出来的物理地址将会是错误的，于是取指和访存都会受到影响。于是修改了
TLB 充填的函数，便解决了这个问题。</p>
<p>而对于第一个问题，由于当时没有其他的思路，于是我决定从头搭一个
SOC，如果还有问题，只能是软件或 CPU 核的问题。当然从头搭 SOC
不是那么容易的，首先就是在实验课中完全没有过相关的经历和理解，而我则是参看了《计算机系统设计（下册）》后才知道
Vivado 中有一个 Block Design 的功能能够基于 IP 进行 SOC
搭建。在练习使用了几天 Block Design 后，我开始着手进行 SOC
的搭建。在整个 SOC 中，除了 CPU
核之外，必需的外设有：UART、SPI、GPIO（confreg）以及 DDR3。</p>
<p>其中，最为复杂的是 DDR3 控制器，它通过调用 Xilinx IP 核 memory
interface generator
来实现。首先是参数配置的复杂，其次是时钟输入的复杂，最后则是复位信号的复杂。不过还好，我参考了清华大学往届的
<a
href="https://github.com/trivialmips/nontrivial-mips">nontrivial-mips</a>
项目，从中获取了许多启发和设计思路，最终完成了 DDR3 控制器的集成。</p>
<p>结果，使用了新的 SOC 后，UART
问题仍然存在。我觉得更有可能是软件的问题，因为新 SOC 中的 UART
控制器调用的是 Xilinx IP 核 AXI UART
16550，在查阅手册之后我发现寄存器空间与之前不兼容，也许在功能上也有一些细微的差别是我没有注意到的。查手册之余，我在
github
上找到了它的官方驱动程序仓库，于是便照着修改。还是不行。那只能一点一点试了，所有问题集中在
UART 初始化的函数中，我不断改变初始化参数，最后发现只要将 UART
的队列功能关闭，输入即可正常使用（奇怪的是 ucore
最开始的时候默认就是将其关闭的，但是在原来的 SOC
中仍然有这个问题）。</p>
<p>解决了 UART 的问题后，ucore 可以在新的 SOC
上运行了，尽管不是特别稳定。</p>
<h2 id="决赛前的冲刺">决赛前的冲刺</h2>
<p>大赛要求启动系统后能够运行一些软件来展示系统的完备性，我觉得可以把功能测试里的“记忆游戏”移植到
ucore 中运行。一是它的内容比较简单，移植起来难度不是很大；二是它需要操作
4
种板载外设，也可以证明系统的完备性。在与徐同学交流了我的想法后，他决定试试，最后，他花了不到一天的时间就将记忆游戏成功移植到了
ucore 上运行。</p>
<p>决赛的前一天，我进行性能测试计数时发现了一个诡异的异常：第三个测试点在某些情况下显示结果异常。经过一上午紧张的调试，我们发现又是访存的问题！修改了
d-cache
中不到一行的代码，这个问题得到了解决，修改后的版本也成了我们最终决赛的提交版本。</p>
<h1 id="决赛现场">决赛现场</h1>
<p>团队赛的决赛除了可以由大赛组委进行核查的功能、性能、系统测试外，还增加了自定义指令添加和答辩的环节。</p>
<h2 id="自定义指令添加">自定义指令添加</h2>
<p>指令添加最多只允许两名队员参加，于是这个任务便落到了参与核内开发最多的我和徐同学身上。受疫情的影响，决赛全部改为线上进行，我和徐同学提前到教学楼
6 楼找了一个偏僻的教室，这时还没开课，应该也不会有什么人来教学楼。</p>
<p>下午两点，添加指令环节开始，赛题在微信群里公布，还附带了进行仿真的
coe 文件。赛题并不难，我们大致经过不到 30
分钟就通过了仿真。而后上板时，我们发现单色 LED
的亮灭情况似乎和正常的功能测试有所不同，后来阅读了测试代码后才发现是大赛组委为了区分而有意为之，也算是虚惊一场。</p>
<p>答题后的队伍进入了一个指定会议室进行等待，这个环节也不需要提交什么文件，而是由会议中的老师在线进行验收，过程就和实验课差不多。</p>
<h2 id="答辩">答辩</h2>
<p>答辩是整个比赛的最后一个环节，也就是结合事先准备好的 PPT
进行报告，报告后回答一些专家的问题。说起来答辩有一些遗憾，一个是我在回答第一专家的问题是一直没说到点上，多亏了另一位老师比较熟悉我们的代码风格才帮我们解了围；另一个是在画流水线结构图时由于疏忽没画
TLB，被专家发现并做了提醒。</p>
<h1 id="参赛总结">参赛总结</h1>
<blockquote>
<p>悟已往之不谏，知来者之可追。</p>
</blockquote>
<h2 id="收获">收获</h2>
<p>参加“龙芯杯”的收获还是很多的，主要是两点：</p>
<ul>
<li><p>系统能力：经历了从 SOC
到系统软件的全栈式开发、移植和调试，对金算计体系结构的深度和广度都有了更加深入的理解和运用；</p></li>
<li><p>工程能力：从建立文件夹开始管理整个项目，并且使用、熟悉了整个 IC
前端的设计流程，学会运用一些之前从未使用过的工具进行 SOC 设计。</p></li>
</ul>
<h2 id="不足">不足</h2>
<p>“龙芯杯”每年赛题固定的比赛性质势必导致竞争越来越激烈，相比于其他赛道，它更像是一个已知题目的“命题作文”。命题作文想要写好看重的是积累，对于清华大学这样的强校，几乎连年包揽特等奖和一等奖，很大程度上得益于较为完整的基础设施。这里的基础设施包括但不限于：</p>
<ul>
<li>设计流程、设计语言和设计方法</li>
<li>调试工具链</li>
<li>完整的系统软件移植</li>
</ul>
<p>有了这些基础，他们的起步便已经比我们高很多了。反观我校，我们几乎是从零开始（此处并没有苛责学长的意思，我们十分感激对我们提供过帮助的竞赛小组中的各位学长）。说到底，一方面还是人太少，就更加难成体系；一方面是课程安排上接触专业内容太晚，难以形成积淀。其他学校的实力都是每年上升，而我们还在原地踏步，恐怕之后拿奖都难。</p>
<p>受到设计方法直接影响的是分工问题，核内模块之间紧耦合，难以拆散分配到每个人身上，这就导致了人员分工极不平衡，没有发挥出
4 人队伍的全部实力。</p>
<h2 id="反思">反思</h2>
<p>今年过去，我们也成为学弟口中的学长，我们能为他们留下什么？我们的经验是好的经验吗？“龙芯杯”竞赛小组将被引向何方？当这些担子真实地落到肩上，才深感责任之重大。可以肯定的是，走老路是不行的。</p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>计算机体系结构</tag>
      </tags>
  </entry>
  <entry>
    <title>记计算所夏令营经历</title>
    <url>/2022/07/21/%E8%AE%B0%E8%AE%A1%E7%AE%97%E6%89%80%E5%A4%8F%E4%BB%A4%E8%90%A5%E7%BB%8F%E5%8E%86/</url>
    <content><![CDATA[<blockquote>
<p>声明：本文章将不涉及任何具体的面试内容，除了熟知的英文自我介绍环节。</p>
</blockquote>
<h1 id="报名夏令营">报名夏令营</h1>
<p>报名过程其实没什么可说的，注意一下计算所的官网通知，按要求注册填报系统进行填报即可。另外，计算所还会单开一个问卷进行导师填报，因为当时我认定了目标就是微处理器中心，所以联系了实验室的老师后，我只报了第一志愿导师。</p>
<h1 id="夏令营基本情况">夏令营基本情况</h1>
<p>计算所是真正的 ddl
战士，官网上“六月底公布录取结果”的含义基本上就是“七月初”了，所以大可不必着急。公布入营名单后，首先计算所会给每个入营的同学发送一封邮件，说明一些具体内容，以及电子材料的提交说明（这封邮件不出意外地也是卡点发的，我收到时离
ddl
只有两分钟）。除此之外，各实验室也会根据报名情况进行单独的联系（与是否入营无关），主要是通知进行各实验室的考核，期间要保持邮箱和手机的畅通。</p>
<p>夏令营一般就在公布入营名单的下一周开营，夏令营活动基本上是讲座 +
各实验室的招生宣讲，可以根据自己的兴趣选听，时间在 2
天左右。这两天的活动结束后，就进入了各实验室的考核环节，<strong>根据实验室的不同，可能会安排笔试、机试和面试</strong>，一般面试是必不可少的，一些报名人数比较多的实验室通常会安排笔试和机试。</p>
<h1 id="面试过程中的心路历程">面试过程中的心路历程</h1>
<p>因为我只报了第一志愿导师，因此也只收到了微处理器中心的面试通知，而微处理器中心的考核方式只有面试，最后我也成功通过了面试。虽然只有面试，但我十分地紧张，从头一天晚上一直提心吊胆到进入面试的会议。</p>
<p>回想起来上次参加这种“决定人生走向”的面试，还是 3
年前进入国科大之前的“综合评价”面试。那次面试经历给我留下了不小的阴影。它的面试形式是
4 - 5
人一组一起面试，而我记得和我同组的有一位口才非常好的人大附同学，对老师所提出的任何问题，他都能侃侃而谈，而我却是闷不作声，这让我感到十分的自卑。对于我这种从小就十分内向的人来说，面试那十几分钟简直能要了我的命，因此我一度十分反感这种“以口才论英雄”的考核形式。但是出乎意料的是，最后我的综合评价成绩竟然还不错，最后我也通过综合评价的方式走进了国科大的校园。</p>
<p>回到这次面试，虽然在面试的前一天，实验室就已经发通知明确了面试的基本内容（之前我也向学长咨询了一些），但我仍然十分恐惧。恐惧的来源是对自己极度的不自信，我常常会想“要是英文自我介绍的时候卡壳了怎么办？”“要是老师提的问题我答不上来怎么办？”等等。我的脑中常常模拟出一些我处境十分难堪的场景，随之而来的是心跳加速，精神也变得紧张。因为我被安排到下午进行面试，因此我度过了一个十分煎熬的上午。在精神极度紧张的情况下，即使开着空调，我仍然满头大汗，并且没办法坐下来安心地“复习”英文自我介绍：每隔几分钟，我必须要离开座位，到屋子里走一圈，才能回到座位上再待几分钟。</p>
<p>混混噩噩地度过了一上午，终于，面试组秘书在群里 @
了我，通知我进入会议。我已经完全想不起来当时以什么心情进入会议，但是奇怪的是，进入之后我的心情竟然平静了下来。这种感觉就好像紧张的我发生了一次“中断”，然后由另一个我接管了对我的控制。面试过程非常顺利，英文自我介绍没有卡壳，老师的问题我也一一回答，并且提前十多分钟就结束了面试。最后，在所有面试结束后不到半个小时，我收到了面试通过的消息，总算是有了一个结果。</p>
<h1 id="后记">后记</h1>
<p>最离奇的经历无非就是面试过程中的“中断”，那么“另一个我”到底是谁呢？也许是我的深层的意识。这也许与我在学习中一贯采取的“不求甚解”的方法论有关系。</p>
<p>所谓的“不求甚解”，指的是我在学习知识时，尤其是第一次学习新东西时，通常遇到我无法理解的东西，不会花过多的时间和经历“死磕”。这不是矛盾的吗？什么东西都不弄懂，那最后不是什么都没学会？第一次没搞明白的东西，其实在试图理解的这个过程中，大脑已经在不知不觉中加深了印象，只是我自己还不认可。那么，当未来的某个时间点，又遇到它的时候，原来的印象迅速地被调用出来，在完全不同的情景、灵感下，很容易对之前不理解的东西产生新的启发。虽然新的探索可能仍然是失败的，但是它又进一步加深了大脑对知识的印象。久而久之，一般三五次，在不同的启发之下，许多知识便被我不自觉地掌握了。</p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
  </entry>
</search>
