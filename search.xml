<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>My First Article</title>
    <url>/2022/02/02/My-First-Article/</url>
    <content><![CDATA[<h2 id="chapter-1">Chapter 1</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, World!\n&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="chapter-2">Chapter 2</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;Hello, World!\n&quot;</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="chapter-3">Chapter 3</h2>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/usr/bin/bash</span><br>echo &quot;Hello, World!&quot;<br></code></pre></td></tr></table></figure>
<h2 id="chapter-4">Chapter 4</h2>
<figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby"><span class="hljs-meta">#!/usr/bin/ruby</span><br>puts <span class="hljs-string">&quot;Hello, World!&quot;</span><br></code></pre></td></tr></table></figure>
<h2 id="chapter-5">Chapter 5</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello, World!&quot;</span>)<br></code></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/03/09/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very
first post. Check <a href="https://hexo.io/docs/">documentation</a> for
more info. If you get any problems when using Hexo, you can find the
answer in <a
href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or
you can ask me on <a
href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="quick-start">Quick Start</h2>
<h3 id="create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure>
<p>More info: <a
href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure>
<p>More info: <a
href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure>
<p>More info: <a
href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>nju-pa摸鱼记1-宏的妙用</title>
    <url>/2022/01/31/nju-pa%E6%91%B8%E9%B1%BC%E8%AE%B01-%E5%AE%8F%E7%9A%84%E5%A6%99%E7%94%A8/</url>
    <content><![CDATA[<h2 id="一前言">一、前言</h2>
<p>上学期在课内学习了《计算机体系结构》，一直对最后一章老师讲到的硬件模拟器念念不忘，好奇它的工作原理。好巧不巧，某日在我刷github的时候南京大学的<a
href="https://github.com/NJU-ProjectN/ics-pa">ics-pa项目</a>出现在了我的首页推荐中，于是我便打算利用寒假的时间过一下这个项目，并通过<a
href="https://www.bilibili.com/read/cv15072569">B站的专栏</a>（现在同步到我的个人博客上）记录一些新的知识或者是心得体会。</p>
<h2 id="二使用宏配置编译选项">二、使用宏配置编译选项</h2>
<p>在项目代码进行编译前，需要先使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">make menuconfig<br></code></pre></td></tr></table></figure>
<p>对项目进行配置，在勾选了一些选项退出后，<code>menuconfig</code>会根据之前的选项生成一些宏保存到若干文件中，供之后的.c文件或Makefile文件所包含（使用include）。这样，在C语言源文件或makefile脚本中通过对这些宏加以判断，就可以在编译时使用或抛弃某些特定的功能。</p>
<h2 id="三c语言中检测宏是否被定义">三、C语言中检测宏是否被定义</h2>
<h3 id="使用条件编译指令">1、使用条件编译指令</h3>
<p>在C语言源文件中，可以使用条件编译指令</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> FOO</span><br>  ...<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure>
<p>将宏<code>FOO</code>对应功能的代码包围起来，如果在<code>menuconfig</code>中勾选了该宏所对应的选项，则宏<code>FOO</code>会被定义，最终这段代码也会被编译。</p>
<h3 id="使用宏定义">2、使用宏定义</h3>
<p>除了使用条件编译指令，代码框架还提供了另一种方式检测某个宏是否被定义。之所以要使用另一种方式，是因为条件编译指令不能使用在宏定义中，而频繁地使用条件编译指令会使代码的可读性大打折扣。实现这个功能的关键代码包括：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// macro.h</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> _MACRO_H_</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _MACRO_H_</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> str_temp(x) #x</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> str(x) str_temp(x)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> isdef(macro) (strcmp(<span class="hljs-meta-string">&quot;&quot;</span> #macro, <span class="hljs-meta-string">&quot;&quot;</span> str(macro)) != 0)</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure>
<p>其中宏<code>str(x)</code>使用<code>#</code>运算符将<code>x</code>转化为一个字符串。下面举一个例子来说明<code>isdef</code>这个宏是怎么工作的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// main.c</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;macro.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOO 123</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> a = isdef(FOO);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>经过预处理</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">gcc -o main.i -E main.c<br></code></pre></td></tr></table></figure>
<p>main.i中的内容为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// main.i</span><br>...<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> a = (<span class="hljs-built_in">strcmp</span>(<span class="hljs-string">&quot;&quot;</span> <span class="hljs-string">&quot;FOO&quot;</span>, <span class="hljs-string">&quot;&quot;</span> <span class="hljs-string">&quot;123&quot;</span>) != <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>...<br></code></pre></td></tr></table></figure>
<p>可以发现，<code>strcmp</code>函数的第一个参数对应<code>isdef</code>宏定义中的<code>"" #macro</code>，它直接将宏参数的名称转换为了字符串，而第二个参数对应<code>"" str(macro)</code>，它先将<code>FOO</code>替换为<code>123</code>，然后将<code>123</code>转换为字符串。因此当这两个参数不同时，说明宏已经被定义过。</p>
<p>    通过上面的分析可以发现，宏<code>isdef</code>不能检测宏定义的值与宏定义名称相同的宏，比如说</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOO FOO</span><br></code></pre></td></tr></table></figure>
<p>宏<code>FOO</code>在预处理时仍然被替换为<code>FOO</code>，最后将导致错误的结果。</p>
<p>四、参考资料</p>
<ul>
<li><p><a
href="https://stackoverflow.com/questions/26099745/test-if-preprocessor-symbol-is-defined-inside-macro">stackoverflow上关于如何判断宏是否被定义的讨论</a></p></li>
<li><p><a
href="https://github.com/NJU-ProjectN/ics-pa">南京大学ics-pa项目</a></p></li>
</ul>
]]></content>
      <categories>
        <category>NEMU</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>nju-pa摸鱼记3-NEMU中宏的源码阅读</title>
    <url>/2022/02/05/nju-pa%E6%91%B8%E9%B1%BC%E8%AE%B03-nemu%E4%B8%AD%E5%AE%8F%E7%9A%84%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
    <content><![CDATA[<h2 id="一前言">一、前言</h2>
<p>有关于如何使用宏定义检测某个宏是否存在在前两篇专栏中已经讨论得差不多了，本篇将目光转回NEMU的代码框架，探讨<code>include/macro.h</code>中的有关宏的原理。</p>
<h2 id="二macro.h">二、macro.h</h2>
<p>NEMU代码框架中的<code>include/macro.h</code>文件中定义了一些列宏</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// keep the code if a boolean macro is defined</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IFDEF(macro, ...) MUXDEF(macro, __KEEP, __IGNORE)(__VA_ARGS__)</span><br><span class="hljs-comment">// keep the code if a boolean macro is undefined</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IFNDEF(macro, ...) MUXNDEF(macro, __KEEP, __IGNORE)(__VA_ARGS__)</span><br><span class="hljs-comment">// keep the code if a boolean macro is defined to 1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IFONE(macro, ...) MUXONE(macro, __KEEP, __IGNORE)(__VA_ARGS__)</span><br><span class="hljs-comment">// keep the code if a boolean macro is defined to 0</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IFZERO(macro, ...) MUXZERO(macro, __KEEP, __IGNORE)(__VA_ARGS__)</span><br></code></pre></td></tr></table></figure>
<p>从注释中可以看出，这些宏都是根据布尔宏（即若被定义则只有可能被定义为<code>0</code>或<code>1</code>）是否被定义或者定义为什么值而决定后面变长参数表中的代码在预编译时是否被保留。由于它们的原理是相通的，所以这里只分析宏<code>IFDEF(macro, ...)</code>，并使用自顶向下的方法，从顶层宏定义一直追踪到最深层的定义。</p>
<p>宏<code>IFDEF(macro, ...)</code>的第一个参数是一个布尔宏，第二个参数是变长列表，可以传入语句或代码块。若宏<code>macro</code>被定义则保留代码，反之什么都不保留。在它的顶层定义中使用了宏<code>MUXDEF(macro, a, b)</code>，它是一个广义的选择器，不管<code>a</code>和<code>b</code>的类型是什么。在这里，<code>__KEEP</code>和<code>__IGNORE</code>是两个宏函数，它们的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __IGNORE(...)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __KEEP(...) __VA_ARGS__</span><br></code></pre></td></tr></table></figure>
<p>它们的功能和它们的名字相同，<code>__KEEP</code>将保留所有的输入，而<code>__IGNORE</code>将所有输入舍弃。所以，在这里宏<code>IFDEF</code>使用宏<code>MUXDEF</code>选择<code>__KEEP</code>宏函数或<code>__IGNORE</code>宏函数中的一个，然后再将选出来的宏函数作用到后面的代码上，决定这段代码的去留。</p>
<p>举个例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;macro.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOO 1</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	IFDEF(FOO, <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, World!\n&quot;</span>);)<br>   <span class="hljs-comment">// =&gt; __KEEP(printf(&quot;Hello, World!\n&quot;);)</span><br>   <span class="hljs-comment">// =&gt; printf(&quot;Hello, World!\n&quot;);</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在上面的例子中，因为宏<code>FOO</code>已经被定义了，所以再<code>MUXDEF</code>的作用下，宏函数<code>__KEEP</code>被选择出来作用在<code>printf</code>语句上，最后这个语句被保留了下来。</p>
<p>接下来看宏<code>MUXDEF</code>是怎么实现的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CHOOSE2nd(a, b, ...) b</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MUX_WITH_COMMA(contain_comma, a, b) CHOOSE2nd(contain_comma a, b)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MUX_MACRO_PROPERTY(p, macro, a, b) MUX_WITH_COMMA(concat(p, macro), a, b)</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __P_DEF_0  X,</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __P_DEF_1  X,</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MUXDEF(macro, X, Y) MUX_MACRO_PROPERTY(__P_DEF_, macro, X, Y)</span><br></code></pre></td></tr></table></figure>
<p>宏<code>MUXDEF</code>又调用了宏<code>MUX_MACRO_PROPERTY</code>，它的作用是使用宏<code>concat</code>为宏<code>macro</code>添加一个前缀<code>__P_DEF_</code>，然后将处理过的宏传给宏<code>MUX_WITH_COMMA</code>。上一篇所介绍的技术在这里体现了出来：如果布尔宏被定义了，那么加上前缀后将得到<code>__P_DEF_0</code>或<code>__P_DEF_1</code>，然后再定义这两个宏，通过逗号控制最后传入<code>CHOOSE2nd</code>宏的第二个参数为<code>a</code>，最终选择结果为<code>a</code>；如果宏没有被定义，那么加上前缀后的宏不会再进行解释，那么“<code>contain_comma a</code>”部分将作为传入<code>CHOOSE2nd</code>的第一个参数，最终选择结果为<code>b</code>。</p>
]]></content>
      <categories>
        <category>NEMU</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>nju-pa摸鱼记2-计算机与λ演算</title>
    <url>/2022/02/01/nju-pa%E6%91%B8%E9%B1%BC%E8%AE%B02-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8E%CE%BB%E6%BC%94%E7%AE%97/</url>
    <content><![CDATA[<h2 id="一前言">一、前言</h2>
<p>在<a
href="https://miaohao-oops.github.io/2022/01/31/nju-pa%E6%91%B8%E9%B1%BC%E8%AE%B01-%E5%AE%8F%E7%9A%84%E5%A6%99%E7%94%A8/">上一篇</a>中，讨论了如何使用预处理指令或是宏来识别某个宏是否被定义，以实现通过配置进行有选择的编译。不过，仅使用上一篇讨论的<code>isdef</code>宏还不能达到和预处理指令一样的效果，本篇将继续讨论框架中如何使用宏来实现“<strong>如果某个宏被定义，则预处理后保留某些语句或代码块，反之抛弃这些部分</strong>”的功能。之所以提到<span
class="math inline">\(\lambda\)</span>演算，是由于我在搞明白代码框架中的宏是如何运作之后，发现其颇有“函数式编程”的风格，而<span
class="math inline">\(\lambda\)</span>演算是函数式编程的基础，遂记录于此。</p>
<h2 id="二浅谈lambda演算">二、浅谈<span
class="math inline">\(\lambda\)</span>演算</h2>
<h3 id="简介">1、简介</h3>
<p><span
class="math inline">\(\lambda\)</span>演算是一种和图灵机等价的计算模型（<strong>丘奇-图灵论题</strong>），它可以描述任何可计算问题，又称为“最小的编程语言”。简单来说，<span
class="math inline">\(\lambda\)</span>演算的核心是<strong>抽象化定义的函数</strong>，它的参数没有类型的限制，可以是数字，函数或者字符串等等。一个最基础的函数是恒等函数：</p>
<p><span class="math display">\[\lambda x.x\]</span></p>
<p>其中<span class="math inline">\(\lambda\)</span>后的<span
class="math inline">\(x\)</span>是这个函数的<strong>输入</strong>，点号后的<span
class="math inline">\(x\)</span>是函数的<strong>输出</strong>。可以将这个函数作用在变量<span
class="math inline">\(a\)</span>上，就得到：</p>
<p><span class="math display">\[\lambda x.x(a) = a\]</span></p>
<p>通过<strong>柯里化</strong>方法，可以定义二输入函数：</p>
<p><span class="math display">\[\lambda x.\lambda y.x+y\]</span></p>
<p>其中<span class="math inline">\(x\)</span>和<span
class="math inline">\(y\)</span>是该函数的两个输入，该函数的输出是两个输入的和。</p>
<h3 id="用抽象化函数表示布尔逻辑">2、用抽象化函数表示布尔逻辑</h3>
<p>在<span
class="math inline">\(\lambda\)</span>演算中，没有布尔值的概念，但是可以定义两个函数来表示布尔逻辑：</p>
<p><span class="math display">\[\text{TRUE} = \lambda x.\lambda
y.x\]</span></p>
<p><span class="math display">\[\text{FALSE} = \lambda x.\lambda
y.y\]</span></p>
<p>用自然语言来描述<span
class="math inline">\(\text{TRUE}\)</span>函数的作用：“输入两个参数<span
class="math inline">\(x\)</span>和<span
class="math inline">\(y\)</span>，输出第一个参数”，<span
class="math inline">\(\text{FALSE}\)</span>函数的功能同理。这样的话，可以把布尔值<span
class="math inline">\(1\)</span>和<span
class="math inline">\(0\)</span>分别定义成<span
class="math inline">\(\text{TRUE}\)</span>函数和<span
class="math inline">\(\text{FALSE}\)</span>函数。接下来可以定义最基本的非、与、或运算：</p>
<p><span class="math display">\[
\begin{cases}
\text{NOT} &amp;= \lambda x.x\ \text{FALSE}\ \text{TRUE} \\
\text{AND} &amp;= \lambda x.\lambda y.x\ y\ \text{FALSE} \\
\text{OR} &amp;= \lambda x.\lambda y. x\ \text{TRUE}\ y \\
\end{cases}
\]</span></p>
<p>上面的三个函数都是利用了<span
class="math inline">\(\lambda\)</span>演算中参数可以是函数的性质，输入的<span
class="math inline">\(\text{TRUE}\)</span>或<span
class="math inline">\(\text{FALSE}\)</span>都可以作为函数继续运算，下面以<span
class="math inline">\(\text{AND}\)</span>函数为例进行验证：</p>
<p><span class="math display">\[
\begin{align*}
\text{AND}(\text{FALSE})(\text{FALSE}) &amp;=
\text{FALSE}(\text{FALSE})(\text{FALSE}) \\
&amp;= \text{FALSE}
\end{align*}
\]</span></p>
<p><span class="math display">\[
\begin{align*}
\text{AND}(\text{FALSE})(\text{TRUE}) &amp;=
\text{FALSE}(\text{TRUE})(\text{FALSE}) \\
&amp;= \text{FALSE}
\end{align*}
\]</span></p>
<p><span class="math display">\[
\begin{align*}
\text{AND}(\text{TRUE})(\text{FALSE}) &amp;=
\text{TRUE}(\text{FALSE})(\text{FALSE}) \\
&amp;= \text{FALSE}
\end{align*}
\]</span></p>
<p><span class="math display">\[
\begin{align*}
\text{AND}(\text{TRUE})(\text{TRUE}) &amp;=
\text{TRUE}(\text{TRUE})(\text{FALSE}) \\
&amp;= \text{TRUE}
\end{align*}
\]</span></p>
<p>当且仅当<span class="math inline">\(x\)</span>与<span
class="math inline">\(y\)</span>均为<span
class="math inline">\(\text{TRUE}\)</span>时，<span
class="math inline">\(\text{AND}\)</span>的值为<span
class="math inline">\(\text{TRUE}\)</span>。因此，函数<span
class="math inline">\(\text{AND}\)</span>的定义正确。</p>
<h3 id="lambda演算与计算机的联系">3、<span
class="math inline">\(\lambda\)</span>演算与计算机的联系</h3>
<p><span class="math inline">\(\text{TRUE}\)</span>和<span
class="math inline">\(\text{FALSE}\)</span>这两个函数的功能用一个词来概括就是“<strong>选择</strong>”，在数字电路中，也有一个可以做选择的模块：<strong>选择器</strong>。选择器有三个输入端口<span
class="math inline">\(a\)</span>，<span
class="math inline">\(b\)</span>和<span
class="math inline">\(sel\)</span>，一个输出端口<span
class="math inline">\(y\)</span>，根据<span
class="math inline">\(sel\)</span>的值可以决定<span
class="math inline">\(y\)</span>的值是和<span
class="math inline">\(a\)</span>相同还是和<span
class="math inline">\(b\)</span>相同（比如当<span
class="math inline">\(sel = \text{TRUE}\)</span>时，<span
class="math inline">\(y=a\)</span>；<span class="math inline">\(sel =
\text{FALSE}\)</span>时，<span class="math inline">\(y =
b\)</span>），类似的，可以构建函数：</p>
<p><span class="math display">\[\text{MUX} = \lambda a.\lambda b.\lambda
sel.sel\ a\ b\]</span></p>
<p>这个函数看起来有些奇怪，似乎只是把三个参数排列在一起输出了，并不能看出其中的“选择功能”，但是<span
class="math inline">\(\lambda\)</span>表达式的特别之处就在于输入的参数可以是函数，从而可以进一步作用在后面的参数上。下面来验证一下的功能：</p>
<p><span class="math display">\[
\begin{align*}
\text{MUX}(a)(b)(\text{TRUE}) &amp;= \text{TRUE}(a)(b) = a \\
\text{MUX}(a)(b)(\text{FALSE}) &amp;= \text{FALSE}(a)(b) = b \\
\end{align*}
\]</span></p>
<p><span
class="math inline">\(\text{MUX}\)</span>函数的工作行为与选择器完全一致！放在硬件中，<span
class="math inline">\(\text{MUX}\)</span>函数是选择器，而在软件中，它就是<code>if</code>语句：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (sel) &#123;<br>  a<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  b<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="三更进一步">三、更进一步</h2>
<p>有了<span
class="math inline">\(\text{MUX}\)</span>函数，就可以实现宏定义的“条件编译”了，只需要改变一下它0的输入参数即可：</p>
<p><span class="math display">\[
\text{MUX}(code\_block, , \text{isdef}(macro))
\]</span></p>
<p>其中<code>isdef</code>是在上一篇定义的宏函数，如果<span
class="math inline">\(macro\)</span>已经被定义了，它将返回<span
class="math inline">\(\text{TRUE}\)</span>，反之返回<span
class="math inline">\(\text{FALSE}\)</span>。<span
class="math inline">\(code_block\)</span>是在宏<span
class="math inline">\(macro\)</span>被定义后希望在预处理时被保留下来的代码块。传给<span
class="math inline">\(\text{MUX}\)</span>函数的第二个参数是一个空串，也就是说在<span
class="math inline">\(macro\)</span>未被定义时，预处理后会留下一个空串，对于最后的预处理结果没有任何影响。</p>
<p>通过上面的抽象定义，已经实现了预期的功能，但是到C语言中，还面临着一些细节问题。首先，<code>isdef</code>的值是<code>1</code>或<code>0</code>，而不是上面定义的和函数。这就导致C语言预处理器并不会把<code>isdef</code>替换为<code>1</code>或<code>0</code>后再当作一个“函数”来解释。其次，<code>isdef</code>中使用了<code>strcmp</code>函数，这显然不能在函数外面使用，函数的运行结果在运行时才被计算出来。</p>
<p>对于第一个问题，如何将<code>isdef</code>的值解释为一个函数呢？由于<code>1</code>和<code>0</code>在C语言中被解释为整型字面量，所以可以给这个<code>1</code>或者<code>0</code>“加点东西”，然后定义新的宏，这里用到了<code>##</code>运算符：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> concat(a, b) a ## b</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MUX_MID(a, b, p, sel) MUX(a, b, concat(p, sel))</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MUX_OUT(a, b, sel) MUX_MID(a, b, PREFIX_, sel)</span><br></code></pre></td></tr></table></figure>
<p>宏<code>concat</code>将两个参数粘连起来，<code>MUX</code>仍然是上面抽象的函数。假设<code>MUX_OUT</code>的输入参数是<code>(code_block, , isdef(foo)</code>，并且宏<code>foo</code>已经被定义过，先不考虑其他问题，经过宏<code>MUX_MID</code>和<code>concat</code>，最终传入<code>MUX</code>的参数将会变为<code>(code_block, , PREFIX_1)</code>。如果我们继续定义宏函数<code>PREFIX_1</code>和<code>PREFIX_0</code>，就可以解决第一个问题了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TRUE(a, b) a</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FALSE(a, b) b</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PREFIX_1(a, b) TRUE(a, b)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PREFIX_0(a, b) FALSE(a, b)\</span><br></code></pre></td></tr></table></figure>
<p>这里定义的<code>TRUE</code>和<code>FALSE</code>宏函数其实就是上面<span
class="math inline">\(\lambda\)</span>演算中的<span
class="math inline">\(\text{TRUE}\)</span>和<span
class="math inline">\(\text{FALSE}\)</span>！现在，考虑宏<code>MUX</code>怎么定义，我们想要将最后的<code>PREFIX_1</code>或者<code>PREFIX_0</code>作用在<code>a</code>和<code>b</code>上，那么只需要改一下参数的顺序，再加个括号就行了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MUX(a, b, sel) sel(a, b)</span><br></code></pre></td></tr></table></figure>
<p>下面来看第二个问题，宏<code>isdef</code>在预处理阶段不会被替换为<code>1</code>或<code>0</code>，因此，不能通过<code>MUX_OUT(a, b, isdef(macro))</code>来使用这个宏，这样肯定是有问题的。需要一个宏，能在预处理阶段就产生<code>1</code>或<code>0</code>的结果。由于我们是在配置编译时使用，所以对于某个选项，要么它被定义了，要么它没被定义，而被定义的宏我们并不在乎它是什么值，所以可以限制为：“一旦定义，就将它定义为<code>t</code>”（这个限制只在本篇中成立）。</p>
<p>再整理一下，现在需要一个宏，来检测一个“一旦定义，就被一定被定义成<code>t</code>”的宏是否被定义，如果被定义了，预处理时它会被替换成<code>1</code>，否则被替换成<code>0</code>。在这个假设下，被定义了的宏会被替换为<code>t</code>，而没有被定义的宏在预处理阶段会保留为宏名。可以使用刚才的“加点东西”技术，把替换后的<code>t</code>再进一步替换为别的东西：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> choose2nd(a, b, ...) b</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PREFIX_t t,</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> choose2nd_mid(p_macro, a, b) choose2nd(p_macro a, b)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> choose2nd_out(macro, a, b) choose2nd_mid(concat(PREFIX_, macro), a, b)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IFDEF(macro) choose2nd_out(macro, 1, 0)</span><br></code></pre></td></tr></table></figure>
<p>这一系列宏的关键之处在于<code>choose2nd_mid</code>宏定义中<code>p_macro</code>和<code>a</code>之间没有逗号，如果<code>macro</code>被定义成了<code>t</code>，则会被替换为“<code>t,</code>”（<code>t</code>后面有一个逗号分隔），从而成为了第二个参数；当未被定义或者被定义成别的，是第二个参数。</p>
<p>上面的讨论中已经涉及了大部分NEMU框架中所使用的技巧和方法，实现这些宏的思路与<span
class="math inline">\(\lambda\)</span>演算关系密切，这种思路也许就是“函数式编程”。</p>
<h2 id="四参考资料">四、参考资料</h2>
<ul>
<li><p><a
href="https://github.com/NJU-ProjectN/ics-pa">南京大学ics-pa在github上的项目</a></p></li>
<li><p><a
href="https://www.bilibili.com/video/BV1VA411H7Ym?share_source=copy_web"><span
class="math inline">\(\lambda\)</span>演算简介</a></p></li>
</ul>
]]></content>
      <categories>
        <category>NEMU</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>理论计算机科学</tag>
      </tags>
  </entry>
  <entry>
    <title>nju-pa摸鱼记4-指令的生命周期</title>
    <url>/2022/02/07/nju-pa%E6%91%B8%E9%B1%BC%E8%AE%B04-%E6%8C%87%E4%BB%A4%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<h2 id="一前言">一、前言</h2>
<p>在之前的3篇专栏中，主要探讨了NEMU中一些巧妙的宏定义，以及关于计算模型的思考。从本篇开始，将专注于“模拟器如何模拟真实计算机”这一话题。计算机最基础、最核心的功能是执行指令，因此执行指令也是NEMU模拟器最基本的功能。</p>
<h2 id="二计算机中指令的生命周期">二、计算机中指令的生命周期</h2>
<p>对于精简指令集系统，五级流水线是一种经典的CPU核结构，它将一条指令的处理过程分为5个阶段：</p>
<ul>
<li><p>取指：维护PC寄存器，发起访存请求从内存中取出指令；</p></li>
<li><p>译码：翻译取出的指令，确定指令的操作方法和操作对象；</p></li>
<li><p>执行：通过运算部件（如ALU，乘法器等）对操作对象进行算</p></li>
<li><p>访存：若为访存类指令，则在这个阶段进行访存；</p></li>
<li><p>写回：将指令的运算、访存等结果写回目的寄存器。</p></li>
</ul>
<p>这五个阶段轮流往复地运行，计算机便能自动地运行下去。</p>
<h2 id="三nemu中指令的生命周期">三、NEMU中指令的生命周期</h2>
<p>在真实的CPU中，为了提升效率，在取指完成后PC跳转到紧接着当前指令的下一条指令继续取指，如果遇到跳转指令，可以冲刷流水线或者使用分支预测等技术增大取指的正确率。而在模拟器中则没有对于性能的要求，完全可以等到指令执行结束再更新PC，然后开始取下一条指令，在NEMU中，指令执行阶段的划分为：</p>
<ul>
<li><p>取指：通过PC值访问“内存”，取出指令；</p></li>
<li><p>译码：分析指令，确定操作方法和操作数；</p></li>
<li><p>执行：通过对应的处理函数对操作数进行处理，同时将结果写回“寄存器”；</p></li>
<li><p>更新PC：根据指令的执行情况更新PC，此PC一定是正确的PC。</p></li>
</ul>
<p>下面是一条语句在NEMU中的执行过程：</p>
<ol type="1">
<li><p>NEMU调用定义在<code>src/cpu/cpu-exec.c</code>中的<code>cpu_exec()</code>函数，该函数将反复进行取指、译码、执行、更新PC这个过程，直到遇到停机、断点或是什么别的情况。</p></li>
<li><p><code>cpu_exec()</code>函数的核心是一个死循环，其中包括了<code>fetch_decode_exec_updatepc()</code>函数，该函数的定义如下：</p></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// src/cpu/cpu-exec.c</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fetch_decode_exec_updatepc</span><span class="hljs-params">(Decode *s)</span> </span>&#123;<br>  fetch_decode(s, cpu.pc);  <span class="hljs-comment">// fetch and decode</span><br>  s-&gt;EHelper(s);            <span class="hljs-comment">// exec</span><br>  cpu.pc = s-&gt;dnpc;         <span class="hljs-comment">// update pc</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>它将取指译码、执行和更新PC解构，分别对应函数中的三条语句。</p>
<ol start="3" type="1">
<li>首先调用<code>fetch_decode()</code>函数，该函数的核心功能可以简化如下：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// src/cpu/cpu-exec.c</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fetch_decode</span><span class="hljs-params">(Decode *s, <span class="hljs-keyword">vaddr_t</span> pc)</span> </span>&#123;<br>  s-&gt;pc = pc;<br>  s-&gt;snpc = pc;<br>  <span class="hljs-keyword">int</span> idx = isa_fetch_decode(s);<br>  s-&gt;dnpc = s-&gt;snpc;<br>  s-&gt;EHelper = g_exec_table[idx];<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在<code>fetch_decode()</code>函数中，通过<code>isa_fetch_decode()</code>函数得到指令所对应的序号，该序号和这条指令对应处理函数在列表中的下标相同，然后为函数指针<code>s-&gt;EHelper</code>赋值为对应的处理函数。</p>
<ol start="4" type="1">
<li>进入<code>isa_fetch_decode()</code>函数，取指和译码进一步被解构，<code>instr_fetch()</code>函数负责与内存交互取指令；<code>table_main()</code>函数是译码函数，将取回的函数和模式串一一比对，若匹配成功则返回该指令对应的序号，若失败则返回一个无效指令序号，这将导致NEMU产生运行异常报给用户。同时在译码时，也将获取该指令的所有操作数，包括立即数和寄存器，它们都将被存在<code>Decode</code>结构中。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// src/isa/risCV64/instr/decode.c</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isa_fetch_decode</span><span class="hljs-params">(Decode *s)</span> </span>&#123;<br>  s-&gt;isa.instr.val = instr_fetch(&amp;s-&gt;snpc, <span class="hljs-number">4</span>);<br>  <span class="hljs-keyword">int</span> idx = table_main(s);<br>  <span class="hljs-keyword">return</span> idx;<br>&#125;<br></code></pre></td></tr></table></figure>
<ol start="5" type="1">
<li>现在返回到<code>fetch_decode_exec_updatepc()</code>函数中，它的第二条语句调用了<code>s-&gt;EHelper()</code>函数执行该指令，这些执行函数被定义在<code>src/isa/$ISA/instr</code>下的若干<code>.h</code>文件中，比如说lui指令的处理函数：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// src/isa/$ISA/instr/compute.h</span><br>def_EHelper(lui) &#123;<br>  rtl_li(s, ddest, id_src1-&gt;imm);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>它是由更加细化的rtl级函数<code>rtl_li</code>所完成的，所有指令的终点都是若干rtl函数，也就是将指令拆解成“微指令”。</p>
<ol start="6" type="1">
<li>执行完<code>s-&gt;EHelper()</code>后，语句</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">cpu.pc = s-&gt;dnpc;         <span class="hljs-comment">// update pc</span><br></code></pre></td></tr></table></figure>
<p>将完成更新PC的过程。</p>
]]></content>
      <categories>
        <category>NEMU</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>try latex</title>
    <url>/2022/02/01/try-latex/</url>
    <content><![CDATA[<p><span class="math inline">\(a=\lambda x.x\)</span></p>
<p>Hello!</p>
<p><span class="math display">\[
A = \begin{bmatrix}
        a_{11}    &amp; a_{12}    &amp; ...    &amp; a_{1n}\\
        a_{21}    &amp; a_{22}    &amp; ...    &amp; a_{2n}\\
        a_{31}    &amp; a_{22}    &amp; ...    &amp; a_{3n}\\
        \vdots    &amp; \vdots    &amp; \ddots &amp; \vdots\\
        a_{n1}    &amp; a_{n2}    &amp; ... &amp; a_{nn}\\
    \end{bmatrix} , b = \begin{bmatrix}
        b_{1}  \\
        b_{2}  \\
        b_{3}  \\
        \vdots \\
        b_{n}  \\
    \end{bmatrix}
\]</span></p>
<p><img src="/img/a.png" /></p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
</search>
