<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>My First Article</title>
    <link href="/2022/02/02/My-First-Article/"/>
    <url>/2022/02/02/My-First-Article/</url>
    
    <content type="html"><![CDATA[<h2 id="chapter-1">Chapter 1</h2><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, World!\n&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="chapter-2">Chapter 2</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;Hello, World!\n&quot;</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="chapter-3">Chapter 3</h2><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/usr/bin/bash</span><br>echo &quot;Hello, World!&quot;<br></code></pre></td></tr></table></figure><h2 id="chapter-4">Chapter 4</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-meta">#!/usr/bin/ruby</span><br>puts <span class="hljs-string">&quot;Hello, World!&quot;</span><br></code></pre></td></tr></table></figure><h2 id="chapter-5">Chapter 5</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello, World!&quot;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>try latex</title>
    <link href="/2022/02/01/try-latex/"/>
    <url>/2022/02/01/try-latex/</url>
    
    <content type="html"><![CDATA[<p><span class="math inline">\(a=\lambda x.x\)</span></p><p>Hello!</p><p><span class="math display">\[A = \begin{bmatrix}        a_{11}    &amp; a_{12}    &amp; ...    &amp; a_{1n}\\        a_{21}    &amp; a_{22}    &amp; ...    &amp; a_{2n}\\        a_{31}    &amp; a_{22}    &amp; ...    &amp; a_{3n}\\        \vdots    &amp; \vdots    &amp; \ddots &amp; \vdots\\        a_{n1}    &amp; a_{n2}    &amp; ... &amp; a_{nn}\\    \end{bmatrix} , b = \begin{bmatrix}        b_{1}  \\        b_{2}  \\        b_{3}  \\        \vdots \\        b_{n}  \\    \end{bmatrix}\]</span></p><p><img src="/img/a.png" /></p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LaTeX</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/02/01/hello-world/"/>
    <url>/2022/02/01/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>nju-pa摸鱼记2-计算机与λ演算</title>
    <link href="/2022/02/01/nju-pa%E6%91%B8%E9%B1%BC%E8%AE%B02-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8E%CE%BB%E6%BC%94%E7%AE%97/"/>
    <url>/2022/02/01/nju-pa%E6%91%B8%E9%B1%BC%E8%AE%B02-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8E%CE%BB%E6%BC%94%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h2 id="一前言">一、前言</h2><p>在<a href="https://miaohao-oops.github.io/2022/01/31/nju-pa%E6%91%B8%E9%B1%BC%E8%AE%B01-%E5%AE%8F%E7%9A%84%E5%A6%99%E7%94%A8/">上一篇</a>中，讨论了如何使用预处理指令或是宏来识别某个宏是否被定义，以实现通过配置进行有选择的编译。不过，仅使用上一篇讨论的<code>isdef</code>宏还不能达到和预处理指令一样的效果，本篇将继续讨论框架中如何使用宏来实现“<strong>如果某个宏被定义，则预处理后保留某些语句或代码块，反之抛弃这些部分</strong>”的功能。之所以提到<span class="math inline">\(\lambda\)</span>演算，是由于我在搞明白代码框架中的宏是如何运作之后，发现其颇有“函数式编程”的风格，而<span class="math inline">\(\lambda\)</span>演算是函数式编程的基础，遂记录于此。</p><h2 id="二浅谈lambda演算">二、浅谈<span class="math inline">\(\lambda\)</span>演算</h2><h3 id="简介">1、简介</h3><p><span class="math inline">\(\lambda\)</span>演算是一种和图灵机等价的计算模型（<strong>丘奇-图灵论题</strong>），它可以描述任何可计算问题，又称为“最小的编程语言”。简单来说，<span class="math inline">\(\lambda\)</span>演算的核心是<strong>抽象化定义的函数</strong>，它的参数没有类型的限制，可以是数字，函数或者字符串等等。一个最基础的函数是恒等函数：</p><p><span class="math display">\[\lambda x.x\]</span></p><p>其中<span class="math inline">\(\lambda\)</span>后的<span class="math inline">\(x\)</span>是这个函数的<strong>输入</strong>，点号后的<span class="math inline">\(x\)</span>是函数的<strong>输出</strong>。可以将这个函数作用在变量<span class="math inline">\(a\)</span>上，就得到：</p><p><span class="math display">\[\lambda x.x(a) = a\]</span></p><p>通过<strong>柯里化</strong>方法，可以定义二输入函数：</p><p><span class="math display">\[\lambda x.\lambda y.x+y\]</span></p><p>其中<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>是该函数的两个输入，该函数的输出是两个输入的和。</p><h3 id="用抽象化函数表示布尔逻辑">2、用抽象化函数表示布尔逻辑</h3><p>在<span class="math inline">\(\lambda\)</span>演算中，没有布尔值的概念，但是可以定义两个函数来表示布尔逻辑：</p><p><span class="math display">\[\text{TRUE} = \lambda x.\lambda y.x\]</span></p><p><span class="math display">\[\text{FALSE} = \lambda x.\lambda y.y\]</span></p><p>用自然语言来描述<span class="math inline">\(\text{TRUE}\)</span>函数的作用：“输入两个参数<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>，输出第一个参数”，<span class="math inline">\(\text{FALSE}\)</span>函数的功能同理。这样的话，可以把布尔值<span class="math inline">\(1\)</span>和<span class="math inline">\(0\)</span>分别定义成<span class="math inline">\(\text{TRUE}\)</span>函数和<span class="math inline">\(\text{FALSE}\)</span>函数。接下来可以定义最基本的非、与、或运算：</p><p><span class="math display">\[\begin{cases}\text{NOT} &amp;= \lambda x.x\ \text{FALSE}\ \text{TRUE} \\\text{AND} &amp;= \lambda x.\lambda y.x\ y\ \text{FALSE} \\\text{OR} &amp;= \lambda x.\lambda y. x\ \text{TRUE}\ y \\\end{cases}\]</span></p><p>上面的三个函数都是利用了<span class="math inline">\(\lambda\)</span>演算中参数可以是函数的性质，输入的<span class="math inline">\(\text{TRUE}\)</span>或<span class="math inline">\(\text{FALSE}\)</span>都可以作为函数继续运算，下面以<span class="math inline">\(\text{AND}\)</span>函数为例进行验证：</p><p><span class="math display">\[\begin{align*}\text{AND}(\text{FALSE})(\text{FALSE}) &amp;= \text{FALSE}(\text{FALSE})(\text{FALSE}) \\&amp;= \text{FALSE}\end{align*}\]</span></p><p><span class="math display">\[\begin{align*}\text{AND}(\text{FALSE})(\text{TRUE}) &amp;= \text{FALSE}(\text{TRUE})(\text{FALSE}) \\&amp;= \text{FALSE}\end{align*}\]</span></p><p><span class="math display">\[\begin{align*}\text{AND}(\text{TRUE})(\text{FALSE}) &amp;= \text{TRUE}(\text{FALSE})(\text{FALSE}) \\&amp;= \text{FALSE}\end{align*}\]</span></p><p><span class="math display">\[\begin{align*}\text{AND}(\text{TRUE})(\text{TRUE}) &amp;= \text{TRUE}(\text{TRUE})(\text{FALSE}) \\&amp;= \text{TRUE}\end{align*}\]</span></p><p>当且仅当<span class="math inline">\(x\)</span>与<span class="math inline">\(y\)</span>均为<span class="math inline">\(\text{TRUE}\)</span>时，<span class="math inline">\(\text{AND}\)</span>的值为<span class="math inline">\(\text{TRUE}\)</span>。因此，函数<span class="math inline">\(\text{AND}\)</span>的定义正确。</p><h3 id="lambda演算与计算机的联系">3、<span class="math inline">\(\lambda\)</span>演算与计算机的联系</h3><p><span class="math inline">\(\text{TRUE}\)</span>和<span class="math inline">\(\text{FALSE}\)</span>这两个函数的功能用一个词来概括就是“<strong>选择</strong>”，在数字电路中，也有一个可以做选择的模块：<strong>选择器</strong>。选择器有三个输入端口<span class="math inline">\(a\)</span>，<span class="math inline">\(b\)</span>和<span class="math inline">\(sel\)</span>，一个输出端口<span class="math inline">\(y\)</span>，根据<span class="math inline">\(sel\)</span>的值可以决定<span class="math inline">\(y\)</span>的值是和<span class="math inline">\(a\)</span>相同还是和<span class="math inline">\(b\)</span>相同（比如当<span class="math inline">\(sel = \text{TRUE}\)</span>时，<span class="math inline">\(y=a\)</span>；<span class="math inline">\(sel = \text{FALSE}\)</span>时，<span class="math inline">\(y = b\)</span>），类似的，可以构建函数：</p><p><span class="math display">\[\text{MUX} = \lambda a.\lambda b.\lambda sel.sel\ a\ b\]</span></p><p>这个函数看起来有些奇怪，似乎只是把三个参数排列在一起输出了，并不能看出其中的“选择功能”，但是<span class="math inline">\(\lambda\)</span>表达式的特别之处就在于输入的参数可以是函数，从而可以进一步作用在后面的参数上。下面来验证一下的功能：</p><p><span class="math display">\[\begin{align*}\text{MUX}(a)(b)(\text{TRUE}) &amp;= \text{TRUE}(a)(b) = a \\\text{MUX}(a)(b)(\text{FALSE}) &amp;= \text{FALSE}(a)(b) = b \\\end{align*}\]</span></p><p><span class="math inline">\(\text{MUX}\)</span>函数的工作行为与选择器完全一致！放在硬件中，<span class="math inline">\(\text{MUX}\)</span>函数是选择器，而在软件中，它就是<code>if</code>语句：</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (sel) &#123;<br>  a<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  b<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>NEMU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>理论计算机科学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nju-pa摸鱼记1-宏的妙用</title>
    <link href="/2022/01/31/nju-pa%E6%91%B8%E9%B1%BC%E8%AE%B01-%E5%AE%8F%E7%9A%84%E5%A6%99%E7%94%A8/"/>
    <url>/2022/01/31/nju-pa%E6%91%B8%E9%B1%BC%E8%AE%B01-%E5%AE%8F%E7%9A%84%E5%A6%99%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="一前言">一、前言</h2><p>上学期在课内学习了《计算机体系结构》，一直对最后一章老师讲到的硬件模拟器念念不忘，好奇它的工作原理。好巧不巧，某日在我刷github的时候南京大学的<a href="https://github.com/NJU-ProjectN/ics-pa">ics-pa项目</a>出现在了我的首页推荐中，于是我便打算利用寒假的时间过一下这个项目，并通过<a href="https://www.bilibili.com/read/cv15072569">B站的专栏</a>（现在同步到我的个人博客上）记录一些新的知识或者是心得体会。</p><h2 id="二使用宏配置编译选项">二、使用宏配置编译选项</h2><p>在项目代码进行编译前，需要先使用</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">make menuconfig<br></code></pre></td></tr></table></figure><p>对项目进行配置，在勾选了一些选项退出后，<code>menuconfig</code>会根据之前的选项生成一些宏保存到若干文件中，供之后的.c文件或Makefile文件所包含（使用include）。这样，在C语言源文件或makefile脚本中通过对这些宏加以判断，就可以在编译时使用或抛弃某些特定的功能。</p><h2 id="三c语言中检测宏是否被定义">三、C语言中检测宏是否被定义</h2><h3 id="使用条件编译指令">1、使用条件编译指令</h3><p>在C语言源文件中，可以使用条件编译指令</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> FOO</span><br>  ...<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>将宏<code>FOO</code>对应功能的代码包围起来，如果在<code>menuconfig</code>中勾选了该宏所对应的选项，则宏<code>FOO</code>会被定义，最终这段代码也会被编译。</p><h3 id="使用宏定义">2、使用宏定义</h3><p>除了使用条件编译指令，代码框架还提供了另一种方式检测某个宏是否被定义。之所以要使用另一种方式，是因为条件编译指令不能使用在宏定义中，而频繁地使用条件编译指令会使代码的可读性大打折扣。实现这个功能的关键代码包括：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// macro.h</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> _MACRO_H_</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _MACRO_H_</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> str_temp(x) #x</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> str(x) str_temp(x)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> isdef(macro) (strcmp(<span class="hljs-meta-string">&quot;&quot;</span> #macro, <span class="hljs-meta-string">&quot;&quot;</span> str(macro)) != 0)</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>其中宏<code>str(x)</code>使用<code>#</code>运算符将<code>x</code>转化为一个字符串。下面举一个例子来说明<code>isdef</code>这个宏是怎么工作的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// main.c</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;macro.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOO 123</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> a = isdef(FOO);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>经过预处理</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -o main.i -E main.c<br></code></pre></td></tr></table></figure><p>main.i中的内容为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// main.i</span><br>...<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> a = (<span class="hljs-built_in">strcmp</span>(<span class="hljs-string">&quot;&quot;</span> <span class="hljs-string">&quot;FOO&quot;</span>, <span class="hljs-string">&quot;&quot;</span> <span class="hljs-string">&quot;123&quot;</span>) != <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>...<br></code></pre></td></tr></table></figure><p>可以发现，<code>strcmp</code>函数的第一个参数对应<code>isdef</code>宏定义中的<code>"" #macro</code>，它直接将宏参数的名称转换为了字符串，而第二个参数对应<code>"" str(macro)</code>，它先将<code>FOO</code>替换为<code>123</code>，然后将<code>123</code>转换为字符串。因此当这两个参数不同时，说明宏已经被定义过。</p><p>    通过上面的分析可以发现，宏<code>isdef</code>不能检测宏定义的值与宏定义名称相同的宏，比如说</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOO FOO</span><br></code></pre></td></tr></table></figure><p>宏<code>FOO</code>在预处理时仍然被替换为<code>FOO</code>，最后将导致错误的结果。</p><p>四、参考资料</p><ul><li><p><a href="https://stackoverflow.com/questions/26099745/test-if-preprocessor-symbol-is-defined-inside-macro">stackoverflow上关于如何判断宏是否被定义的讨论</a></p></li><li><p><a href="https://github.com/NJU-ProjectN/ics-pa">南京大学ics-pa项目</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>NEMU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
