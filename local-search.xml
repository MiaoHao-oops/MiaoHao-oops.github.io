<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>LR(0)分析方法</title>
    <link href="/2022/03/29/LR-0-%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95/"/>
    <url>/2022/03/29/LR-0-%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="基本概念">基本概念</h2><h3 id="项目-item">项目 item</h3><blockquote><p>项目是对文法中产生式的扩展，通过在产生式右部添加<span class="math inline">\(\cdot\)</span>的方法来表示语法分析器在分析过程中的某个状态。</p></blockquote><p>例子：</p><p>对于产生式<span class="math inline">\(A\rightarrow \alpha X\)</span>，它产生以下几个项：</p><p><span class="math display">\[\begin{align}A&amp;\rightarrow \cdot \alpha X &amp;(1)\\ A&amp;\rightarrow \alpha \cdot X &amp;(2)\\ A&amp;\rightarrow \alpha X \cdot &amp;(3)\\ \end{align}\]</span></p><p>其中，</p><ul><li><p>式<span class="math inline">\((1)\)</span>的点号右侧是一个终结符，意味着在当前状态下，分析器期待从输入流中读入符号<span class="math inline">\(\alpha\)</span>，因此它被定义为一个<strong>移入项</strong>。</p></li><li><p>式<span class="math inline">\((2)\)</span>中点号右侧是一个非终结符，此时分析器期待后面的输入归约得到非终结符<span class="math inline">\(X\)</span>，因此它被定义为一个<strong>待约项</strong>。</p></li><li><p>式<span class="math inline">\((3)\)</span>的点号位于整个产生式的结尾，此时意味着分析器将进行归约操作，将<span class="math inline">\(\alpha X\)</span>归约为<span class="math inline">\(A\)</span>，因此它被定义为一个<strong>归约项</strong>。</p></li></ul><h3 id="增广文法-augmented-grammar">增广文法 augmented grammar</h3><p>为了得到唯一的终止产生式，定义一个文法<span class="math inline">\(G\)</span>的增广文法<span class="math inline">\(G^{\prime}\)</span>：</p><blockquote><p>对于文法<span class="math inline">\(G\)</span>的开始符号<span class="math inline">\(S\)</span>，将产生式<span class="math inline">\(S^{\prime}\rightarrow S\)</span>添加到<span class="math inline">\(G\)</span>中，就得到了文法<span class="math inline">\(G^{\prime}\)</span>。</p></blockquote><p>这样，当分析器进入状态<span class="math inline">\(S^{\prime}\rightarrow S\cdot\)</span>时，如果输入流已经读完，就表示进入了接受状态。</p><h3 id="textclosure函数"><span class="math inline">\(\text{CLOSURE}\)</span>函数</h3><p><span class="math inline">\(\text{CLOSURE}\)</span>函数将一个项目集合映射到另一个项目集合，它的输入是项目集合<span class="math inline">\(I\)</span>，输出是该项目集合的闭包<span class="math inline">\(\text{CLOSURE}(I)\)</span>。它的意义在于将一些在状态上等价的项聚集起来形成一个状态，而不是对于文法的每一个项作为一个状态，避免语法分析器的状态数过多。定义<span class="math inline">\(\text{CLOSURE}(I)\)</span>：</p><blockquote><ol type="1"><li>初始，<span class="math inline">\(\text{CLOSURE}(I) = \phi\)</span></li><li><span class="math inline">\(\text{CLOSURE}(I) = \text{CLOSURE}(I)\cup I\)</span></li><li>如果<span class="math inline">\(A\rightarrow \alpha \cdot B \beta \in \text{CLOSURE}(I)\)</span>，并且<span class="math inline">\(\exists B\rightarrow \cdot \gamma \notin \text{CLOSURE}(I)\)</span>，那么<span class="math inline">\(\text{CLOSURE}(I) = \text{CLOSURE}(I)\cup B\rightarrow \cdot \gamma\)</span></li></ol></blockquote><p>不断重复<span class="math inline">\((3)\)</span>直到没有新的项能添加到<span class="math inline">\(\text{CLOSURE}(I)\)</span>中。上面各式的含义是：</p><ul><li><p><span class="math inline">\((2)\)</span>的含义是所有<span class="math inline">\(I\)</span>中的项都在<span class="math inline">\(I\)</span>的闭包中</p></li><li><p><span class="math inline">\((3)\)</span>的含义是如果<span class="math inline">\(\text{CLOSURE}(I)\)</span>中某个项的点号的右侧是一个非终结符，那么以该非终结符为左部且点号在右部最左侧的项也在<span class="math inline">\(\text{CLOSURE}(I)\)</span>中。进一步也就是说如果此时分析器期待对非终结符<span class="math inline">\(B\)</span>的归约，那么它也同样期待着由<span class="math inline">\(B\)</span>产生的那些符号，因为只有那些符号才能归约成<span class="math inline">\(B\)</span>。</p></li></ul><h3 id="textgoto函数"><span class="math inline">\(\text{GOTO}\)</span>函数</h3><p><span class="math inline">\(\text{GOTO}\)</span>函数也将一个项目集合映射到另一个项目集合，它的输入是项目集合<span class="math inline">\(I\)</span>和一个文法符号<span class="math inline">\(X\)</span>，输出是该项目集合中所有项遇到文法符号<span class="math inline">\(X\)</span>后所有后继项的闭包。</p><blockquote><p>后继项：对于项<span class="math inline">\(A\rightarrow X\cdot YZ\)</span>而言，它的后继项就是将点号移动到项右部的下一个文法符号，即<span class="math inline">\(A\rightarrow XY\cdot Z\)</span>。</p></blockquote><p>它的意义是求出分析器状态机中的所有状态转移。定义<span class="math inline">\(\text{GOTO}\)</span>函数：</p><blockquote><p><span class="math inline">\(\text{GOTO}(I, X) = \text{CLOSURE}(\{A\rightarrow \alpha X\cdot \beta \ |\ \forall A\rightarrow \alpha \cdot X \beta \in I \})\)</span></p></blockquote><h3 id="规范textlr0项集族-canonical-lr0-collection">规范<span class="math inline">\(\text{LR}(0)\)</span>项集族 canonical LR(0) collection</h3><p>所谓项集族，指的是项目集合的集合，也就是说项集族中每一个元素都是一个项目的集合。利用<span class="math inline">\(\text{CLOSURE}\)</span>函数和<span class="math inline">\(\text{GOTO}\)</span>函数，可以构造出一个文法的规范<span class="math inline">\(\text{LR}(0)\)</span>项集族。定义规范<span class="math inline">\(\text{LR}(0)\)</span>项集族：</p><blockquote><p><span class="math inline">\(C = \{I_{0}\}\cup \{I\ |\ \exists J\in C, X\in V_{N}\cup V_{T}, I = \text{GOTO}(J, X)\}\)</span></p></blockquote><p>上面表达式的含义是：</p><ul><li><p><span class="math inline">\(C\)</span>中包含了项<span class="math inline">\(S^{\prime}\rightarrow \cdot S\)</span>的闭包。</p></li><li><p>对<span class="math inline">\(C\)</span>中的每一个项目集合<span class="math inline">\(I\)</span>和文法中每一个符号<span class="math inline">\(X\)</span>，如果<span class="math inline">\(\text{GOTO}(I, X)\)</span>不在<span class="math inline">\(C\)</span>中，则将其添加到<span class="math inline">\(C\)</span>中。</p></li></ul><h2 id="textlr0分析器"><span class="math inline">\(\text{LR}(0)\)</span>分析器</h2><h3 id="textlr0分析表的结构"><span class="math inline">\(\text{LR}(0)\)</span>分析表的结构</h3><p><span class="math inline">\(\text{LR}(0)\)</span>分析表是一个二维表格，它的行数等于文法<span class="math inline">\(G\)</span>的规范<span class="math inline">\(\text{LR}(0)\)</span>项集族中元素个数，列数等于<span class="math inline">\(G\)</span>中文法符号的个数。分析表中的每一个单元表示在某个状态下遇到某个文法符号时，下一步需要进行的操作。整个分析表被划分为<span class="math inline">\(\text{ACTION}\)</span>和<span class="math inline">\(\text{GOTO}\)</span>两个区域，落入对应区域的单元分别表示遇到终结符和非终结符时所进行的操作。</p><p>对于<span class="math inline">\(\text{ACTION}\)</span>：</p><ul><li><p>如果为<span class="math inline">\(s_{i}\)</span>，则表示移入（shift）操作，分析器将输入指针指向的符号移入符号栈，然后将状态<span class="math inline">\(S_{i}\)</span>移入状态栈。</p></li><li><p>如果为<span class="math inline">\(r_{i}\)</span>，则表示归约（reduce）操作，分析器将使用第<span class="math inline">\(i\)</span>个产生式对符号栈顶的句柄进行归约操作。</p></li></ul><p>对于<span class="math inline">\(\text{GOTO}\)</span>，单元格中所有的元素都是数字，<span class="math inline">\(j = \text{GOTO}[S_{i}, X]\)</span>表示状态<span class="math inline">\(S_{i}\)</span>遇到栈顶为非终结符<span class="math inline">\(X\)</span>时将状态<span class="math inline">\(S_{j}\)</span>入栈。</p><h3 id="textlr0分析器的结构"><span class="math inline">\(\text{LR}(0)\)</span>分析器的结构</h3><p><span class="math inline">\(\text{LR}(0)\)</span>分析器包含4个主要部分：</p><ul><li><p>输入缓冲</p></li><li><p>符号和状态栈</p></li><li><p><span class="math inline">\(\text{LR}(0)\)</span>分析表</p></li><li><p>驱动程序</p></li></ul><p>它的运行中的格局是：</p><ol type="1"><li>初始格局为：</li></ol><p><span class="math display">\[\begin{align}&amp;S_{0} \\&amp;\$ &amp;a_{1}a_{2}\cdots a_{n}\$\\\end{align}\]</span></p><p>其中<span class="math inline">\(S_{0}\)</span>表示初始状态，对应<span class="math inline">\(S^{\prime}\rightarrow \cdot S\)</span>的项目集闭包。</p><ol start="2" type="1"><li>假设运行时的一个格局是：</li></ol><p><span class="math display">\[\begin{align}&amp;S_{0}S_{1}S_{2}\cdots S_{m} \\&amp;\$ X_{1}X_{2}\cdots X_{m} &amp;a_{i}a_{i + 1}\cdots a_{n}\$\\\end{align}\]</span></p><ul><li><p>若<span class="math inline">\(\text{ACTION}[S_{m}, a_{i}] = s_{x}\)</span>，则进行移入操作，格局变为： <span class="math display">\[\begin{align}&amp;S_{0}S_{1}S_{2}\cdots S_{m}S_{x} \\&amp;\$ X_{1}X_{2}\cdots X_{m}a_{i} &amp;a_{i + 1}\cdots a_{n}\$\\  \end{align}\]</span></p></li><li><p>若<span class="math inline">\(\text{ACTION}[S_{m}, a_{i}] = r_{x}\)</span>，则进行归约操作，使用第<span class="math inline">\(x\)</span>个产生式<span class="math inline">\(A\rightarrow X_{m - (k - 1)}\cdots X_{m}\)</span>，格局变为： <span class="math display">\[\begin{align}&amp;S_{0}S_{1}S_{2}\cdots S_{m - k} \\&amp;\$ X_{1}X_{2}\cdots X_{m - k}A &amp;a_{i}a_{i + 1}\cdots a_{n}\$\\  \end{align}\]</span></p></li></ul><p>而后查找<span class="math inline">\(\text{GOTO}\)</span>表，若<span class="math inline">\(\text{GOTO}[S_{m - k}, A] = y\)</span>，则进行状态转移，格局变为：</p><p><span class="math display">\[\begin{align}&amp;S_{0}S_{1}S_{2}\cdots S_{m - k}S_{y} \\&amp;\$ X_{1}X_{2}\cdots X_{m - k}A &amp;a_{i}a_{i + 1}\cdots a_{n}\$\\  \end{align}\]</span></p><ul><li>若<span class="math inline">\(\text{ACTION}[S_{m}, a_{i}] = \text{acc}\)</span>，则分析成功。</li><li>若<span class="math inline">\(\text{ACTION}[S_{m}, a_{i}] = \text{err}\)</span>，则分析失败。</li></ul><h3 id="构造textlr0分析表">构造<span class="math inline">\(\text{LR}(0)\)</span>分析表</h3><p>构造<span class="math inline">\(\text{LR}(0)\)</span>分析表的方法是：</p><ol type="1"><li><p>首先求文法<span class="math inline">\(G\)</span>的<span class="math inline">\(\text{LR}(0)\)</span>项集族<span class="math inline">\(C\)</span></p></li><li><p>对于<span class="math inline">\(C\)</span>中的每一个项目集<span class="math inline">\(I\)</span>：</p><ol type="1"><li><p>如果<span class="math inline">\(\text{GOTO}(I, \alpha) = I^{\prime}\)</span>，则<span class="math inline">\(\text{ACTION}[I, \alpha] = S_{I^{\prime}}\)</span></p></li><li><p>如果<span class="math inline">\(\text{GOTO}(I, A) = I^{\prime}\)</span>，则<span class="math inline">\(\text{GOTO}[I, A] = I^{\prime}\)</span></p></li><li><p>如果<span class="math inline">\(I\)</span>中有归约项，则<span class="math inline">\(\forall \alpha, \text{ACTION}[I, \alpha] = r_{x}\)</span>，其中<span class="math inline">\(x\)</span>为归约项对应产生式的编号</p></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nju-pa摸鱼记4-指令的生命周期</title>
    <link href="/2022/02/07/nju-pa%E6%91%B8%E9%B1%BC%E8%AE%B04-%E6%8C%87%E4%BB%A4%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>/2022/02/07/nju-pa%E6%91%B8%E9%B1%BC%E8%AE%B04-%E6%8C%87%E4%BB%A4%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="一前言">一、前言</h2><p>在之前的3篇专栏中，主要探讨了NEMU中一些巧妙的宏定义，以及关于计算模型的思考。从本篇开始，将专注于“模拟器如何模拟真实计算机”这一话题。计算机最基础、最核心的功能是执行指令，因此执行指令也是NEMU模拟器最基本的功能。</p><h2 id="二计算机中指令的生命周期">二、计算机中指令的生命周期</h2><p>对于精简指令集系统，五级流水线是一种经典的CPU核结构，它将一条指令的处理过程分为5个阶段：</p><ul><li><p>取指：维护PC寄存器，发起访存请求从内存中取出指令；</p></li><li><p>译码：翻译取出的指令，确定指令的操作方法和操作对象；</p></li><li><p>执行：通过运算部件（如ALU，乘法器等）对操作对象进行算</p></li><li><p>访存：若为访存类指令，则在这个阶段进行访存；</p></li><li><p>写回：将指令的运算、访存等结果写回目的寄存器。</p></li></ul><p>这五个阶段轮流往复地运行，计算机便能自动地运行下去。</p><h2 id="三nemu中指令的生命周期">三、NEMU中指令的生命周期</h2><p>在真实的CPU中，为了提升效率，在取指完成后PC跳转到紧接着当前指令的下一条指令继续取指，如果遇到跳转指令，可以冲刷流水线或者使用分支预测等技术增大取指的正确率。而在模拟器中则没有对于性能的要求，完全可以等到指令执行结束再更新PC，然后开始取下一条指令，在NEMU中，指令执行阶段的划分为：</p><ul><li><p>取指：通过PC值访问“内存”，取出指令；</p></li><li><p>译码：分析指令，确定操作方法和操作数；</p></li><li><p>执行：通过对应的处理函数对操作数进行处理，同时将结果写回“寄存器”；</p></li><li><p>更新PC：根据指令的执行情况更新PC，此PC一定是正确的PC。</p></li></ul><p>下面是一条语句在NEMU中的执行过程：</p><ol type="1"><li><p>NEMU调用定义在<code>src/cpu/cpu-exec.c</code>中的<code>cpu_exec()</code>函数，该函数将反复进行取指、译码、执行、更新PC这个过程，直到遇到停机、断点或是什么别的情况。</p></li><li><p><code>cpu_exec()</code>函数的核心是一个死循环，其中包括了<code>fetch_decode_exec_updatepc()</code>函数，该函数的定义如下：</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// src/cpu/cpu-exec.c</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fetch_decode_exec_updatepc</span><span class="hljs-params">(Decode *s)</span> </span>&#123;<br>  fetch_decode(s, cpu.pc);  <span class="hljs-comment">// fetch and decode</span><br>  s-&gt;EHelper(s);            <span class="hljs-comment">// exec</span><br>  cpu.pc = s-&gt;dnpc;         <span class="hljs-comment">// update pc</span><br>&#125;<br></code></pre></td></tr></table></figure><p>它将取指译码、执行和更新PC解构，分别对应函数中的三条语句。</p><ol start="3" type="1"><li>首先调用<code>fetch_decode()</code>函数，该函数的核心功能可以简化如下：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// src/cpu/cpu-exec.c</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fetch_decode</span><span class="hljs-params">(Decode *s, <span class="hljs-keyword">vaddr_t</span> pc)</span> </span>&#123;<br>  s-&gt;pc = pc;<br>  s-&gt;snpc = pc;<br>  <span class="hljs-keyword">int</span> idx = isa_fetch_decode(s);<br>  s-&gt;dnpc = s-&gt;snpc;<br>  s-&gt;EHelper = g_exec_table[idx];<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>fetch_decode()</code>函数中，通过<code>isa_fetch_decode()</code>函数得到指令所对应的序号，该序号和这条指令对应处理函数在列表中的下标相同，然后为函数指针<code>s-&gt;EHelper</code>赋值为对应的处理函数。</p><ol start="4" type="1"><li>进入<code>isa_fetch_decode()</code>函数，取指和译码进一步被解构，<code>instr_fetch()</code>函数负责与内存交互取指令；<code>table_main()</code>函数是译码函数，将取回的函数和模式串一一比对，若匹配成功则返回该指令对应的序号，若失败则返回一个无效指令序号，这将导致NEMU产生运行异常报给用户。同时在译码时，也将获取该指令的所有操作数，包括立即数和寄存器，它们都将被存在<code>Decode</code>结构中。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// src/isa/risCV64/instr/decode.c</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isa_fetch_decode</span><span class="hljs-params">(Decode *s)</span> </span>&#123;<br>  s-&gt;isa.instr.val = instr_fetch(&amp;s-&gt;snpc, <span class="hljs-number">4</span>);<br>  <span class="hljs-keyword">int</span> idx = table_main(s);<br>  <span class="hljs-keyword">return</span> idx;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="5" type="1"><li>现在返回到<code>fetch_decode_exec_updatepc()</code>函数中，它的第二条语句调用了<code>s-&gt;EHelper()</code>函数执行该指令，这些执行函数被定义在<code>src/isa/$ISA/instr</code>下的若干<code>.h</code>文件中，比如说lui指令的处理函数：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// src/isa/$ISA/instr/compute.h</span><br>def_EHelper(lui) &#123;<br>  rtl_li(s, ddest, id_src1-&gt;imm);<br>&#125;<br></code></pre></td></tr></table></figure><p>它是由更加细化的rtl级函数<code>rtl_li</code>所完成的，所有指令的终点都是若干rtl函数，也就是将指令拆解成“微指令”。</p><ol start="6" type="1"><li>执行完<code>s-&gt;EHelper()</code>后，语句</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">cpu.pc = s-&gt;dnpc;         <span class="hljs-comment">// update pc</span><br></code></pre></td></tr></table></figure><p>将完成更新PC的过程。</p>]]></content>
    
    
    <categories>
      
      <category>NEMU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C语言</tag>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nju-pa摸鱼记3-NEMU中宏的源码阅读</title>
    <link href="/2022/02/05/nju-pa%E6%91%B8%E9%B1%BC%E8%AE%B03-nemu%E4%B8%AD%E5%AE%8F%E7%9A%84%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <url>/2022/02/05/nju-pa%E6%91%B8%E9%B1%BC%E8%AE%B03-nemu%E4%B8%AD%E5%AE%8F%E7%9A%84%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="一前言">一、前言</h2><p>有关于如何使用宏定义检测某个宏是否存在在前两篇专栏中已经讨论得差不多了，本篇将目光转回NEMU的代码框架，探讨<code>include/macro.h</code>中的有关宏的原理。</p><h2 id="二macro.h">二、macro.h</h2><p>NEMU代码框架中的<code>include/macro.h</code>文件中定义了一些列宏</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// keep the code if a boolean macro is defined</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IFDEF(macro, ...) MUXDEF(macro, __KEEP, __IGNORE)(__VA_ARGS__)</span><br><span class="hljs-comment">// keep the code if a boolean macro is undefined</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IFNDEF(macro, ...) MUXNDEF(macro, __KEEP, __IGNORE)(__VA_ARGS__)</span><br><span class="hljs-comment">// keep the code if a boolean macro is defined to 1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IFONE(macro, ...) MUXONE(macro, __KEEP, __IGNORE)(__VA_ARGS__)</span><br><span class="hljs-comment">// keep the code if a boolean macro is defined to 0</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IFZERO(macro, ...) MUXZERO(macro, __KEEP, __IGNORE)(__VA_ARGS__)</span><br></code></pre></td></tr></table></figure><p>从注释中可以看出，这些宏都是根据布尔宏（即若被定义则只有可能被定义为<code>0</code>或<code>1</code>）是否被定义或者定义为什么值而决定后面变长参数表中的代码在预编译时是否被保留。由于它们的原理是相通的，所以这里只分析宏<code>IFDEF(macro, ...)</code>，并使用自顶向下的方法，从顶层宏定义一直追踪到最深层的定义。</p><p>宏<code>IFDEF(macro, ...)</code>的第一个参数是一个布尔宏，第二个参数是变长列表，可以传入语句或代码块。若宏<code>macro</code>被定义则保留代码，反之什么都不保留。在它的顶层定义中使用了宏<code>MUXDEF(macro, a, b)</code>，它是一个广义的选择器，不管<code>a</code>和<code>b</code>的类型是什么。在这里，<code>__KEEP</code>和<code>__IGNORE</code>是两个宏函数，它们的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __IGNORE(...)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __KEEP(...) __VA_ARGS__</span><br></code></pre></td></tr></table></figure><p>它们的功能和它们的名字相同，<code>__KEEP</code>将保留所有的输入，而<code>__IGNORE</code>将所有输入舍弃。所以，在这里宏<code>IFDEF</code>使用宏<code>MUXDEF</code>选择<code>__KEEP</code>宏函数或<code>__IGNORE</code>宏函数中的一个，然后再将选出来的宏函数作用到后面的代码上，决定这段代码的去留。</p><p>举个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;macro.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOO 1</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>IFDEF(FOO, <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, World!\n&quot;</span>);)<br>   <span class="hljs-comment">// =&gt; __KEEP(printf(&quot;Hello, World!\n&quot;);)</span><br>   <span class="hljs-comment">// =&gt; printf(&quot;Hello, World!\n&quot;);</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的例子中，因为宏<code>FOO</code>已经被定义了，所以再<code>MUXDEF</code>的作用下，宏函数<code>__KEEP</code>被选择出来作用在<code>printf</code>语句上，最后这个语句被保留了下来。</p><p>接下来看宏<code>MUXDEF</code>是怎么实现的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CHOOSE2nd(a, b, ...) b</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MUX_WITH_COMMA(contain_comma, a, b) CHOOSE2nd(contain_comma a, b)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MUX_MACRO_PROPERTY(p, macro, a, b) MUX_WITH_COMMA(concat(p, macro), a, b)</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __P_DEF_0  X,</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __P_DEF_1  X,</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MUXDEF(macro, X, Y) MUX_MACRO_PROPERTY(__P_DEF_, macro, X, Y)</span><br></code></pre></td></tr></table></figure><p>宏<code>MUXDEF</code>又调用了宏<code>MUX_MACRO_PROPERTY</code>，它的作用是使用宏<code>concat</code>为宏<code>macro</code>添加一个前缀<code>__P_DEF_</code>，然后将处理过的宏传给宏<code>MUX_WITH_COMMA</code>。上一篇所介绍的技术在这里体现了出来：如果布尔宏被定义了，那么加上前缀后将得到<code>__P_DEF_0</code>或<code>__P_DEF_1</code>，然后再定义这两个宏，通过逗号控制最后传入<code>CHOOSE2nd</code>宏的第二个参数为<code>a</code>，最终选择结果为<code>a</code>；如果宏没有被定义，那么加上前缀后的宏不会再进行解释，那么“<code>contain_comma a</code>”部分将作为传入<code>CHOOSE2nd</code>的第一个参数，最终选择结果为<code>b</code>。</p>]]></content>
    
    
    <categories>
      
      <category>NEMU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>My First Article</title>
    <link href="/2022/02/02/My-First-Article/"/>
    <url>/2022/02/02/My-First-Article/</url>
    
    <content type="html"><![CDATA[<h2 id="chapter-1">Chapter 1</h2><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, World!\n&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="chapter-2">Chapter 2</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;Hello, World!\n&quot;</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="chapter-3">Chapter 3</h2><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/usr/bin/bash</span><br>echo &quot;Hello, World!&quot;<br></code></pre></td></tr></table></figure><h2 id="chapter-4">Chapter 4</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-meta">#!/usr/bin/ruby</span><br>puts <span class="hljs-string">&quot;Hello, World!&quot;</span><br></code></pre></td></tr></table></figure><h2 id="chapter-5">Chapter 5</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello, World!&quot;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>try latex</title>
    <link href="/2022/02/01/try-latex/"/>
    <url>/2022/02/01/try-latex/</url>
    
    <content type="html"><![CDATA[<p><span class="math inline">\(a=\lambda x.x\)</span></p><p>Hello!</p><p><span class="math display">\[A = \begin{bmatrix}        a_{11}    &amp; a_{12}    &amp; ...    &amp; a_{1n}\\        a_{21}    &amp; a_{22}    &amp; ...    &amp; a_{2n}\\        a_{31}    &amp; a_{22}    &amp; ...    &amp; a_{3n}\\        \vdots    &amp; \vdots    &amp; \ddots &amp; \vdots\\        a_{n1}    &amp; a_{n2}    &amp; ... &amp; a_{nn}\\    \end{bmatrix} , b = \begin{bmatrix}        b_{1}  \\        b_{2}  \\        b_{3}  \\        \vdots \\        b_{n}  \\    \end{bmatrix}\]</span></p><p><img src="/img/a.png" /></p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LaTeX</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nju-pa摸鱼记2-计算机与λ演算</title>
    <link href="/2022/02/01/nju-pa%E6%91%B8%E9%B1%BC%E8%AE%B02-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8E%CE%BB%E6%BC%94%E7%AE%97/"/>
    <url>/2022/02/01/nju-pa%E6%91%B8%E9%B1%BC%E8%AE%B02-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8E%CE%BB%E6%BC%94%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h2 id="一前言">一、前言</h2><p>在<a href="https://miaohao-oops.github.io/2022/01/31/nju-pa%E6%91%B8%E9%B1%BC%E8%AE%B01-%E5%AE%8F%E7%9A%84%E5%A6%99%E7%94%A8/">上一篇</a>中，讨论了如何使用预处理指令或是宏来识别某个宏是否被定义，以实现通过配置进行有选择的编译。不过，仅使用上一篇讨论的<code>isdef</code>宏还不能达到和预处理指令一样的效果，本篇将继续讨论框架中如何使用宏来实现“<strong>如果某个宏被定义，则预处理后保留某些语句或代码块，反之抛弃这些部分</strong>”的功能。之所以提到<span class="math inline">\(\lambda\)</span>演算，是由于我在搞明白代码框架中的宏是如何运作之后，发现其颇有“函数式编程”的风格，而<span class="math inline">\(\lambda\)</span>演算是函数式编程的基础，遂记录于此。</p><h2 id="二浅谈lambda演算">二、浅谈<span class="math inline">\(\lambda\)</span>演算</h2><h3 id="简介">1、简介</h3><p><span class="math inline">\(\lambda\)</span>演算是一种和图灵机等价的计算模型（<strong>丘奇-图灵论题</strong>），它可以描述任何可计算问题，又称为“最小的编程语言”。简单来说，<span class="math inline">\(\lambda\)</span>演算的核心是<strong>抽象化定义的函数</strong>，它的参数没有类型的限制，可以是数字，函数或者字符串等等。一个最基础的函数是恒等函数：</p><p><span class="math display">\[\lambda x.x\]</span></p><p>其中<span class="math inline">\(\lambda\)</span>后的<span class="math inline">\(x\)</span>是这个函数的<strong>输入</strong>，点号后的<span class="math inline">\(x\)</span>是函数的<strong>输出</strong>。可以将这个函数作用在变量<span class="math inline">\(a\)</span>上，就得到：</p><p><span class="math display">\[\lambda x.x(a) = a\]</span></p><p>通过<strong>柯里化</strong>方法，可以定义二输入函数：</p><p><span class="math display">\[\lambda x.\lambda y.x+y\]</span></p><p>其中<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>是该函数的两个输入，该函数的输出是两个输入的和。</p><h3 id="用抽象化函数表示布尔逻辑">2、用抽象化函数表示布尔逻辑</h3><p>在<span class="math inline">\(\lambda\)</span>演算中，没有布尔值的概念，但是可以定义两个函数来表示布尔逻辑：</p><p><span class="math display">\[\text{TRUE} = \lambda x.\lambda y.x\]</span></p><p><span class="math display">\[\text{FALSE} = \lambda x.\lambda y.y\]</span></p><p>用自然语言来描述<span class="math inline">\(\text{TRUE}\)</span>函数的作用：“输入两个参数<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>，输出第一个参数”，<span class="math inline">\(\text{FALSE}\)</span>函数的功能同理。这样的话，可以把布尔值<span class="math inline">\(1\)</span>和<span class="math inline">\(0\)</span>分别定义成<span class="math inline">\(\text{TRUE}\)</span>函数和<span class="math inline">\(\text{FALSE}\)</span>函数。接下来可以定义最基本的非、与、或运算：</p><p><span class="math display">\[\begin{cases}\text{NOT} &amp;= \lambda x.x\ \text{FALSE}\ \text{TRUE} \\\text{AND} &amp;= \lambda x.\lambda y.x\ y\ \text{FALSE} \\\text{OR} &amp;= \lambda x.\lambda y. x\ \text{TRUE}\ y \\\end{cases}\]</span></p><p>上面的三个函数都是利用了<span class="math inline">\(\lambda\)</span>演算中参数可以是函数的性质，输入的<span class="math inline">\(\text{TRUE}\)</span>或<span class="math inline">\(\text{FALSE}\)</span>都可以作为函数继续运算，下面以<span class="math inline">\(\text{AND}\)</span>函数为例进行验证：</p><p><span class="math display">\[\begin{align*}\text{AND}(\text{FALSE})(\text{FALSE}) &amp;= \text{FALSE}(\text{FALSE})(\text{FALSE}) \\&amp;= \text{FALSE}\end{align*}\]</span></p><p><span class="math display">\[\begin{align*}\text{AND}(\text{FALSE})(\text{TRUE}) &amp;= \text{FALSE}(\text{TRUE})(\text{FALSE}) \\&amp;= \text{FALSE}\end{align*}\]</span></p><p><span class="math display">\[\begin{align*}\text{AND}(\text{TRUE})(\text{FALSE}) &amp;= \text{TRUE}(\text{FALSE})(\text{FALSE}) \\&amp;= \text{FALSE}\end{align*}\]</span></p><p><span class="math display">\[\begin{align*}\text{AND}(\text{TRUE})(\text{TRUE}) &amp;= \text{TRUE}(\text{TRUE})(\text{FALSE}) \\&amp;= \text{TRUE}\end{align*}\]</span></p><p>当且仅当<span class="math inline">\(x\)</span>与<span class="math inline">\(y\)</span>均为<span class="math inline">\(\text{TRUE}\)</span>时，<span class="math inline">\(\text{AND}\)</span>的值为<span class="math inline">\(\text{TRUE}\)</span>。因此，函数<span class="math inline">\(\text{AND}\)</span>的定义正确。</p><h3 id="lambda演算与计算机的联系">3、<span class="math inline">\(\lambda\)</span>演算与计算机的联系</h3><p><span class="math inline">\(\text{TRUE}\)</span>和<span class="math inline">\(\text{FALSE}\)</span>这两个函数的功能用一个词来概括就是“<strong>选择</strong>”，在数字电路中，也有一个可以做选择的模块：<strong>选择器</strong>。选择器有三个输入端口<span class="math inline">\(a\)</span>，<span class="math inline">\(b\)</span>和<span class="math inline">\(sel\)</span>，一个输出端口<span class="math inline">\(y\)</span>，根据<span class="math inline">\(sel\)</span>的值可以决定<span class="math inline">\(y\)</span>的值是和<span class="math inline">\(a\)</span>相同还是和<span class="math inline">\(b\)</span>相同（比如当<span class="math inline">\(sel = \text{TRUE}\)</span>时，<span class="math inline">\(y=a\)</span>；<span class="math inline">\(sel = \text{FALSE}\)</span>时，<span class="math inline">\(y = b\)</span>），类似的，可以构建函数：</p><p><span class="math display">\[\text{MUX} = \lambda a.\lambda b.\lambda sel.sel\ a\ b\]</span></p><p>这个函数看起来有些奇怪，似乎只是把三个参数排列在一起输出了，并不能看出其中的“选择功能”，但是<span class="math inline">\(\lambda\)</span>表达式的特别之处就在于输入的参数可以是函数，从而可以进一步作用在后面的参数上。下面来验证一下的功能：</p><p><span class="math display">\[\begin{align*}\text{MUX}(a)(b)(\text{TRUE}) &amp;= \text{TRUE}(a)(b) = a \\\text{MUX}(a)(b)(\text{FALSE}) &amp;= \text{FALSE}(a)(b) = b \\\end{align*}\]</span></p><p><span class="math inline">\(\text{MUX}\)</span>函数的工作行为与选择器完全一致！放在硬件中，<span class="math inline">\(\text{MUX}\)</span>函数是选择器，而在软件中，它就是<code>if</code>语句：</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (sel) &#123;<br>  a<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  b<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三更进一步">三、更进一步</h2><p>有了<span class="math inline">\(\text{MUX}\)</span>函数，就可以实现宏定义的“条件编译”了，只需要改变一下它0的输入参数即可：</p><p><span class="math display">\[\text{MUX}(code\_block, , \text{isdef}(macro))\]</span></p><p>其中<code>isdef</code>是在上一篇定义的宏函数，如果<span class="math inline">\(macro\)</span>已经被定义了，它将返回<span class="math inline">\(\text{TRUE}\)</span>，反之返回<span class="math inline">\(\text{FALSE}\)</span>。<span class="math inline">\(code_block\)</span>是在宏<span class="math inline">\(macro\)</span>被定义后希望在预处理时被保留下来的代码块。传给<span class="math inline">\(\text{MUX}\)</span>函数的第二个参数是一个空串，也就是说在<span class="math inline">\(macro\)</span>未被定义时，预处理后会留下一个空串，对于最后的预处理结果没有任何影响。</p><p>通过上面的抽象定义，已经实现了预期的功能，但是到C语言中，还面临着一些细节问题。首先，<code>isdef</code>的值是<code>1</code>或<code>0</code>，而不是上面定义的和函数。这就导致C语言预处理器并不会把<code>isdef</code>替换为<code>1</code>或<code>0</code>后再当作一个“函数”来解释。其次，<code>isdef</code>中使用了<code>strcmp</code>函数，这显然不能在函数外面使用，函数的运行结果在运行时才被计算出来。</p><p>对于第一个问题，如何将<code>isdef</code>的值解释为一个函数呢？由于<code>1</code>和<code>0</code>在C语言中被解释为整型字面量，所以可以给这个<code>1</code>或者<code>0</code>“加点东西”，然后定义新的宏，这里用到了<code>##</code>运算符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> concat(a, b) a ## b</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MUX_MID(a, b, p, sel) MUX(a, b, concat(p, sel))</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MUX_OUT(a, b, sel) MUX_MID(a, b, PREFIX_, sel)</span><br></code></pre></td></tr></table></figure><p>宏<code>concat</code>将两个参数粘连起来，<code>MUX</code>仍然是上面抽象的函数。假设<code>MUX_OUT</code>的输入参数是<code>(code_block, , isdef(foo)</code>，并且宏<code>foo</code>已经被定义过，先不考虑其他问题，经过宏<code>MUX_MID</code>和<code>concat</code>，最终传入<code>MUX</code>的参数将会变为<code>(code_block, , PREFIX_1)</code>。如果我们继续定义宏函数<code>PREFIX_1</code>和<code>PREFIX_0</code>，就可以解决第一个问题了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TRUE(a, b) a</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FALSE(a, b) b</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PREFIX_1(a, b) TRUE(a, b)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PREFIX_0(a, b) FALSE(a, b)\</span><br></code></pre></td></tr></table></figure><p>这里定义的<code>TRUE</code>和<code>FALSE</code>宏函数其实就是上面<span class="math inline">\(\lambda\)</span>演算中的<span class="math inline">\(\text{TRUE}\)</span>和<span class="math inline">\(\text{FALSE}\)</span>！现在，考虑宏<code>MUX</code>怎么定义，我们想要将最后的<code>PREFIX_1</code>或者<code>PREFIX_0</code>作用在<code>a</code>和<code>b</code>上，那么只需要改一下参数的顺序，再加个括号就行了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MUX(a, b, sel) sel(a, b)</span><br></code></pre></td></tr></table></figure><p>下面来看第二个问题，宏<code>isdef</code>在预处理阶段不会被替换为<code>1</code>或<code>0</code>，因此，不能通过<code>MUX_OUT(a, b, isdef(macro))</code>来使用这个宏，这样肯定是有问题的。需要一个宏，能在预处理阶段就产生<code>1</code>或<code>0</code>的结果。由于我们是在配置编译时使用，所以对于某个选项，要么它被定义了，要么它没被定义，而被定义的宏我们并不在乎它是什么值，所以可以限制为：“一旦定义，就将它定义为<code>t</code>”（这个限制只在本篇中成立）。</p><p>再整理一下，现在需要一个宏，来检测一个“一旦定义，就被一定被定义成<code>t</code>”的宏是否被定义，如果被定义了，预处理时它会被替换成<code>1</code>，否则被替换成<code>0</code>。在这个假设下，被定义了的宏会被替换为<code>t</code>，而没有被定义的宏在预处理阶段会保留为宏名。可以使用刚才的“加点东西”技术，把替换后的<code>t</code>再进一步替换为别的东西：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> choose2nd(a, b, ...) b</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PREFIX_t t,</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> choose2nd_mid(p_macro, a, b) choose2nd(p_macro a, b)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> choose2nd_out(macro, a, b) choose2nd_mid(concat(PREFIX_, macro), a, b)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IFDEF(macro) choose2nd_out(macro, 1, 0)</span><br></code></pre></td></tr></table></figure><p>这一系列宏的关键之处在于<code>choose2nd_mid</code>宏定义中<code>p_macro</code>和<code>a</code>之间没有逗号，如果<code>macro</code>被定义成了<code>t</code>，则会被替换为“<code>t,</code>”（<code>t</code>后面有一个逗号分隔），从而成为了第二个参数；当未被定义或者被定义成别的，是第二个参数。</p><p>上面的讨论中已经涉及了大部分NEMU框架中所使用的技巧和方法，实现这些宏的思路与<span class="math inline">\(\lambda\)</span>演算关系密切，这种思路也许就是“函数式编程”。</p><h2 id="四参考资料">四、参考资料</h2><ul><li><p><a href="https://github.com/NJU-ProjectN/ics-pa">南京大学ics-pa在github上的项目</a></p></li><li><p><a href="https://www.bilibili.com/video/BV1VA411H7Ym?share_source=copy_web"><span class="math inline">\(\lambda\)</span>演算简介</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>NEMU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C语言</tag>
      
      <tag>理论计算机科学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nju-pa摸鱼记1-宏的妙用</title>
    <link href="/2022/01/31/nju-pa%E6%91%B8%E9%B1%BC%E8%AE%B01-%E5%AE%8F%E7%9A%84%E5%A6%99%E7%94%A8/"/>
    <url>/2022/01/31/nju-pa%E6%91%B8%E9%B1%BC%E8%AE%B01-%E5%AE%8F%E7%9A%84%E5%A6%99%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="一前言">一、前言</h2><p>上学期在课内学习了《计算机体系结构》，一直对最后一章老师讲到的硬件模拟器念念不忘，好奇它的工作原理。好巧不巧，某日在我刷github的时候南京大学的<a href="https://github.com/NJU-ProjectN/ics-pa">ics-pa项目</a>出现在了我的首页推荐中，于是我便打算利用寒假的时间过一下这个项目，并通过<a href="https://www.bilibili.com/read/cv15072569">B站的专栏</a>（现在同步到我的个人博客上）记录一些新的知识或者是心得体会。</p><h2 id="二使用宏配置编译选项">二、使用宏配置编译选项</h2><p>在项目代码进行编译前，需要先使用</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">make menuconfig<br></code></pre></td></tr></table></figure><p>对项目进行配置，在勾选了一些选项退出后，<code>menuconfig</code>会根据之前的选项生成一些宏保存到若干文件中，供之后的.c文件或Makefile文件所包含（使用include）。这样，在C语言源文件或makefile脚本中通过对这些宏加以判断，就可以在编译时使用或抛弃某些特定的功能。</p><h2 id="三c语言中检测宏是否被定义">三、C语言中检测宏是否被定义</h2><h3 id="使用条件编译指令">1、使用条件编译指令</h3><p>在C语言源文件中，可以使用条件编译指令</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> FOO</span><br>  ...<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>将宏<code>FOO</code>对应功能的代码包围起来，如果在<code>menuconfig</code>中勾选了该宏所对应的选项，则宏<code>FOO</code>会被定义，最终这段代码也会被编译。</p><h3 id="使用宏定义">2、使用宏定义</h3><p>除了使用条件编译指令，代码框架还提供了另一种方式检测某个宏是否被定义。之所以要使用另一种方式，是因为条件编译指令不能使用在宏定义中，而频繁地使用条件编译指令会使代码的可读性大打折扣。实现这个功能的关键代码包括：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// macro.h</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> _MACRO_H_</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _MACRO_H_</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> str_temp(x) #x</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> str(x) str_temp(x)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> isdef(macro) (strcmp(<span class="hljs-meta-string">&quot;&quot;</span> #macro, <span class="hljs-meta-string">&quot;&quot;</span> str(macro)) != 0)</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>其中宏<code>str(x)</code>使用<code>#</code>运算符将<code>x</code>转化为一个字符串。下面举一个例子来说明<code>isdef</code>这个宏是怎么工作的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// main.c</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;macro.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOO 123</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> a = isdef(FOO);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>经过预处理</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -o main.i -E main.c<br></code></pre></td></tr></table></figure><p>main.i中的内容为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// main.i</span><br>...<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> a = (<span class="hljs-built_in">strcmp</span>(<span class="hljs-string">&quot;&quot;</span> <span class="hljs-string">&quot;FOO&quot;</span>, <span class="hljs-string">&quot;&quot;</span> <span class="hljs-string">&quot;123&quot;</span>) != <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>...<br></code></pre></td></tr></table></figure><p>可以发现，<code>strcmp</code>函数的第一个参数对应<code>isdef</code>宏定义中的<code>"" #macro</code>，它直接将宏参数的名称转换为了字符串，而第二个参数对应<code>"" str(macro)</code>，它先将<code>FOO</code>替换为<code>123</code>，然后将<code>123</code>转换为字符串。因此当这两个参数不同时，说明宏已经被定义过。</p><p>    通过上面的分析可以发现，宏<code>isdef</code>不能检测宏定义的值与宏定义名称相同的宏，比如说</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOO FOO</span><br></code></pre></td></tr></table></figure><p>宏<code>FOO</code>在预处理时仍然被替换为<code>FOO</code>，最后将导致错误的结果。</p><p>四、参考资料</p><ul><li><p><a href="https://stackoverflow.com/questions/26099745/test-if-preprocessor-symbol-is-defined-inside-macro">stackoverflow上关于如何判断宏是否被定义的讨论</a></p></li><li><p><a href="https://github.com/NJU-ProjectN/ics-pa">南京大学ics-pa项目</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>NEMU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/1970/01/01/hello-world/"/>
    <url>/1970/01/01/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
